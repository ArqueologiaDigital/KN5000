{"id":"kn5000-001","title":"LLVM: Symbolic labels, comment cleanup, and label shift bug fix","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T01:34:55.495526267-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T01:35:14.856156882-03:00","closed_at":"2026-02-22T01:35:14.856156882-03:00","close_reason":"Closed","comments":[{"id":145,"issue_id":"kn5000-001","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Documenting completed work.","created_at":"2026-02-22T04:34:59Z"},{"id":146,"issue_id":"kn5000-001","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All work done across 7 commits (ec2df44 through 411f2ec):\n\n1. Symbolic JP/CALL labels: ADDR_TO_LABEL pre-pass maps 36,895 addresses to label names. JP/CALL now use symbolic names instead of hex addresses.\n\n2. Drop redundant ASL comments: Native instructions no longer carry auto-generated comments restating the mnemonic. Same for .ascii/.asciz.\n\n3. Symbolic .long: 9,766 numeric .long values replaced with symbolic label references.\n\n4. Label-only segment labels: 4,344 emitted inline + 7,503 via .set. Content LABEL_XXXXXX on instruction lines use .set (103 cases).\n\n5. DW label arithmetic: 30 dispatch table entries converted to symbolic A-B form across 3 dispatch tables.\n\n6. Label shift bug fix: Data directives at exhausted block boundaries now get re-converted after block transition, fixing shifted label content (e.g. FILETYPE_SIG labels).\n\nAll changes verified: 100% byte-identical ROM match.","created_at":"2026-02-22T04:35:11Z"},{"id":147,"issue_id":"kn5000-001","author":"Felipe Correa da Silva Sanches","text":"Additional work: Expanded .long symbolization from 9,766 to 15,089 references (commit a1561fe). Enhanced pre-pass tracks addresses through data directives and binclude files. Split into reliable (JP/CALL) and all (.long) maps to prevent instruction sizing errors from corrupting byte-matching.","created_at":"2026-02-22T06:32:13Z"},{"id":148,"issue_id":"kn5000-001","author":"Felipe Correa da Silva Sanches","text":"Additional: moved address comments to label lines, split mixed byte/string DB lines (commit 7a7bc16). 100% byte-match preserved.","created_at":"2026-02-22T06:42:51Z"},{"id":149,"issue_id":"kn5000-001","author":"Felipe Correa da Silva Sanches","text":"Added comprehensive LLVM fallback report (commit 857a75f): 126,730 .byte fallback lines analyzed, 49 unique mnemonics catalogued, 13 priorities identified. Top 3 targets (JR/JRL/CALR, displacement addressing, LDA) would bring native coverage from 41.7% to 75.1%.","created_at":"2026-02-22T06:51:23Z"}]}
{"id":"kn5000-061","title":"Sound: Trace main CPU to Sub CPU command protocol","description":"Document how main CPU sends commands to sub CPU for sound generation. Trace latch communication at 0x120000. Document: note-on/off commands, program change, pitch bend, volume, pan, effects parameters. Create command reference.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:31.530760739-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:49:12.972115254Z","closed_at":"2026-02-28T00:49:12.972115254Z","close_reason":"MIDI command format and voice processing fully documented. All command byte formats, CC numbers, and voice parameter structures reverse engineered.","comments":[{"id":1,"issue_id":"kn5000-061","author":"Felipe Correa da Silva Sanches","text":"Substantially addressed by audio subsystem reverse engineering:\n\n- Documented Audio_Lock_Acquire/Release mechanism for serializing access\n- Documented Audio_DMA_Transfer for bulk data transfer\n- Documented command dispatch table (CMD_DISPATCH_TABLE) with 8 handler ranges\n- Documented ring buffer at 0x2B0D for MIDI-like command data\n- Documented InterCPU_Latch_Setup and InterCPU_DMA_Send routines\n- All findings added to inter-cpu-protocol.md and audio-subsystem.md\n\nRemaining: Document exact byte formats for each command type.","created_at":"2026-01-30T04:02:50Z"},{"id":349,"issue_id":"kn5000-061","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on documenting exact byte formats for each command type.","created_at":"2026-02-28T00:46:01Z"},{"id":350,"issue_id":"kn5000-061","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Completed. Documented exact byte formats for all MIDI commands:\n- Command byte encoding: handler (bits 7-5) + length (bits 4-0)\n- MIDI messages: Note On/Off, CC, Program Change, Pitch Bend, Channel Pressure, System\n- 26 MIDI channels supported, 287-byte per-channel voice structures at 0x041381\n- Standard CCs: ModWheel, Volume, Pan, Expression, Sustain, Sostenuto, Soft, Portamento\n- Proprietary CCs: 0x78-0x81 (extended), 0x91-0x9D (effects depth)\n- Voice processing: allocation, pitch/velocity setting, note-off release\n- Special commands: E1 (bulk transfer), E2 (extended params), E3 (payload signal)\n- All findings added to inter-cpu-protocol.md","created_at":"2026-02-28T00:49:12Z"}]}
{"id":"kn5000-07bj","title":"Milestone: Zero .byte fallbacks across all 6 ROMs (279,441 native)","status":"closed","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T11:59:20.424195665-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:59:25.216231146-03:00","closed_at":"2026-02-23T11:59:25.216231146-03:00","close_reason":"Closed"}
{"id":"kn5000-0bq","title":"FeatureDemo: Document demo sequence and timing","description":"Create complete documentation of the Feature Demo: slide order, timing between slides, which MIDI plays when, user interaction points (if any), loop behavior. Add screenshots/video to documentation website.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:58:26.227227734-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:18:00.606103226Z","closed_at":"2026-02-28T01:18:00.606103226Z","close_reason":"Demo sequence already documented in feature-demo.md: 27-step XML ACTION sequence with all object names (ftdemo01-48, Accordion, Drawbar, Sdmixer), 6 BMP background images, and demo mode handler architecture."}
{"id":"kn5000-0du3","title":"LLVM migration Phase 5: Promote LLVM sources to authoritative","description":"Make LLVM .s files the source of truth. Final conversion run, verify 100% byte match, reorganize directory structure (remove llvm/ nesting), archive ASL sources, update Makefile (LLVM targets become primary), update CLAUDE.md for LLVM-only workflow. Keep converter functional for future use.","status":"closed","priority":2,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-23T11:19:47.434306992-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:30:52.99374402-03:00","closed_at":"2026-02-23T11:30:52.99374402-03:00","close_reason":"Closed","comments":[{"id":247,"issue_id":"kn5000-0du3","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on Phase 5 — promoting LLVM to authoritative source.","created_at":"2026-02-23T14:19:50Z"},{"id":248,"issue_id":"kn5000-0du3","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Phase 5 done. LLVM .s files promoted to authoritative source. ASL .asm files archived to archive/asl/. Directory structure reorganized: .s files moved from */llvm/ to */. Makefile updated (LLVM-only primary build). CLAUDE.md updated for LLVM-only workflow. All 6 ROMs build from new locations with 100% byte match.","created_at":"2026-02-23T14:30:49Z"}]}
{"id":"kn5000-0eo","title":"MAME: Spurious button events during boot (voice dialog, transpose B)","notes":"Running 'make fsanches_test' outside the VM, after boot sequence completes, some actions happen without user input: a dialog for selecting an instrument voice appears, and the screen shows transposition set to B (half step below default C). This suggests spurious button press events (possibly a 'transpose -' event). The control panel HLE or serial protocol may be generating ghost events. Needs investigation in MAME driver or control panel emulation.","status":"open","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:34.024555191-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T00:41:34.024555191-03:00","comments":[{"id":2,"issue_id":"kn5000-0eo","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): MAME control panel emulation has seen significant work — serial TX/RX timing, self-clocking, button packet encoding, idle detection, and INTA mechanism fixes (visible in MAME and custom-roms commit histories). The spurious button events may be related to the serial protocol improvements that were still in progress. Needs retesting with current MAME build to see if the ghost events persist.","created_at":"2026-02-21T04:01:39Z"},{"id":292,"issue_id":"kn5000-0eo","author":"Felipe Correa da Silva Sanches","text":"Note: While this issue remains open for MAME investigation, the Mines homebrew game now uses an 'input hijacking' trick by clearing the firmware's application event queue (0x02F838/0x02F83A) in each frame. This successfully suppresses all firmware-level actions for physical button presses while the game is running, including any spurious events that might occur during gameplay.","created_at":"2026-02-24T11:08:32Z"}]}
{"id":"kn5000-0o6","title":"MAME: Update HLE based on audio subsystem findings","notes":"The audio subsystem reverse engineering provides new information for MAME HLE:\n\nKey findings for emulation:\n1. Command dispatch table with 8 handler ranges\n2. Ring buffer at 0x2B0D for MIDI-like commands\n3. MIDI status byte parsing (0x80-0xF0)\n4. Voice parameter handlers for each message type\n5. Control Change handlers including proprietary CCs\n6. DSP channel configuration at 0x130000\n\nUpdate mame_driver/ reference files:\n- Document command byte ranges in comments\n- Add state machine for MIDI parsing if not present\n- Ensure CC handlers match discovered behavior\n\nReference: audio-subsystem.md, midi-subsystem.md, inter-cpu-protocol.md","status":"open","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:04:29.058923813-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:04:29.058923813-03:00","comments":[{"id":3,"issue_id":"kn5000-0o6","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): MAME audio emulation has advanced. Sine wave tone generator output working, pitch derived from register values, rhythm sequencer diagnostics added, Sub CPU payload transfer working (524K HDMA). Recent MAME commits show audio mixer register mapping at 0x150000/0x150002, sequencer ring buffer monitoring, and event queue diagnostics. The HLE should be updated to reflect these new working audio paths.","created_at":"2026-02-21T04:01:54Z"}]}
{"id":"kn5000-0os2","title":"LLVM codegen: INC/DEC selection for add/sub 1-8","description":"Add ISel patterns or peephole to convert ADD32ri/SUB32ri with constants 1-8 to INC32/DEC32 instructions. Saves 4 bytes per instance (6-byte reg-imm → 2-byte INC/DEC). High frequency in typical code.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T18:48:23.672253792-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:02:34.98460173-03:00","closed_at":"2026-02-23T19:02:34.98460173-03:00","close_reason":"Closed","comments":[{"id":267,"issue_id":"kn5000-0os2","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-23T21:48:43Z"},{"id":268,"issue_id":"kn5000-0os2","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Implementation complete. ADD/SUB 1-8 → INC/DEC when SR dead. Saves 4 bytes per instance. All 50 tests pass.","created_at":"2026-02-23T22:02:34Z"}]}
{"id":"kn5000-0r5","title":"Investigate shared graphics data between maincpu and table_data","notes":"Analysis found ~40KB of shared graphics/image data between ROMs:\n\n| Table Data | Main CPU | Size | Density |\n|------------|----------|------|---------|\n| 0x91D0EA | 0xE90090 | 13,806 bytes | 100% |\n| 0x82CDA4 | 0xE93680 | 7,198 bytes | 100% |\n| 0x921176 | 0xE7C8B0 | 9,282 bytes | 83.8% |\n| 0x809AD6 | 0xEB8190 | 8,964 bytes | 93.7% |\n\nTasks:\n1. Identify what graphics these regions contain (UI elements? fonts?)\n2. Check if they are already documented in maincpu\n3. Determine if sharing via binclude is feasible\n4. Update image-gallery.md if new images are found\n\nThe data appears to be 8-bit indexed color (lots of 0xF7 bytes = likely background color).\n\nReference: Investigation of ROM word-level interleaving fix","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:37:14.352198288-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:37:21.859066381-03:00"}
{"id":"kn5000-0vs","title":"Audio: Document external MIDI I/O on Main CPU","notes":"The Main CPU handles external MIDI IN/OUT/THRU via serial ports. Need to document:\n\n1. Serial port addresses and configuration\n2. MIDI parser routines in maincpu\n3. MIDI routing logic (how external MIDI reaches Sub CPU)\n4. MIDI OUT generation (keyboard events, sequencer playback)\n5. MIDI THRU implementation (hardware vs software)\n\nThis complements the internal MIDI processing already documented in midi-subsystem.md.\n\nSearch maincpu for: Serial port init, MIDI-related strings, writes to Sub CPU for external events.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:13.543904363-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:03:13.543904363-03:00"}
{"id":"kn5000-1061","title":"LLVM: Complex register-indirect addressing (C3/D3/E3/F3) — ~6,818 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:20:57.672327377-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T16:52:44.026485046-03:00","closed_at":"2026-02-22T16:52:44.026485046-03:00","close_reason":"Closed","comments":[{"id":188,"issue_id":"kn5000-1061","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Implemented ExtAddrModeSuffix format + converter changes. Converted 3,251 source LD (C3/D3/E3) and 2,495 destination LD/LDA/ST (F3) instructions from opaque sri/dri to semantic ld_REG/st_REG/lda_REG mnemonics. Remaining: 470 sri + 602 dri with non-LD sub-opcodes (ALU, EX, SET/RES, etc).","created_at":"2026-02-22T19:52:40Z"}]}
{"id":"kn5000-16s","title":"Images: Find embedded image locations in table data ROM","description":"Scan the 2MB table data ROM for embedded images. This ROM likely contains most graphical assets. Look for BMP headers, icon data, splash screens, UI elements. Cross-reference with table_data/images/ directory which may already have some extractions.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:37:56.153219854-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:45:15.933651254Z","closed_at":"2026-02-27T23:45:15.933651254Z","close_reason":"Already complete. Table data ROM images found: 6 FTBMP demo screens (BMP format, 8-bit), 2 wallpapers (320x240 8bpp at 0x8ED000 and 0x900000), 176 icons (24x24 4bpp at table 0x938000), 8 system update bitmaps (shared with main CPU at 0x9FA156). All documented in image-gallery.md with icon sprite sheet, palette details, and table structure."}
{"id":"kn5000-17u","title":"LLVM parallel build: Phase 2 (.byte fallback) complete","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T08:27:35.253825118-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T08:27:47.688371894-03:00","closed_at":"2026-02-21T08:27:47.688371894-03:00","close_reason":"Closed","comments":[{"id":138,"issue_id":"kn5000-17u","author":"Felipe Correa da Silva Sanches","text":"Phase 2 of the LLVM parallel build is complete. The ASL-to-LLVM converter (scripts/asl_to_llvm.py) now produces a 100% byte-identical 2MB ROM using the LLVM toolchain (llvm-mc -\u003e ld.lld -\u003e llvm-objcopy). All CPU instructions are emitted as .byte sequences from the original ROM with ASL syntax preserved as comments. Key implementation: TLCS-900 instruction length decoder, address tracking with self-correction at labels, macro definition freeze (prevents phantom ADDR_TRACKER drift), and multi-instruction macro expansion sizing. Baseline: 131,076 .byte fallback lines to be progressively replaced with native LLVM instructions in Phase 3.","created_at":"2026-02-21T11:27:43Z"}]}
{"id":"kn5000-1b1i","title":"LLVM converter: data formatting improvements — .ascii/.long/.short","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:11:08.809708781-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:58:20.399376346-03:00","closed_at":"2026-02-22T15:58:20.399376346-03:00","close_reason":"Closed","comments":[{"id":181,"issue_id":"kn5000-1b1i","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on data formatting.","created_at":"2026-02-22T18:57:05Z"},{"id":182,"issue_id":"kn5000-1b1i","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Data formatting is already well-implemented. Assembly uses: .ascii (25,242), .long (15,231), .asciz (5,569), .short (75), .incbin (80). Of 101K .byte lines, 98K already use comma-separated multi-value format. Only 2,784 are single-value (instruction fallbacks). No significant improvements remain. RELEASED.","created_at":"2026-02-22T18:58:20Z"}]}
{"id":"kn5000-1c7d","title":"LLVM converter: Replace extpfx with semantic register-indirect instructions (~12,000)","description":"Convert extpfx pseudo-instructions that use C0-C7/D0-D7/E0-E7/F0-F5 prefix bytes into semantic native instructions with proper register names and mnemonics. Currently 13,038 extpfx lines emit correct bytes but have no semantic meaning — the assembler doesn't understand what instruction they represent. The converter needs to decode the prefix byte to identify the base register and addressing mode, then the sub-opcode to identify the operation (LD, CP, ADD, etc.), and emit a proper native LLVM instruction. Top operations inside extpfx: LD (2,587), JR (1,141), EXTZ (1,025), CALL (566), CP (496), CALR (372), PUSH/POP (~700), LDA (324), ADD (280).","status":"closed","priority":2,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:08:48.140513422-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:59:01.38637258-03:00","closed_at":"2026-02-22T15:59:01.38637258-03:00","close_reason":"Closed","comments":[{"id":183,"issue_id":"kn5000-1c7d","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: This issue is now done. The ExtAddrMode LLVM backend format + Tier 43 categorization converts 12,788 previously-generic extpfx into semantic categories (erp/sri/spi/sd8/sd16/sd24/spd/dri/dpi/dd8/dd16/dd24/dpd + memory prefix mri/mrd). Only 250 extpfx remain (rare register prefix sub-opcodes). Done as part of kn5000-4rk9 and kn5000-qgz3.","created_at":"2026-02-22T18:59:01Z"}]}
{"id":"kn5000-1iy","title":"Mines: Fix garbled graphics on KN5000 playfield screenshot","notes":"The screenshot of the playfield drawn on the KN5000 screen clearly shows garbled graphics. The minesweeper game board is not rendering correctly. Need to investigate the rendering code (video.c, tiles.c) and fix the drawing so the board displays properly.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:26.588999248-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:38:11.145573837-03:00","closed_at":"2026-02-23T19:38:11.145573837-03:00","close_reason":"Closed","comments":[{"id":4,"issue_id":"kn5000-1iy","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Mines game builds and produces ROM output successfully. The game board renders on screen but with garbled graphics. The display subsystem is now well-understood (320x240 8bpp linear framebuffer, palette via 0x1703C8/C9), so the issue is likely in the tile/sprite rendering code in video.c, not in the display driver. May also be related to LLVM bug #10 (register swap on inlining) affecting tile_vram_ptr().","created_at":"2026-02-21T04:01:43Z"},{"id":275,"issue_id":"kn5000-1iy","author":"Felipe Correa da Silva Sanches","text":"RESOLVED: Garbled graphics fixed. Root cause was LLVM backend encoding bugs (extended addressing modes), not tile rendering code. The same LLVM fixes that resolved kn5000-3z6 (button activation) also fixed the graphics. Playfield now renders correctly. Committed as part of 78d023c.","created_at":"2026-02-23T22:38:10Z"}]}
{"id":"kn5000-1oy","title":"Audio: Analyze DSP effects processing algorithms","notes":"DSP effects processing is critical for audio emulation.\n\n**Current state:** Dual DSP architecture documented, but register meanings and effect algorithms unknown.\n\n**Required work:**\n- Trace DSP register writes at 0x130000\n- Document effect parameter mapping\n- Analyze reverb, chorus, delay implementations\n- Map effect chain configuration\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** Audio synthesis in MAME\n**Dependencies:** Audio hardware documentation\n**Related:** kn5000-xv2 (DSP IC311), kn5000-si0 (effects chain)","status":"open","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:50.844950943-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:57:34.960712871-03:00"}
{"id":"kn5000-1ru","title":"SubCPU: Document payload memory layout","description":"Analyze the 192KB sub CPU payload structure. Document: entry point address, interrupt vectors, code segments, data segments, any embedded tables or wavetables, and relationship to the 128KB boot ROM. Cross-reference with subcpu/kn5000_subprogram_v142.asm.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:35:39.018213203-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:04.041733872Z","closed_at":"2026-02-27T23:48:04.041733872Z","close_reason":"Already complete. Payload layout documented in boot-sequence.md: entry point at 0x0400 (interrupt vector trampolines), status flags at 0x04FE, DMA params at 0x0502-0x0516, command buffers at 0x051E-0x054A, 9 E1 transfer blocks covering 0x0400-0x090000. Payload command dispatch table with 8 handlers (0x00-0xFF range) documented. Cross-referenced with subcpu_payload assembly."}
{"id":"kn5000-1tn","title":"Update: Reverse engineer Flash program algorithm","description":"Trace the Flash ROM programming routine. Document: byte/word program commands, unlock sequences, program verification, error handling, write protection. Identify if using byte-program or page-buffer mode.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:45.220793898-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:17:37.931317649Z","closed_at":"2026-02-28T01:17:37.931317649Z","close_reason":"Already documented in flash-programming.md: Flash_ProgramWord_16bit (0x9FB903), Flash_ProgramWord_32bit (0x9FBCD7), FlashWrite (0xEF3B6C) with sector management, unlock sequences, skip-0xFFFF optimization, 16-bit and 32-bit bus modes."}
{"id":"kn5000-1v8g","title":"Investigate Feature Demo (FTDEMO) display failure","description":"The Internal Feature Presentation DEMO mode does not show FTBMP images on screen. It appears to get stuck before reaching the bitmap drawing code. Need to trace the code path from demo activation through floppy disk loading to bitmap display, identify the blockage, and fix or workaround it in MAME.","status":"closed","priority":2,"issue_type":"bug","owner":"juca@members.fsf.org","created_at":"2026-02-28T10:48:34.665231014Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-03-01T07:30:20.030503195Z","closed_at":"2026-03-01T07:30:20.030503195Z","close_reason":"Root cause confirmed: Feature Demo requires user button-press navigation to trigger FDB3D1 event buffer writer. Without input, LABEL_F98697 never fires post-boot. Table[1] logic is correct. No MAME bug — just no simulated input in automated tests.","comments":[{"id":378,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting investigation of FTDEMO display failure.","created_at":"2026-02-28T10:48:38Z"},{"id":379,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"Investigation complete. Key findings:\n\n1. FTBMP images are in Table Data ROM (not floppy disk) — loaded via file entry index at 0x8CE01C\n2. The demo is driven by AcPresentationControlProc processing hkst_55.ssf XML from ROM\n3. Audio_WaitForReady (polls 0x420 bit 2) has a 61440-iteration timeout — not a hard block\n4. Most likely culprit: EV_READPRESENTATION/EV_READACTION events not being delivered correctly, stalling the presentation state machine\n5. MAME floppy bug fixed: kn5000_floppies was '35dd' (720K), now '35hd' (1.44MB HD) — real KN5000 disks couldn't be mounted\n6. Added trace script at /tmp/ftdemo_investigate.lua for user to run while manually navigating to demo\n7. feature-demo.md updated with bitmap loading chain, MAME status, floppy type bug\n\nRELEASED: Investigation done; active debugging requires user to navigate to demo in MAME.","created_at":"2026-02-28T11:04:28Z"},{"id":380,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"TRACE ANALYSIS (v1 script had wrong addresses):\n\nKey findings from v1 trace reanalysis:\n- 'AcFdemoScreenProc' tap at even(0xF84149)=0xF84148 was WRONG: it was firing during VwUserBitmapSpProc's ret epilog at F84148, NOT AcFdemoScreenProc. PC=F84145/F84146 confirmed this was the epilog.\n- 'EventDispatch' tap at 0xFA9660: CORRECT — FA9660 = SendEvent function (confirmed via unidasm: 'lda XSP,XSP+0xE8'). Fires every frame because DispatchEvent's epilog runs at FA965C and MAME prefetch reads FA9660.\n- 'InitializeEventQueue' at FA9584 = single ret byte (0x0E), consistent with disassembly.\n- DemoModeFunc actual ROM address: 0xF222CC (found via binary search for call pattern to 0xF8696F/0xF869E3).\n\nCORRECTED FUNCTION ADDRESSES:\n- DemoModeFunc = 0xF222CC (was NOT being monitored in v1!)\n- DemoMode_Main_Operation = 0xF8696F (tap at F8696E)\n- DemoMode_Initialize = 0xF869E3 (tap at F869E2)\n- AcFdemoScreenProc = 0xF84149 (tap at F84148, but distinguishable by PC \u003e= F84149)\n- SendEvent = 0xFA9660 (confirmed correct)\n- DispatchEvent = 0xFA9585 (tap at FA9584)\n\nNew investigation script written: /tmp/ftdemo2.lua — uses correct addresses and logs XBC/XDE for key functions to see what event codes flow during demo activation.","created_at":"2026-02-28T12:09:50Z"},{"id":381,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"Progress 2026-02-28: Deep analysis of AcPresentationControlProc dispatch chain.\n\nKey findings:\n1. AcPresentCtrl IS being called (PC=F8450B) at frame 1103+ with real events\n2. Receives 0x1C0001C with XDE=0x0001BFC8 (ALWAYS same address)\n3. Handler at F84625 checks: *(0x0001BFC8) == 0xB80A before sending 0x1C00006 (SSF start)\n4. If check fails, SSF never starts → no images ever appear\n5. 0x0001BFC8 is valid DRAM (mapped 0x000000-0x0FFFFF in MAME driver)\n\nIdentified dispatch table structure:\n- RegisterObjectTable copies 14 bytes to 0x027ED2 + type*14\n- Types 0x000-0xFF default to BitmapHandler (0xFA5995)\n- Type 0x001 handler: BitmapHandler (not DemoModeFunc!)\n- Type 0x013 handler: overridden to DemoModeFunc (confirmed firing at frame 883 with XDE=0)\n\nAcPresentCtrl jump table (events 0x1C00002-0x1C0000C):\n- 0x1C00002 → F84563 (EVT_DISPLAY handler)\n- 0x1C00006 → F84650 (starts SSF: clears counters, calls 0xFC5625)\n- 0x1C00007-9 → F84580 (sends 0x1E00029 to 0x02600024)\n- All others → F8468B/F84687 (exit)\n\nThe 0x1C00006 event starts SSF reading by calling 0xFC5625 with WA=8.\nThis event is NEVER received because 0x1C0001C handler check fails.\n\nNext step: Run ftdemo4.lua to confirm B80A check passes/fails and see workspace content at 0x0001BFC8.","created_at":"2026-02-28T13:34:28Z"},{"id":382,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"Root cause confirmed (Feb 2026 deep analysis):\n\nThe Feature Demo image display failure has a confirmed root cause in the event routing system. Full findings:\n\n1. AcPresentCtrl_CheckSSFStart (0xF84625) checks *(XDE) == 0x0000B80A when handling event 0x1C0001C. SSF only starts if this passes.\n\n2. TWO code paths send event 0x1C0001C:\n   - DemoMenu_BuildItemWorkspace (0xF83CEA): QUEUED via FA9D58. Workspace tag = table[iz]+R*1024, always in 0x82xx range. NEVER produces 0xB80A. This is what fires in MAME — and always fails the check.\n   - GroupBoxProc_StartSSFPresentation (0xF9A273): DIRECT via FA9660. Builds workspace byte-by-byte from stack params, producing tag 0x0000B80A. This is the CORRECT path, but it NEVER fires in MAME.\n\n3. GroupBoxProc_StartSSFPresentation is reached when GroupBoxProc receives event 0x1C00038 (or 0x1C00030). These events are never routed to GroupBoxProc during Feature Demo navigation in MAME.\n\n4. Remaining question: what should send 0x1C00038 to GroupBoxProc, and why doesn't it happen in MAME?\n\nActions taken:\n- Added semantic labels and function headers to kn5000_v10_program.s:\n  - LABEL_F83CEA → DemoMenu_BuildItemWorkspace (with full header doc)\n  - LABEL_F83D8D → DemoMenu_BuildItemWorkspace_Post\n  - LABEL_F84625 → AcPresentCtrl_CheckSSFStart (with investigation notes)\n  - LABEL_F9A21E → GroupBoxProc_Ev1C00030\n  - LABEL_F9A273 → GroupBoxProc_StartSSFPresentation (with critical path doc)\n  - LABEL_F9A2BA → GroupBoxProc_SSFItemLoop\n  - GroupBoxProc: added full function header\n- Updated feature-demo.md with confirmed root cause, workspace concept, call-chain overview, and next steps\n- All 6 ROMs: 100% byte-match maintained","created_at":"2026-02-28T14:28:13Z"},{"id":383,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Resuming GroupBoxProc investigation. New findings: GroupBoxProc at 0xF99840, broadcast events resolve to active widget at DRAM[0x02F83C] not all widgets. Trace script ftdemo6.lua prepared.","created_at":"2026-02-28T16:35:20Z"},{"id":384,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Tracing what should send event 0x1C00038 to GroupBoxProc.","created_at":"2026-03-01T06:01:17Z"},{"id":385,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"Deep trace of 0x1C00038 event chain (Mar 1 2026):\n\nIdentified the full chain of code that should send event 0x1C00038 to GroupBoxProc:\n\n1. LABEL_F98697 (0xF98697) -- THE SENDER\n   - Embedded in handler chain tables (LABEL_EE7FA8 etc.) as a function pointer\n   - Fires when widgets using those chains receive user-interaction events\n   - Reads DRAM 0x8D38 as index R; looks up ROM array at E01F80+R*4\n   - Walks ROM array comparing state bytes (0xC07D/0xC080) to find a match\n   - On match (or 0xFFFE unconditional): pushes event 0x1C00038 to FA9945\n\n2. FA9945 -- QUEUE PROCESSOR/ROUTER\n   - Processes circular event queue at DRAM 0x02BC34 (PostEvent=FA9752 writes to it)\n   - For queued events with code 0x1C00038: checks upper16 of param vs. stored value\n   - If queue empty: posts directly via FA9D58\n\n3. FA9752 = PostEvent -- EVENT QUEUE WRITER\n   - Inserts 12-byte entries (self, event_code, param) into circular buffer\n\n4. HYPOTHESIS: F98697 never fires in MAME because either:\n   a) No widget with the EE7FA8/EE7FD4/EE7FFC handler chains is active during demo\n   b) DRAM 0x8D38 selector points to an array whose entries don't match current state\n   c) State bytes (0xC07D/0xC080) never match the ROM array entry 0x9100\n\nActions taken:\n- Added function header to LABEL_F98697 block explaining full logic\n- Updated feature-demo.md with detailed event chain analysis (FA9945, FA9752/PostEvent)\n- Wrote Lua verification script at /tmp/ftdemo_v6.lua:\n  Monitors FA9752 (PostEvent) calls, F98697 calls, FA9945 with XBC=0x1C00038,\n  GroupBoxProc_StartSSFPresentation entry, and AcPresentCtrl B80A checks\n  with state snapshot (0x8D38, 0x8D3A, 0xC07D-0xC080, routing table contents)\n\nRELEASED: investigation complete pending Lua trace run in MAME.","created_at":"2026-03-01T06:24:35Z"},{"id":386,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Updating with MAME Lua trace results - final root cause analysis","created_at":"2026-03-01T07:26:13Z"},{"id":387,"issue_id":"kn5000-1v8g","author":"Felipe Correa da Silva Sanches","text":"Root cause confirmed via MAME Lua trace (March 2026):\n\nLABEL_F98697 is called ~900 times during boot init (8D38=0x00, table[0]={0xFFFF} sentinel → always returns early, no event sent). After boot stabilizes (8D38=0x01), FDB3D1 (event buffer writer at 0xBD3C) is never called again because no user input occurs in MAME's automated test → event buffer stays empty → F98697 never fires post-boot.\n\nTable entry[1] DOES contain 0x7002 at ROM 0xE0156E — F98697 WOULD send event 0x1C00038 if called with chain C080=0x70, param C07D=0x02, which is exactly what user navigation would produce on real hardware.\n\nNo MAME emulation bug. The Feature Demo requires actual user button-press navigation to trigger the dispatcher. Automated MAME tests don't simulate this.\n\nUpdating feature-demo.md with full findings. RELEASED: investigation complete.","created_at":"2026-03-01T07:29:57Z"}]}
{"id":"kn5000-1vz","title":"MAME: Input/Control subsystem emulation milestone","notes":"Track completion of input and control subsystem emulation for MAME.\n\n## Required Components\n- [ ] Control panel HLE (MCU ROM not dumped)\n- [ ] Button matrix scanning\n- [ ] LED control responses\n- [ ] Rotary encoder simulation\n- [ ] Analog controllers (wheels, pedals)\n\n## Related Issues\n- kn5000-9ye: Control panel protocol\n- kn5000-qhm: Control panel HLE design\n- kn5000-3c7: Analog controllers\n- kn5000-j3c: Button index mapping\n- kn5000-ljl: LED index mapping\n- kn5000-unb: Rotary encoder format\n\n## Success Criteria\n- Keyboard input responds to user\n- UI navigation works\n- LEDs reflect state changes","status":"open","priority":2,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:15.10414233-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:15.10414233-03:00"}
{"id":"kn5000-1zlp","title":"LLVM converter: Native LD with memory operands (~40,000+ instructions)","description":"## Goal\nConvert the massive LD instruction backlog from .byte fallback to native LLVM. This is the single largest category (~53,807 fallbacks) and covers many sub-forms.\n\n## Sub-form breakdown\n\n### Direct memory loads: LD reg, (nn) — ~7,248 instances\n- Extended addressing: C1/D1/E1 prefix + 16-bit addr + LD sub-opcode\n- 24-bit addressing: C2/D2/E2 prefix + 24-bit addr + LD sub-opcode\n- Example: .byte 0xc1, 0x02, 0x04, 0x21 → ld a, (0x0402)\n\n### Direct memory stores: LD (nn), reg — ~6,411 instances\n- Extended addressing: F0/F1 prefix + addr + store sub-opcode + reg_or_imm\n- 24-bit addressing: F2 prefix + 24-bit addr + store sub-opcode\n- Example: .byte 0xf1, 0x09, 0x04, 0x60 → ld (0x0409), xwa\n\n### Direct memory store immediate: LD (nn), #imm — ~1,698 instances (opcode 0x08)\n- 3-byte: 0x08, addr_lo, imm8 (8-bit I/O register writes)\n- Example: .byte 0x08, 0x3c, 0x00 → ld (0x3C), 0x00\n\n### Register-indirect with displacement: LD reg, (Xreg+d8/d16) — ~167+349 instances\n- d8 form: prefix_base+8+r, d8, sub-opcode (3 bytes)\n- d16 form: F3, mode_byte, d16, sub-opcode (5+ bytes)\n- Example: .byte 0x9f, 0x04, 0x23 → ld hl, (xsp+4)\n\n### Prefix LD r,#imm (prefix + 0x03 + imm) — ~33 instances\n- 8-bit: C8+r, 0x03, imm8 (3 bytes)\n- 16-bit: D8+r, 0x03, imm16 (4 bytes)\n- Already supported as PrefixLDImm format in MCCodeEmitter\n\n### Other LD forms\n- LD r8,#imm8 (0x20-0x27) — 5,533 (separate issue kn5000-aq9)\n- LD r16,#imm16 (0x30-0x37) — 6,301 (separate issue kn5000-aq9)\n- LD r32,#imm32 (0x40-0x47) — already native (Tier 2)\n- LD r,r (2-byte) — already native (Tier 3)\n- LD r,(Xreg) / LD (Xreg),r (2-byte) — already native (Tier 7)\n\n## LLVM backend status\n- MemLoad format: reg_prefix + (opcode + dst_reg) — supported\n- MemStore format: dst_prefix + (opcode + src_reg_or_imm) — supported\n- MemLoadDst (LDA): dst_prefix + (opcode + dst_reg) — supported\n- Direct addressing via F2/E2: 24-bit address with fixup — supported\n- Register-indirect with d8/d16 displacement: emitMemPrefix handles all cases\n\n## Implementation strategy\nRecommend implementing in phases due to complexity:\n1. **Phase A:** Direct memory with extended addressing (C1-E2/F0-F2 prefixes) — highest count\n2. **Phase B:** Register-indirect with d8 displacement — moderate count\n3. **Phase C:** LD (nn),#imm8 (0x08 opcode) — 1,698 instances\n4. **Phase D:** Prefix LD r,#imm forms — small count\n\n### Key challenge: Address operand syntax\nLLVM syntax for memory operands: \"ld a, (xhl)\" vs \"ld a, (xhl, 4)\" for displacement.\nMust match exactly what the LLVM AsmParser expects. Check TLCS900AsmParser.cpp or .td files.\n\nFor direct addressing with symbols/labels, can use either:\n- Numeric: ld a, (0x0402, 0) — base=0x0402, disp=0\n- Symbolic: ld a, (SYMBOL, 0) — if the address has a known label\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check: count native ld instructions vs remaining .byte LD fallbacks","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:26:43.026584035-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T06:46:43.579172821-03:00","closed_at":"2026-02-22T06:46:43.579172821-03:00","close_reason":"Closed","comments":[{"id":161,"issue_id":"kn5000-1zlp","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work — Phase B (register-indirect LD with d8 displacement).","created_at":"2026-02-22T09:31:51Z"},{"id":162,"issue_id":"kn5000-1zlp","author":"Felipe Correa da Silva Sanches","text":"Converted register-indirect LD loads (Tier 18), LD stores, and LDA (Tier 19) to native. 26,437 new native instructions. Fallback: 58,351. d8=0 cases skipped (LLVM optimizes to shorter encoding). Direct addressing (F2/E2 prefix) LD not yet done.","created_at":"2026-02-22T09:46:26Z"}]}
{"id":"kn5000-21e","title":"FeatureDemo: Refactor assembly to use slide macros","description":"Replace raw data definitions in assembly source with new macros. Convert existing db/dw sequences to SLIDE_BEGIN, WIDGET_*, SLIDE_END. Verify rebuilt ROM still matches original byte-for-byte. Measure source code line reduction.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:23.925468009-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:15:26.816971175Z","closed_at":"2026-02-28T01:15:26.816971175Z","close_reason":"Superseded: Feature Demo uses XML-based SSF format, not binary slide records. No binary 'slide' data to refactor with macros — the existing assembly (table_data.s) already uses .incbin for SSF and BMP files."}
{"id":"kn5000-24m","title":"Boot: Document reset vector and early initialization","description":"Trace main CPU behavior from reset vector (0xE00000 area). Document: initial stack pointer setup, memory controller configuration, clock/PLL initialization, watchdog setup. Identify the entry point and first instructions executed after power-on.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:44:52.125109034-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:35:05.969503711-03:00","closed_at":"2026-01-26T08:35:05.969503711-03:00","close_reason":"Closed","comments":[{"id":5,"issue_id":"kn5000-24m","author":"fsanches","text":"Main CPU Reset Handler Analysis (from kn5000_v10_program.asm):\n\n**Reset Vector:** 0xFFFF00 points to RESET_HANDLER at 0xEF03C6\n\n**Early Initialization Sequence (0xEF03C6):**\n\n1. **Watchdog Timer Disable:**\n   - WDMOD = 0x00 (disable watchdog)\n   - WDCR = 0xB1 (watchdog control)\n\n2. **Clock Configuration:**\n   - CLKMOD = 0x04 (clock mode select)\n\n3. **Port Configuration (I/O Setup):**\n   - PF/PFFC/PFCR: Control panel enabled, MIDI disabled (PFFC=0x73)\n   - P2FC/P3FC = 0xFF (full function on ports 2/3)\n   - P7/P7FC/P7CR, PA/PAFC, PB/PBFC, PC/PCFC/PCCR\n   - PD/PDFC/PDCR, PE/PEFC/PECR, PH/PHFC/PHCR\n   - PZ/PZCR\n\n4. **Timer Initialization:**\n   - T01MOD = 0x1D, T23MOD = 0x1D\n   - T02FFCR = 0x00, TREG0 = 0x0A, TREG1 = 0x10\n   - T8RUN bit 1 set\n   - T4MOD = 0x05, T4FFCR = 0x00, T16CR = 0x00\n   - TREG4L = 0x0001, TREG5L = 0x3D09\n   - T16RUN bits 7 and 0 set\n\n5. **Memory Controller Setup:**\n   - MSAR0-5: Memory segment start addresses (0x1E, 0x10, 0xC0, 0x00, 0x80, 0x00)\n   - MAMR0-5: Memory segment masks (0x0F, 0x3F, 0x7F, 0x1F, 0xFF, 0xFF)\n   - P8/P8FC/P8CR configuration\n\n6. **DRAM Initialization (0xEF04A1-0xEF04BC):**\n   - Short pause loop (BC = 0x400 iterations)\n   - DRAM1REF = 0x81\n   - Longer pause loop (BC = 0x2000 iterations)\n   - DRAM1REF = 0x71\n   - DRAM1CRL = 0x8B, DRAM1CRH = 0x58\n   - PMEMCR bit 4 cleared\n\n7. **Bus Chip Select Setup:**\n   - B0CSL-B5CSL, B0CSH-B5CSH (bus control registers for external devices)\n\n8. **Serial \u0026 DAC:**\n   - SC0MOD = 0x29, SC0CR = 0x00 (serial channel 0)\n   - DAREG0/1 = 0xFF, DADRV = 0x03 (DAC output)\n\n9. **Stack Pointer Initialization (0xEF0526):**\n   - XSP = 0x00000C00 (stack at top of internal RAM)\n\n**Post-Init Sequence:**\n- Calls Seems_to_copy_some_data_buffers\n- Calls MainCPU_self_test_routines\n- Calls Get_Firmware_Version\n- If running boot ROM (version 0xFF): displays \"Please Wait !!\" bitmap\n- Initializes system timestamp to 0\n- Calls peripheral init routines\n- Sets interrupt priorities (INTET01, INTET45)\n- Detects area/region code\n- Checks for HD-AE5000 expansion board (PE bit 0)\n- Reads control panel buttons for update mode check\n- Optional: FLASH_MEM_UPDATE if holding specific button combo\n\nStatus: Issue can be closed - reset vector and early init fully documented.","created_at":"2026-01-26T10:40:45Z"},{"id":6,"issue_id":"kn5000-24m","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Reset Vector and Early Init' section (lines ~507-515) with actual findings from comments. Replace generic 'Tasks:' list with documented reset handler address (0xEF03C6), watchdog disable sequence, clock config, port setup, timer init, memory controller, DRAM init, serial/DAC setup, stack pointer. Add to memory-map.md any new register addresses discovered.","created_at":"2026-01-26T11:32:06Z"},{"id":7,"issue_id":"kn5000-24m","author":"fsanches","text":"Website updated: reverse-engineering.md 'Reset Vector and Early Init' section now documents RESET_HANDLER at 0xEF03C6, watchdog disable, clock config, port setup table, timer init, and post-init sequence. Replaced generic 'Tasks:' with actual findings.","created_at":"2026-01-26T11:35:05Z"}]}
{"id":"kn5000-28dn","title":"LLVM converter: Split chunked multi-instruction .byte blocks into individual instructions (~15,700 instructions)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T18:45:57.941734711-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T18:51:54.352102693-03:00","closed_at":"2026-02-22T18:51:54.352102693-03:00","close_reason":"Closed","comments":[{"id":201,"issue_id":"kn5000-28dn","author":"Felipe Correa da Silva Sanches","text":"DESCRIPTION: The converter currently dumps entire subroutines as raw 8-byte-per-line .byte blocks when it encounters instructions it can't handle. 6,856 lines (54,848 bytes, ~15,700 instructions) are affected. Fix: instead of giving up on the whole block, split the packed bytes into individual instructions using known instruction lengths from ASL output, then convert each one separately. Most individual instructions within these blocks ARE convertible — the block was only skipped because one or two instructions in it weren't.","created_at":"2026-02-22T21:46:04Z"},{"id":206,"issue_id":"kn5000-28dn","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on splitting chunked .byte blocks.","created_at":"2026-02-22T21:46:55Z"},{"id":207,"issue_id":"kn5000-28dn","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Re-analysis shows the 8-byte-per-line blocks are data (DB rows from ASL source), not multi-instruction chunks. The converter doesn't chunk instructions. Closing as invalid — the real issue is macro expansions (kn5000-a6uy).","created_at":"2026-02-22T21:51:54Z"}]}
{"id":"kn5000-2ic6","title":"LLVM converter: PUSH imm16 mnemonic mismatch (51 fallbacks)","description":"Tier 23 checks mnem_upper == 'PUSHW' but ASL source uses 'PUSH'. Fix: also accept 'PUSH' in the condition. Affects table_data (51 instances). Opcode 0x0B + imm16_LE = 3 bytes.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:18.423767123-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:18:46.887987751-03:00","closed_at":"2026-02-23T08:18:46.887987751-03:00","close_reason":"Closed","comments":[{"id":232,"issue_id":"kn5000-2ic6","author":"Felipe Correa da Silva Sanches","text":"FIXED: Changed Tier 23 to accept 'PUSH' in addition to 'PUSHW'. Actual fallback was 1 (not 51 — the rest were db-directive bytes in ASL source).","created_at":"2026-02-23T11:18:46Z"}]}
{"id":"kn5000-2og","title":"Symbols: Rename AudioMix to a more accurate name","notes":"AudioMix appears to be a misnomer. Need to investigate what the symbol actually does and choose a better semantic name. Apply sed-based renaming across all assembly files and documentation per policy.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:21.199731384-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T03:23:20.922732817-03:00","closed_at":"2026-02-21T03:23:20.922732817-03:00","close_reason":"Closed","comments":[{"id":8,"issue_id":"kn5000-2og","author":"Felipe Correa da Silva Sanches","text":"INVESTIGATION COMPLETE (Feb 21): Examined the hardware at 0x150000 and the AudioMix_* routines. The device is a register-indirect audio mixer/attenuator with 32 channels organized in 4 groups of 8. Register map: data regs at (group*0x20+0x10) through (group*0x20+0x17), enable regs at 0x1F/0x3F/0x5F/0x7F. Init writes 0x5A to all channel levels. The 4 groups likely correspond to 4 tone generator ICs, each handling 8 voices. The table_data bootcode at 0xFFFA5C also accesses this device with the same register structure. CONCLUSION: 'AudioMix' is an accurate name for an audio mixer/attenuator device. The MAME driver already describes it as 'Audio mixer/attenuator at 0x150000'. No rename needed — closing as investigated, name is correct.","created_at":"2026-02-21T06:23:17Z"}]}
{"id":"kn5000-2th1","title":"LLVM converter: Native LDA (load effective address) (~11,565 instructions)","description":"## Goal\nConvert LDA (Load Effective Address) from .byte fallback to native LLVM.\n\n## Instruction forms\n\n### LDA Xreg, (nn) — 3-byte form (~6,071 instances)\n- Prefix: B0+r (B0 table) or F0 for extended\n- Sub-opcode: 0x30+r (LDA in B0 table)\n- Example: .byte 0xf0, 0xe4, 0x31 → lda xbc, (0xE4) [I/O register INTET01]\n\n### LDA Xreg, nn:24 — 5-byte form (~3,579 instances)\n- Prefix: F2 (24-bit direct addressing)\n- 24-bit address + sub-opcode 0x30+r\n- Example: .byte 0xf2, 0x00, 0xb0, 0x0a, 0x31 → lda xbc, (0x0AB000)\n\n### LDA Xreg, (nn:16) — 4-byte form (~1,603 instances)\n- Prefix: F0/F1 (extended 8/16-bit addressing)\n- Example: .byte 0xf0, 0x80, 0x30 → lda xwa, (0x80)\n\n### LDA Xreg, (Xreg+d) — 2-byte form (~311 instances)  \n- Register-indirect with LDA sub-opcode in B0 table\n- Example: .byte 0xb0, 0x30 → lda xwa, (xwa)\n\n## LLVM backend status\n- MemLoadDst format: Already supported — uses dst_mem_prefix + (opcode + dst_reg)\n- LDA is in the B0 opcode table (destination-memory prefix)\n- Direct addressing via F2 prefix: supported\n- MCCodeEmitter encodes this correctly\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\n### Encoding detection\nLDA uses the B0 sub-opcode table. The sub-opcode for LDA is 0x30+r where r is the 32-bit destination register index:\n- r=0: XWA, r=1: XBC, r=2: XDE, r=3: XHL, r=4: XIX, r=5: XIY, r=6: XIZ, r=7: XSP\n\n### Address prefix types\n- B0+r: register-indirect (Xreg) — no displacement\n- B8+r, d8: register-indirect with 8-bit displacement\n- F0, addr8: 8-bit I/O register address\n- F1, addr16_LE: 16-bit address  \n- F2, addr24_LE: 24-bit address\n- F3, mode, d16: register-indirect with 16-bit displacement\n\n### Implementation approach\n1. Identify the prefix type from rom_bytes[0]\n2. Decode the address/displacement\n3. Find the LDA sub-opcode (0x30-0x37) to get destination register\n4. Emit native: lda \u003cxreg\u003e, (\u003caddress_expr\u003e)\n\n### Key challenge\nMust match LLVM's expected syntax for LDA operands. The MemLoadDst format expects (base_reg, disp) or (symbol_expr, 0) syntax. Check .td files or test with llvm-mc.\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check: grep -cP '^\\s+lda ' in output","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:27:02.506854393-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T18:01:26.378425192-03:00","closed_at":"2026-02-22T18:01:26.378425192-03:00","close_reason":"Closed","comments":[{"id":163,"issue_id":"kn5000-2th1","author":"Felipe Correa da Silva Sanches","text":"PARTIAL: Register-indirect LDA forms (B0/B8 prefix) already converted in Tier 19 (kn5000-1zlp commit). 6,344 LDA instructions native. Remaining: F0/F1/F2/F3 prefix (direct addressing) forms.","created_at":"2026-02-22T09:46:39Z"},{"id":171,"issue_id":"kn5000-2th1","author":"Felipe Correa da Silva Sanches","text":"Progress update: ExtPrefix (Tier 43) now generically captures all remaining prefix-byte instructions (\u003e= 0x80, sizes 2-10) including direct-addressing LDA forms (F0/F1/F2/F3 prefix). These are encoded as extpfxN with literal bytes rather than semantic native LDA instructions, but they're no longer .byte fallback. Total native: 228,545 instructions. Semantic LDA conversion for direct addressing is lower priority since ExtPrefix captures instruction boundaries.","created_at":"2026-02-22T14:06:57Z"},{"id":185,"issue_id":"kn5000-2th1","author":"Felipe Correa da Silva Sanches","text":"Update: LDA instructions using F0/F1/F2/F3 prefix are now categorized as semantic ExtAddrMode instructions (dd8/dd16/dd24/dri) instead of generic extpfx. Full semantic LDA conversion for direct addressing remains optional — instruction boundaries are already correct.","created_at":"2026-02-22T18:59:11Z"},{"id":200,"issue_id":"kn5000-2th1","author":"Felipe Correa da Silva Sanches","text":"Closing: Register-indirect LDA fully converted. Direct-addressing LDA already categorized as ExtAddrMode. Only 1,183 .byte instruction fallbacks remain total. Further semantic conversion is optional.","created_at":"2026-02-22T21:01:25Z"}]}
{"id":"kn5000-32b","title":"Trace CPanel_SM_* state machine handlers","description":"Trace execution flow through all CPanel_SM_* state machine handlers (states 0-10 in CPANEL_STATE_MACHINE_INDEX). Document what each handler does, when it's called, and how it processes data. Key routines: CPanel_InitHardware, CPanel_WaitTXReady, CPanel_SendCommand, CPanel_RX_Process, CPanel_RX_ParseNext.","notes":"Trace execution flow through all CPanel_SM_* state machine handlers (states 0-10). Document what each handler does, when it's called, and how it processes data. Key routines: CPanel_InitHardware, CPanel_WaitTXReady, CPanel_SendCommand, CPanel_RX_Process, CPanel_RX_ParseNext.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T03:10:48.449869191-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:05:21.124439372Z","closed_at":"2026-02-27T23:05:21.124439372Z","close_reason":"All 10 CPanel_SM_* state machine handlers fully labeled and documented. LED dispatch handlers (FC4B95/FC4BC5) converted from .byte blobs to native instructions (114 bytes). CPanel_LED_HandlePacket2 (types 0-2, 48 bytes) and CPanel_LED_HandlePacketN (type 3, 66 bytes) disassembled. Only LABEL_FC4C34 (23 bytes, in main program file) remains undisassembled. Protocol doc updated. All 6 ROMs 100% byte-match.","comments":[{"id":9,"issue_id":"kn5000-32b","author":"fsanches","text":"Serial routine flag usage (from docs/cp_serial_flags.txt):\n\n**Flag CP_Flags_A (0x8D8C):**\n- Bit 2: Set by LABEL_FC490E/FC4915 (appears unused - nothing reads it)\n- Bit 4: Never set, but checked by LABEL_FC4A40\n- Bit 6: Set by SOME_CPANEL_ROUTINE__FC3EF5\n- Bit 10: Used by multiple routines for handshaking\n\n**Flag CP_Flags_B (0x8D92):**\n- Bit 0: Primary handshake flag, used by most send routines\n- Bit 1: Set by CPANEL_SERIAL_ROUTINE_1 (unused?)\n- Bit 2: Set by CPANEL_SERIAL_ROUTINE_0 (unused?)\n- Bit 3: Set by LABEL_FC4B10 (unused?)\n- Bit 6: Set by INTA_HANDLER (unused?)\n- Bit 7: Checked by ready-to-send routine\n\n**Flag CP_Flags_C (0x8D93):**\n- Bits 0,4: Initial communication test results (set by LABEL_FC4194)\n\n**Key routines identified:**\n- CHECK_IF_WE_ARE_READY_TO_SEND_CMD_TO_CPANEL: Uses A.10, B.7\n- SEND_CMD_TO_CPANEL: Uses A.10\n- INTA_HANDLER: Uses A.10, B.6\n- CPANEL_SERIAL_ROUTINE_0: Uses A.10, B.2, B.7\n- CPANEL_SERIAL_ROUTINE_1: Uses A.10, B.1\n- CPANEL_SERIAL_ROUTINE_6: Uses A.10\n- CPANEL_SERIAL_ROUTINE_7: Uses B.0\n- CPANEL_SERIAL_ROUTINE_8: Uses A.10, B.0","created_at":"2026-01-26T10:35:55Z"},{"id":10,"issue_id":"kn5000-32b","author":"fsanches","text":"**Naming update (2026-01-26):**\n\nThe control panel code has been renamed for clarity:\n\n**Routines:**\n- SOME_CPANEL_ROUTINE__FC3EF5 → CPanel_InitHardware\n- CHECK_IF_WE_ARE_READY_TO_SEND_CMD_TO_CPANEL → CPanel_WaitTXReady\n- SEND_CMD_TO_CPANEL → CPanel_SendCommand\n- CPANEL_SERIAL_ROUTINE_0 through _8 → CPanel_SM_0 through _8\n- Process_CPanel_Rx_* → CPanel_RX_Process, CPanel_RX_ProcessWithFlag\n- LABEL_FC490E/FC4915 → CPanel_RX_ProcessWithFlag / CPanel_RX_Process\n- LABEL_FC4A40 → CPanel_RX_MultiBytePacket\n- LABEL_FC4B10 → CPanel_RX_SyncPacket\n\n**Variables:**\n- CP_Flags_A → CPANEL_TX_RX_FLAGS (0x8D8C)\n- CP_Flags_B → CPANEL_PROTOCOL_FLAGS (0x8D92)\n- CP_Flags_C → CPANEL_PANEL_DETECT_FLAGS (0x8D93)\n- CPANEL_SELECT_SERIAL_ROUTINE → CPANEL_STATE_MACHINE_INDEX\n- CPANEL_STATE_0_TO_17 → CPANEL_PACKET_BYTE_COUNT\n\nSee control-panel-protocol.md for complete state machine documentation.","created_at":"2026-01-27T01:09:13Z"},{"id":11,"issue_id":"kn5000-32b","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Control panel state machine has been extensively traced through MAME development and Another World port work. All CPanel_SM_* handlers renamed with semantic names. Serial TX/RX timing, self-clocking protocol, button packet encoding, idle detection, INTA mechanism all documented in control-panel-protocol.md. The Another World port (attempts 27-43) exercised the full cpanel protocol including sync/ping, button packets, and stale poll response fixes.","created_at":"2026-02-21T04:01:58Z"},{"id":293,"issue_id":"kn5000-32b","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on completing state machine handler tracing.","created_at":"2026-02-25T20:17:46Z"},{"id":295,"issue_id":"kn5000-32b","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Paused work on this issue to focus on HDAE5000 disassembly improvement per user request.","created_at":"2026-02-25T20:33:56Z"},{"id":325,"issue_id":"kn5000-32b","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work to complete state machine handler documentation.","created_at":"2026-02-27T22:26:45Z"}]}
{"id":"kn5000-36g","title":"Images: Reverse engineer image format","description":"Document the image format(s) used. Determine: pixel format (1bpp, 4bpp, 8bpp, RGB), dimensions encoding, palette format if indexed, compression if any, header structure. The LCD controller IC206 (MN89304) specs may indicate supported formats.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:37:56.525867349-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:45:46.782830954Z","closed_at":"2026-02-27T23:45:46.782830954Z","close_reason":"Already complete. Image formats fully documented in image-gallery.md: 1bpp monochrome (224x22, 28 bytes/row), 4bpp icons (24x24, 288 bytes/icon, CGA/EGA palette at 0xEB37DE), 8bpp indexed (various sizes, RGBA palette at 0xEB37DE or HDAE5000 palette at ROM 0x65dce), BMP (standard Windows format, 8-bit). LCD controller MN89304 drives 320x240 display. Icon table structure (8-byte entries at 0x938000) documented."}
{"id":"kn5000-3c5","title":"Display: Document framebuffer memory organization at 0x1A0000","notes":"Video RAM at 0x1A0000 (512KB) organization needs documentation.\n\n**Current state:** Address known, layout unknown.\n\n**Required work:**\n- Determine pixel storage format (linear? planar?)\n- Map screen regions to memory offsets\n- Document double-buffering if present\n- Identify any hardware scrolling/panning support\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** MAME display rendering\n**Dependencies:** VGA register documentation (kn5000-ezo)\n**Related:** kn5000-rq0 (screen layout)","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:56:55.832028062-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T01:00:04.351464255-03:00","closed_at":"2026-02-21T01:00:04.351464255-03:00","close_reason":"Closed","comments":[{"id":12,"issue_id":"kn5000-3c5","author":"Felipe Correa da Silva Sanches","text":"MAJOR PROGRESS (Feb 20): Framebuffer organization now fully understood and working. 320x240 linear framebuffer, 8bpp indexed color at 0x1A0000. Direct byte access works via MN89304 VGA controller mem_linear_r/w. Confirmed working in MAME with Mines homebrew rendering. No double-buffering, no planar modes — simple linear layout. Documented in display-subsystem.md and hdae5000-homebrew.md.","created_at":"2026-02-21T03:32:48Z"},{"id":13,"issue_id":"kn5000-3c5","author":"Felipe Correa da Silva Sanches","text":"RESOLVED (Feb 21): Framebuffer organization fully documented and confirmed working in MAME. Layout: 320x240 linear, 8bpp indexed color at 0x1A0000. Direct byte access via MN89304 mem_linear_r/w. No double-buffering, no planar modes. Documented in display-subsystem.md and hdae5000-homebrew.md. Mines homebrew renders correctly using this layout.","created_at":"2026-02-21T04:00:04Z"}]}
{"id":"kn5000-3c7","title":"Input: Document analog controller processing (wheels, pedals)","notes":"Pitch bend wheel, modulation wheel, and expression pedal processing needs documentation.\n\n**Current state:** Encoder IDs known from control panel protocol, processing unknown.\n\n**Required work:**\n- Trace A/D conversion routines\n- Document wheel position scaling/curves\n- Map pedal input handling\n- Document velocity/aftertouch processing if applicable\n\n**Phase:** 2 - Core Functionality\n**Blocks:** Controller emulation accuracy\n**Dependencies:** Control panel protocol (complete)\n**Related:** kn5000-unb (encoder data format)","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:57:10.002582315-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:58:42.16279674-03:00"}
{"id":"kn5000-3cm","title":"Update: Map file types to system components","description":"Document which file types update which system components: main CPU program ROM, sub CPU payload, table data, custom data flash, HDAE5000 firmware. Create matrix showing file extension/name pattern vs target component.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T05:34:40.672056683-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:39:14.047726351-03:00","closed_at":"2026-01-26T08:39:14.047726351-03:00","close_reason":"Closed","comments":[{"id":14,"issue_id":"kn5000-3cm","author":"fsanches","text":"**File Type to System Component Mapping:**\n\n| File Type ID | Header String | Target Component | Memory Address |\n|--------------|---------------|------------------|----------------|\n| 1 | Program DATA FILE 1/2 | Main CPU ROM (first half) | 0xE00000+ |\n| 2 | Program DATA FILE 2/2 | Main CPU ROM (second half) | 0xF00000+ |\n| 3 | Table DATA FILE 1/2 | Table Data ROM (first half) | 0x800000+ |\n| 4 | Table DATA FILE 2/2 | Table Data ROM (second half) | 0x900000+ |\n| 5 | CMPCUSTOMDATA FILE | Custom Data Flash | 0x300000 |\n| 6 | HD-AEPRG DATA FILE | HDAE5000 ROM | 0x280000 |\n| 7 | Program DATA FILE PCK | Main CPU ROM (packed) | 0xE00000 |\n| 8 | Table DATA FILE PCK | Table Data ROM (packed) | 0x800000 |\n\n**Component Sizes:**\n| Component | Size | File Split |\n|-----------|------|------------|\n| Main CPU ROM | 2 MB | 2 disks (1/2, 2/2) or 1 packed |\n| Table Data ROM | 2 MB | 2 disks (1/2, 2/2) or 1 packed |\n| Custom Data | 1 MB | 1 disk (compressed?) |\n| HDAE5000 ROM | 512 KB | 1 disk |\n\n**Notes:**\n- Sub CPU payload (192KB) is embedded within main CPU ROM, not a separate update file\n- PCK files are likely packed/compressed single-disk versions\n- Split files must be loaded in order (1/2 then 2/2)\n- Handler at SHOW_ILLEGAL_DISK_MESSAGE shown if 2/2 loaded before 1/2\n\nStatus: Mapping complete from firmware analysis.","created_at":"2026-01-26T11:24:56Z"},{"id":15,"issue_id":"kn5000-3cm","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'File Types and Target Components' section with documented file type to component mapping (8 types identified). Add table showing each file type and target address/component.","created_at":"2026-01-26T11:33:03Z"},{"id":16,"issue_id":"kn5000-3cm","author":"fsanches","text":"Website updated: reverse-engineering.md 'File Types and Target Components' section now has complete mapping table with file IDs, headers, targets, addresses, and sizes for all 8 file types.","created_at":"2026-01-26T11:39:13Z"}]}
{"id":"kn5000-3ei","title":"LLVM parallel build: Phase 2 - Replace .incbin with converted assembly","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T03:08:20.242021063-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T08:24:21.043627615-03:00","closed_at":"2026-02-21T08:24:21.043627615-03:00","close_reason":"Closed","comments":[{"id":137,"issue_id":"kn5000-3ei","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Phase 2 implemented using segment-level ROM byte extraction. All 2MB of ROM bytes extracted directly from original binary and emitted as .byte directives in 7 content segments, with ASL source preserved as comments. Builds with zero errors, 100% byte-match verified. Converter: scripts/asl_to_llvm.py. Next: Phase 3 — progressively replace .byte with native LLVM instructions.","created_at":"2026-02-21T11:24:18Z"},{"id":17,"issue_id":"kn5000-3ei","author":"Felipe Correa da Silva Sanches","text":"Phase 1 complete: LLVM toolchain pipeline validated with 100% byte-match via .incbin. Phase 2 will progressively replace .incbin with converted assembly sources from asl_to_llvm.py. Currently ~55K LLVM assembler errors to resolve (unsupported instructions: ld (mem),imm, pushw, sll, set/res/bit, post-increment addressing, size specifiers). Strategy: emit instructions as .byte fallback from original ROM bytes, then replace with native LLVM syntax as backend support improves.","created_at":"2026-02-21T06:08:27Z"}]}
{"id":"kn5000-3go","title":"Plan: Long-term project roadmap and phase tracking","notes":"Master roadmap for KN5000 reverse engineering project.\n\n## Project Goals\n1. **100% ROM Reconstruction** - Byte-accurate rebuilds of all firmware\n2. **MAME Emulation** - Full system emulation for preservation\n3. **Homebrew Development** - Enable custom software creation\n4. **Documentation** - Complete technical reference\n\n## Phase Structure with Tracking Issues\n\n### Phase 1: Foundation (MAME Blockers) - kn5000-dbi\n*Goal: Get basic emulator running with display and sound*\n\n**Display System (kn5000-8z5):**\n- kn5000-ezo: VGA register documentation [P1]\n- kn5000-3c5: Framebuffer memory layout [P1]\n- kn5000-hy8: Pixel format and palette [P1]\n- kn5000-gln: Drawing primitives [P1]\n\n**Audio System (kn5000-y18):**\n- kn5000-1oy: DSP effects processing [P1]\n- kn5000-xv2: DSP IC311 documentation [P1]\n- kn5000-xel: DAC IC310 documentation [P1]\n\n**ROM Reconstruction:**\n- kn5000-5a0: Fix 177 divergent bytes [P1]\n- kn5000-d1x: Table Data ROM structure [P1]\n\n### Phase 2: Core Functionality - kn5000-dnl\n*Goal: User interaction and file I/O working*\n\n**UI/Input (kn5000-1vz):**\n- kn5000-kev: Font system [P2]\n- kn5000-5dc: Widget rendering [P2]\n- kn5000-qhm: Control panel HLE [P2]\n- kn5000-3c7: Analog controllers [P2]\n\n**Storage (kn5000-a0k):**\n- kn5000-ima: FDC subsystem [P2]\n- kn5000-kuu: HDAE5000 ROM [P1]\n\n### Phase 3: Complete Documentation - kn5000-9m6\n*Goal: All subsystems fully documented*\n\n**Documentation (kn5000-8ro):**\n- Complete all placeholder subsystem pages\n- audio-subsystem.md, display-subsystem.md, midi-subsystem.md\n- ui-framework.md, sequencer.md, storage-subsystem.md\n\n**Audio Details:**\n- kn5000-81p: Technics SysEx format\n- kn5000-5ck: Proprietary CC handlers\n- kn5000-rlb: Voice allocation\n\n**Storage Details:**\n- kn5000-bqe: Custom Data Flash\n- kn5000-44c: HDAE5000 filesystem\n\n**Boot/Init:**\n- kn5000-mhj: Complete boot timeline\n- kn5000-izk: HDAE5000 detection\n\n### Phase 4: Quality \u0026 Polish - kn5000-nca\n*Goal: Production-ready emulation and homebrew support*\n\n**Symbol Cleanup:**\n- kn5000-9jq: Sub CPU symbols\n- kn5000-4bt: UI framework symbols\n- kn5000-aar: Naming convention guide\n\n**Tools (kn5000-5jy):**\n- kn5000-waa: Slide viewer/editor\n- kn5000-87m: Update file parser\n- kn5000-pkx: Image converter\n\n**Documentation:**\n- kn5000-9a0: Website maintenance\n- kn5000-sf8: Code reference tables\n\n**Validation (kn5000-a8s):**\n- Emulation validation procedures\n\n## Current Status (Jan 2026)\n- ROM reconstruction: 59.54% overall\n- Main CPU: 99.99% (177 bytes divergent)\n- Sub CPU: 100% complete\n- Table Data: 32.42%\n- MAME PR: #14558 in progress\n\n## Success Criteria\n- [ ] All ROMs 100% byte-matching\n- [ ] MAME driver merged upstream\n- [ ] All subsystems documented\n- [ ] Homebrew SDK available\n\n## Phase Tracking Issues\n- Phase 1: kn5000-dbi (P0 - Current Focus)\n- Phase 2: kn5000-dnl (P1)\n- Phase 3: kn5000-9m6 (P2)\n- Phase 4: kn5000-nca (P3)","status":"open","priority":0,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:58:19.060305466-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:08:31.654216078-03:00","comments":[{"id":18,"issue_id":"kn5000-3go","author":"Felipe Correa da Silva Sanches","text":"STATUS UPDATE (Feb 21): ROM reconstruction scores dramatically improved. Current: maincpu 100%, subcpu boot 100%, subcpu payload 100%, table_data 100% (was 32.42%), hdae5000 100%, custom_data 0% (not started). Overall: 82.80% (was 59.54%). LLVM backend: 10 new commits — LDIR/LDDR block transfers, BIT/SET/RES peephole optimizations, frame pointer support, 8-bit register encoding fix, disassembler fixes. Bugs #10/#11 still active. Display: framebuffer and palette fully working. Audio: sine wave tone gen working. Sound subsystem: 100+ semantic label renames. Another World port: up to attempt 43.","created_at":"2026-02-21T04:00:28Z"}]}
{"id":"kn5000-3lw","title":"LLVM Phase 3: Native JR/JRL/CALR support complete","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T04:52:44.370258611-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T04:52:56.03343316-03:00","closed_at":"2026-02-22T04:52:56.03343316-03:00","close_reason":"Closed","comments":[{"id":150,"issue_id":"kn5000-3lw","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Documenting completed work.\n\nImplemented native JR/JRL/CALR support in the LLVM converter:\n- Fixed emitFixup() placeholder byte counts for custom fixup kinds (rel8=1, rel16=2, disp8=1, disp16=2, 24=3)\n- Fixed PC-relative RELA relocation addends for absolute .set labels (moved displacement adjustment from applyFixup to MCCodeEmitter expression)\n- Added Tiers 8-10 in asl_to_llvm.py: JR (22,183), JRL (6,590), CALR (5,846)\n- Added native conversion in macro handler for single-instruction macros (CALR is an ASL macro)\n- 100% byte-identical ROM output maintained\n- Total native: 125,279 lines (up from ~97K)\n\nRELEASED: Work complete.","created_at":"2026-02-22T07:52:52Z"}]}
{"id":"kn5000-3o6","title":"ASL Macros: Document new TMP94C241 instruction encodings","description":"Several new macros were added to tmp94c241.inc during subcpu_boot disassembly:\n\nJump/Call macros:\n- JRL_T target: Jump relative long (78 LL HH) - 3 bytes vs jp's 4 bytes\n- CALR target: Call relative (1e LL HH) - 3 bytes vs call's 4 bytes  \n- CALL_ABS24 target: Call absolute 24-bit (1d LL MM HH)\n\nBlock transfer macros:\n- LDIR_94: Block copy with TMP94C241 encoding (83 11 vs ASL's 85 11)\n\nRegister load macros (for correct immediate encoding):\n- LD_A value: Load A with immediate (21 nn)\n- LD_D value: Load D with immediate (24 nn)\n\nThese address encoding differences between TMP94C241 and TMP96C141 (which ASL targets).\n\nTODO: Document general encoding patterns for creating future macros.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T20:46:51.922846626-03:00","created_by":"fsanches","updated_at":"2026-02-23T11:31:11.642203988-03:00","closed_at":"2026-02-23T11:31:11.642203988-03:00","close_reason":"Closed","comments":[{"id":19,"issue_id":"kn5000-3o6","author":"fsanches","text":"Additional macros added during DMA routine disassembly:\n\nStack Frame Operations:\n- DEC_6_XSP: Allocate 6 bytes on stack (ef 6e)\n- INC_6_XSP: Deallocate 6 bytes from stack (ef 66)\n- INC_0_XSP: Adjust stack by 0 bytes (ef 60) - used for alignment\n\nIZ Register Operations:\n- LD_IZ_BC: Load IZ from BC (d9 8e)\n- CP_IZ_imm16 value: Compare IZ with 16-bit immediate (de cf LL HH)\n- SUB_IZ_imm16 value: Subtract 16-bit immediate from IZ\n- LD_C_IZL: Load C from low byte of IZ\n\nZero-Extend Operations:\n- EXTZ_WA: Zero-extend A to WA\n- EXTZ_BC: Zero-extend C to BC\n\nDMA Register Operations:\n- LDC_DMAS2_XDE/XWA/XBC/XHL: Set DMA channel 2 source\n- LDC_DMAD2_XWA, LDC_DMAD0_XWA/XBC: Set DMA destination\n- LDC_DMAC2_BC/WA/A, LDC_DMAC0_WA/A: Set DMA count\n\nStack-Relative Operations:\n- LD_pXSP_d_XDE d: Store XDE at (XSP+d)\n- LD_XDE_pXSP_d d: Load XDE from (XSP+d)\n- LD_A_pXSP_d d: Load A from (XSP+d)\n- ADD_pXSP_d_XWA d: Add XWA to (XSP+d)","created_at":"2026-01-26T06:16:50Z"},{"id":20,"issue_id":"kn5000-3o6","author":"fsanches","text":"Complete macro inventory from tmp94c241.inc (135 macros total):\n\n**DMA Control Macros (21 macros):**\n- Source registers: LDC_DMAS0_XWA, LDC_DMAS2_XWA/XBC/XDE/XHL, LDC_DMAS3_XHL\n- Destination: LDC_DMAD0_XWA/XBC, LDC_DMAD2_XWA, LDC_DMAD3_XHL\n- Count: LDC_DMAC0_A/WA, LDC_DMAC2_A/BC/WA/XWA, LDC_DMAC3_A\n- Mode: LDC_DMAM0_WA, LDC_DMAM2_WA/BC, LDC_DMAM3_BC, LDC_WA_DMAM0\n- Misc: LDC_INTNEST_WA\n\n**8-bit Register Load Macros (8 macros):**\nLD_W, LD_A, LD_B, LD_C, LD_D, LD_E, LD_H, LD_L\n\n**Memory Transfer Macros (12 macros):**\n- Block transfers: LDI, LDIR, LDIR_83, LDIW, LDIRW_93, LDIRW_95, LDDR_85\n- Memory-to-memory: LDW_16_16, LD_8_8\n- Address load: LDA variants (19 different encodings for auto-increment modes)\n\n**Multiplication Macros (20 macros):**\n- Unsigned 8-bit: MUL_A/C/E/L\n- Unsigned 16-bit: MUL_WA/BC/DE/HL/IX/IY/IZ, MULW_WA\n- Signed: MULS_A/C/L/WA/BC/DE/HL/IX/IY/IZ/IYL\n- Register pairs: MULS_XWA_IX/DE, MULS_XDE_IY\n\n**Division Macros (14 macros):**\n- Unsigned 8-bit: DIV_A/C/E/L\n- Word: DIVW_WA/BC/DE/HL/IX/IY/IZ\n- Signed word: DIVS_WA/BC/DE/HL/IX/IY\n\n**Shift/Rotate Macros (19 macros):**\nSRA_0/8_XWA/XBC/XDE, SLA_0/2/8_XWA/XBC/XDE/XHL/XIX, SRL_0_XWA/XBC/XDE/XHL, SLL_0/8_XWA/XBC/XDE/XHL/XIX\n\n**Sub CPU Boot ROM Macros (added during disassembly):**\n- Stack: INC_0_XBC, PUSH_WORD, DEC_6_XSP, INC_6_XSP, INC_0_XSP\n- Compare: CP_pXWA_WORD, CP_pXBC_d_WORD, CP_IZ_imm16, CP_MEM24_IMM16\n- Load address: LDA_XWA_IMM24, LDA_XDE_IMM24\n- Memory store: LD_MEM24_IMM16, LD_pXIX_IMM16, LD_pXHL_IMM16\n- Jump/Call: CALR, CALL_ABS24, JRL_T\n- Block: LDIR_94 (TMP94C241 encoding vs ASL's TMP96C141)\n- IZ register: LD_IZ_BC, SUB_IZ_imm16, LD_C_IZL\n- Zero-extend: EXTZ_WA, EXTZ_BC\n- Stack-relative: LD_A/XBC/XDE_pXSP_d, LD_pXSP_d_A/XDE, ADD_pXSP_d_XWA\n- QIZH access: LD_QIZH_0, LD_A/C_QIZH, INC_1_QIZH, CP_QIZH_4\n- Register moves: LD_XDE_XIZ, LD_BC_QBC/QDE, LD_XBC_pXDE_BC\n- Memory auto-increment: LD_pXWA_plus_BC, ADD_XHL_pXWA_plus, DJNZ_DE\n\nDocumentation status: Complete inventory documented. The rom-reconstruction.md page has a subset; consider adding comprehensive reference.","created_at":"2026-01-26T10:40:06Z"},{"id":249,"issue_id":"kn5000-3o6","author":"Felipe Correa da Silva Sanches","text":"CLOSING: No longer relevant. All 110+ ASL macros have been replaced by native LLVM instructions during the ASL-to-LLVM migration (Phase 1). The tmp94c241.inc file is archived in archive/asl/ and no longer needed for ROM builds.","created_at":"2026-02-23T14:31:07Z"}]}
{"id":"kn5000-3z6","title":"Mines: Only Mines Game button should activate game from DISK MENU","notes":"At the DISK MENU, pressing other buttons also activates the Mines game. Need to ensure that ONLY the Mines Game button (specific event/button index) activates the game, while other buttons retain their original firmware behavior. The Mines_Handler in startup.s likely needs to check which button was pressed before activating.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:29.706552622-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:38:08.644313201-03:00","closed_at":"2026-02-23T19:38:08.644313201-03:00","close_reason":"Closed","comments":[{"id":21,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"Previous fix (XWA object_id check) was incorrect. User reports: (1) many DISK MENU buttons open incorrect screens, (2) the Mines Game option itself opens a floppy save/load test dialog instead of the game. This suggests the handler registration or delegation is fundamentally broken — the problem is not just filtering events, but that the entire handler 0x016A dispatch is disrupted by replacing the original 13-record table with our 1-record table.","created_at":"2026-02-21T03:54:14Z"},{"id":22,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Most recent Mines commit (88d6823) attempted to fix this by checking which DISK MENU entry was selected. However, per the earlier comment, the fundamental problem is deeper — replacing the original 13-record handler 0x016A table with a 1-record table disrupts all DISK MENU dispatch, not just Mines activation. This remains open and needs a different approach: possibly appending to the existing table rather than replacing it, or using a different handler registration strategy.","created_at":"2026-02-21T04:01:35Z"},{"id":23,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"Root cause identified: Mines_Handler was delegating non-activation events to table_A[0x00DC] (the default DISK MENU lifecycle handler), which processes them as standard DISK MENU operations — showing 'FD SAVE/LOAD TEST' dialog. Fix: removed the entire delegate path. Handler 0x016A is extension-ROM exclusive (main firmware leaves it vacant), so ignoring non-activation events is safe. Also removed the XWA object_id check (0x016A0000) which may have been filtering out valid events — ClassProc already routes correctly by sub-index.","created_at":"2026-02-21T04:02:06Z"},{"id":24,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"Revised fix: previous change removed the delegate entirely, which broke DISK MENU lifecycle — only 1 item visible, all buttons triggered activation (any 0x01C00008 event hit .Lmh_activate). Root cause: delegate is REQUIRED for lifecycle events (item enumeration, focus, redraw); only activation events (0x01C00008, 0x01E0009C) should skip delegation. Also removed XWA check. Added debug logging: XBC→0x200050, XWA→0x200058.","created_at":"2026-02-21T04:48:50Z"},{"id":25,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"Built and committed 13-record handler table fix. Record[5]=Mines_Handler matches firmware's 0x016A0005 dispatch. Dummy_Return stubs for records 0-4,6-12. DISK MENU slot link updated to 0x016A0005. Ready for testing.","created_at":"2026-02-21T05:24:02Z"},{"id":266,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Rebuilding with latest LLVM to test if recent compiler fixes resolve the button activation issues.","created_at":"2026-02-23T21:47:18Z"},{"id":274,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"RESOLVED: Game activation working. LLVM backend fixes (extended addressing mode consolidation, x_ instruction elimination) resolved the silent encoding bugs that prevented correct handler dispatch. DISK MENU entry now successfully launches Mines game. Graphics also no longer garbled (kn5000-1iy fixed by same LLVM changes). Committed 78d023c.","created_at":"2026-02-23T22:38:08Z"},{"id":276,"issue_id":"kn5000-3z6","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Issue resolved and closed.","created_at":"2026-02-23T22:38:14Z"}]}
{"id":"kn5000-44c","title":"HDAE5000: Document filesystem structure","description":"Analyze how files are organized on the 1.08GB hard disk. Document directory structure, file allocation table format, metadata storage, and how the Flash-ROM/SRAM quick directory access works. Compare with standard DOS/FAT if applicable.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:33:16.234717531-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:24:59.687284289Z","closed_at":"2026-02-27T23:24:59.687284289Z","close_reason":"Complete. Comprehensive filesystem documentation exists at hdae5000-filesystem.md: 3-level FSB/FGB/FEB hierarchy, 21-byte/37-byte/9-byte entry formats, VarInt sector encoding, 20KB allocation table structure, PPORT transfer protocol, 20+ routines documented, 60+ RAM addresses mapped. Not FAT (confirmed). Remaining deeper annotation tracked by sub-issues q7xb, c5gn, li65, c47b.","comments":[{"id":330,"issue_id":"kn5000-44c","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting filesystem structure analysis from HDAE5000 disassembly.","created_at":"2026-02-27T23:20:39Z"}]}
{"id":"kn5000-4bt","title":"Symbols: Apply semantic naming to UI framework LABEL_* symbols","notes":"Following the successful audio subsystem renaming, apply the same approach to UI framework routines:\n\n1. Identify UI-related LABEL_* symbols (widget handlers, drawing, event dispatch)\n2. Analyze each routine's purpose\n3. Create semantic names (UI_DrawButton, Widget_HandleClick, etc.)\n4. Add documentation headers\n5. Update ui-framework.md with code references\n\nMany UI routines already have good names (Display_*, GridCheck_*, ClassProc_*).\nFocus on remaining LABEL_* symbols in UI code regions.\n\nReference: ui-framework.md for existing documentation.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:34.734213245-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:03:34.734213245-03:00"}
{"id":"kn5000-4q0","title":"FeatureDemo: Create ASL macros for slide definitions","description":"Design and implement ASL assembler macros for concise slide definitions: SLIDE_BEGIN/END, WIDGET_TEXT, WIDGET_IMAGE, WIDGET_RECT, SLIDE_MIDI, SLIDE_TIMING, etc. Macros should emit correct binary format while being human-readable.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:19.268069151-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:11:23.824511187Z","closed_at":"2026-02-28T01:11:23.824511187Z","close_reason":"Superseded: Feature Demo uses XML-based SSF format (hkst_55.ssf), not binary slide records. No binary format exists to create ASL macros for. The XML is already human-readable."}
{"id":"kn5000-4rk9","title":"LLVM converter: register-indirect addressing → semantic instructions (~12K extpfx)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:11:03.59226876-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:44:54.818325195-03:00","closed_at":"2026-02-22T15:44:54.818325195-03:00","close_reason":"Closed","comments":[{"id":173,"issue_id":"kn5000-4rk9","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on register-indirect addressing extpfx conversion.","created_at":"2026-02-22T18:11:15Z"},{"id":174,"issue_id":"kn5000-4rk9","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Added ExtAddrMode LLVM backend format + 75 instruction definitions for all addressing mode categories. Converter Tier 43 now categorizes prefix bytes into semantic mnemonics (erp/sri/spi/sd8/dri/dpi/dd8). Native instructions: 228,545 (was 183,796). .byte fallback: 1,068. 100% byte-match verified. Both repos committed.","created_at":"2026-02-22T18:44:51Z"}]}
{"id":"kn5000-4rr","title":"Images: Update assembly sources to include binary images","description":"Modify assembly sources to include extracted image binaries using ASL incbin directive. Ensure correct alignment and placement. Verify rebuilt ROM matches original byte-for-byte at image locations. Update extract_include_binaries.py if needed.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:37:57.313863204-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:28.621949653Z","closed_at":"2026-02-27T23:48:28.621949653Z","close_reason":"Already complete. Assembly sources use .incbin directives: 43 in maincpu/kn5000_v10_program.s, 16 in table_data/kn5000_table_data.s. All extracted as binary files in images/ directories. All 6 ROMs build with 100% byte match. No ASL incbin needed — LLVM .incbin is the authoritative source."}
{"id":"kn5000-51z","title":"SubCPU: Document boot sequence handshake","description":"Trace the complete boot sequence: 1) Main CPU reset/init, 2) Sub CPU held in reset?, 3) Payload transfer trigger, 4) DMA transfer execution, 5) Sub CPU release from reset?, 6) Sub CPU boot ROM hands off to payload, 7) Sub CPU signals ready to main CPU. Document timing requirements.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:35:38.275553404-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:47:43.380834345Z","closed_at":"2026-02-27T23:47:43.380834345Z","close_reason":"Already complete. Boot sequence handshake fully documented in boot-sequence.md (1,181 lines): two-stage boot (Table Data ROM → Program ROM), SubCPU hardware reset release (SET 0 PA), E1 bulk transfer protocol (9 blocks, 192KB payload), DMA state machine (3 states), handshaking signals (INTERCPU_STATUS), payload execution trigger (bit 6 at 0x04FE), complete timeline from power-on to system ready.","comments":[{"id":336,"issue_id":"kn5000-51z","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on SubCPU boot sequence documentation.","created_at":"2026-02-27T23:45:54Z"}]}
{"id":"kn5000-52e","title":"Boot: Document peripheral initialization order","description":"Trace initialization of all peripherals in boot sequence order: serial channels (SC0/SC1), timers (T0-TB), interrupts (INTA/INT0), FDC (0x110000), LCD controller (IC206), any other I/O. Document register values written during init.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:44:53.502794012-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:35:08.007980426-03:00","closed_at":"2026-01-26T08:35:08.007980426-03:00","close_reason":"Closed","comments":[{"id":26,"issue_id":"kn5000-52e","author":"fsanches","text":"Sub CPU peripheral initialization order (from boot ROM at 0xFF8290):\n\n**1. Watchdog (first, for safety):**\n- WDMOD_REAL (0x110) = 0x00 (disable)\n- WDCR_REAL (0x111) = 0xB1\n\n**2. Interrupt Controller:**\n- INT_CTRL (0x10A) = 0x04\n\n**3. Port Function Controls (GPIO setup):**\n- P0FC (0x07) = 0xFF, P1FC (0x0B) = 0xFF, P2FC (0x0F) = 0xFF\n- P7 (0x1C) = 0xFF, P7FC (0x1F) = 0x07, P7CR (0x1E) = 0x78\n- P8 (0x20) = 0x3B, P8FC (0x23) = 0x3F, P8CR (0x22) = 0xFF\n- PA (0x28) = 0xFF, PAFC (0x2B) = 0x08\n- PB (0x2C) = 0xFF, PBFC (0x2F) = 0x1F\n\n**4. Interrupt/Status Registers:**\n- INTTC01 (0x30) = 0x03\n- Registers 0x32-0x3F configured for serial\n\n**5. Extended Port Registers:**\n- P8_FC_LO (0x44) = 0xFF\n- P8_FC_EXT (0x47) = 0x18\n- P8_FC_HI (0x46) = 0x07\n- PE_DATA (0x68) = 0x00, PE_CR (0x6A) = 0xFF\n\n**6. 8-bit Timers:**\n- TREG0 (0x84) = 0x1D, TREG1 (0x85) = 0x1D\n- T8RUN (0x82) = 0x00\n- T23MOD (0x88) = 0x0A, T23FFCR (0x89) = 0x10\n- TREG2 (0x8A) = 0x40, TREG3 (0x8B) = 0x20\n- T01FFCR (0x81) = 0x00, T01MOD (0x80) bit 1 set\n\n**7. 16-bit Timer 4:**\n- T4MOD (0x98) = 0x05, T4FFCR (0x99) = 0x00\n- CAP4H (0x9F) = 0x00, CAP4L (0x9E) = 0x00, then set bit 7\n\n**8. Serial Channels:**\n- SER0_MOD (0xD2) = 0x01, SER0_CR (0xD1) = 0x00\n- SER0_BAUD (0xD3) masked with 0xCF then 0xF0\n- SER1_MOD (0xD6) = 0x29 then modified, SER1_CR (0xD5) = 0x00\n- SER1_BAUD (0xD7) masked similarly\n\n**9. Port F (after serial):**\n- PORT_FC_4 (0xF6) = 0x00","created_at":"2026-01-26T06:35:55Z"},{"id":27,"issue_id":"kn5000-52e","author":"fsanches","text":"**Main CPU Peripheral Initialization Order (RESET_HANDLER at 0xEF03C6):**\n\n**1. Watchdog Timer (first for safety):**\n- WDMOD = 0x00 (disable)\n- WDCR = 0xB1\n\n**2. Clock Configuration:**\n- CLKMOD = 0x04\n\n**3. Port Configuration (GPIO setup):**\n```\nPF = 0x00, PFFC = 0x73 (control panel enabled, MIDI disabled), PFCR = 0x15\nPB = masked with 0xF0\nP8 bit 3 cleared, PF bit 2 cleared\nP2FC = 0xFF, P3FC = 0xFF\nP7 = 0xFF, P7FC = 0x1F, P7CR = 0x00\nPA = 0xFE, PAFC = 0x08\nPB = 0xFF, PBFC = 0x1F\nPC = 0x03, PCFC = 0x00, PCCR = 0x02\nPD = 0x00, PDFC = 0x06, PDCR = 0x11\nPE = 0x00, PEFC = 0x42, PECR = 0x20\nPH = 0x00, PHFC = 0x1E, PHCR = 0x09\nPZ = 0xFF, PZCR = 0x03\n```\n\n**4. 8-bit Timers:**\n- T01MOD = 0x1D, T23MOD = 0x1D\n- T02FFCR = 0x00\n- TREG0 = 0x0A, TREG1 = 0x10, TRDC = 0x00\n- T8RUN bit 1 set\n\n**5. 16-bit Timer 4:**\n- T4MOD = 0x05, T4FFCR = 0x00, T16CR = 0x00\n- TREG4L = 0x0001, TREG5L = 0x3D09\n- T16RUN bits 7 and 0 set\n\n**6. Memory Controller Setup:**\n(See kn5000-cav for detailed MSAR/MAMR/BxCS values)\n\n**7. DRAM Initialization:**\n- Delay loops + DRAM1REF/CRL/CRH configuration\n\n**8. Serial Channel 0:**\n- SC0MOD = 0x29, SC0CR = 0x00\n- BR0CR masked\n\n**9. DAC (Audio Output):**\n- DAREG0 = 0xFF, DAREG1 = 0xFF, DADRV = 0x03\n\n**10. Stack Pointer:**\n- XSP = 0x00000C00\n\n**11. Post-Init (calls to subroutines):**\n- Seems_to_copy_some_data_buffers\n- MainCPU_self_test_routines\n- Get_Firmware_Version\n- Some_VGA_setup (if running boot ROM)\n- Interrupt priority setup (INTET01, INTET45)\n- Region detection\n- HD-AE5000 init (if present)\n- Control panel button read\n\nBoth CPUs follow similar initialization pattern: watchdog → clock → ports → timers → serial → memory\n\nStatus: Well documented for both CPUs.","created_at":"2026-01-26T10:47:49Z"},{"id":28,"issue_id":"kn5000-52e","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Peripheral Initialization Order' section (lines ~530-544) with documented sequence from both main and sub CPU. Replace 'Expected order' with actual confirmed order with register values. Include timing information if known.","created_at":"2026-01-26T11:32:18Z"},{"id":29,"issue_id":"kn5000-52e","author":"fsanches","text":"Website updated: reverse-engineering.md 'Peripheral Initialization Order' section now has confirmed order table for both main CPU and sub CPU, with register names and values. Replaced 'Expected order' with actual documented sequence.","created_at":"2026-01-26T11:35:07Z"}]}
{"id":"kn5000-595","title":"Boot: Document sub CPU startup handshake","description":"Trace main CPU code that initializes sub CPU communication. Document: when sub CPU is released from reset, MicroDMA payload transfer trigger, latch communication at 0x120000 during boot, how main CPU knows sub CPU is ready. Cross-reference with SubCPU tasks.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:44:54.122327932-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:36:12.808007614-03:00","closed_at":"2026-01-26T08:36:12.808007614-03:00","close_reason":"Closed","comments":[{"id":30,"issue_id":"kn5000-595","author":"fsanches","text":"Sub CPU boot sequence documented from boot ROM disassembly:\n\n**Reset Vector (0xFFFEE0):**\n- Loads PC from 0xFFFF00-0xFFFF02: jumps to BOOT_INIT at 0xFF8290\n\n**BOOT_INIT sequence (0xFF8290):**\n1. Disable watchdog: WDMOD_REAL=0, WDCR_REAL=0xB1\n2. Set interrupt control: INT_CTRL=0x04\n3. Configure all port function controls (P0-PB)\n4. Configure interrupt/serial registers (0x30-0x3F area)\n5. Configure extended port registers (P8_FC, PE)\n6. Set up timers (TREG0-3, T01MOD, T23MOD, T4MOD)\n7. Configure memory controller blocks (MSAR0-5, MAMR0-5, B0-B5 CSL/CSH)\n8. Initialize serial channels (SER0, SER1)\n9. Configure DRAM controller (refresh, timing)\n10. Set stack pointer: XSP = 0x05A2\n11. Copy interrupt trampolines: COPY_VECTORS (0xFF8F6C -\u003e 0x0400, 225 bytes)\n12. Enable interrupts: EI 0\n13. Call INIT_MEMORY_TEST (0xFF8956)\n14. Call INIT_DMA_SERIAL (0xFF85AE)\n15. Call INIT_TONE_GEN (0xFF84A8)\n16. Enter MAIN_LOOP\n\n**MAIN_LOOP handshake:**\n- Clears bit 6 of SUBCPU_STATUS_FLAGS (0x04FE)\n- Polls bit 6 waiting for payload ready signal\n- When ready: EI 6, calls PAYLOAD_ENTRY (0x0400)\n- Continuously updates interrupt control based on serial status\n\n**How main CPU knows sub CPU is ready:**\n- Sub CPU sets bit 0 of INTERCPU_STATUS (0x34) when ready\n- Main CPU polls bit 4 which sub CPU monitors\n- E3 command sets bit 6 of SUBCPU_STATUS_FLAGS to signal payload ready","created_at":"2026-01-26T06:35:36Z"},{"id":31,"issue_id":"kn5000-595","author":"fsanches","text":"**Main CPU side of handshake (inferred from memory map and architecture):**\n\nThe inter-CPU communication latch at 0x120000 is used bidirectionally:\n- Main CPU writes commands to 0x120000\n- Sub CPU reads from same address via DMA\n- Handshaking via INTERCPU_STATUS register bits\n\n**Command Protocol (from Sub CPU boot ROM):**\n```\n0x00-0x1F: General commands (bits 7-5 = handler, bits 4-0 = length-1)\n0xE1: DMA transfer type 1 (multi-stage, 6 bytes)\n0xE2: DMA transfer type 2 (payload, 10 bytes)\n0xE3: Signal payload ready (triggers bit 6 of SUBCPU_STATUS_FLAGS)\n```\n\n**Payload Transfer Sequence:**\n1. Main CPU loads payload into RAM\n2. Main CPU sends E2 command with address/size parameters\n3. Sub CPU receives via DMA, stores to destination\n4. Main CPU sends E3 to signal all payload data ready\n5. Sub CPU sets bit 6 of status flags\n6. Sub CPU boot ROM detects bit 6, calls PAYLOAD_ENTRY (0x0400)\n\n**Note:** The main CPU firmware at 0xE00000+ likely has a routine that performs this payload transfer during boot. The exact location needs tracing from the main CPU reset handler's call sequence.\n\nStatus: Well documented from Sub CPU perspective. Main CPU side needs firmware tracing to identify exact routine locations.","created_at":"2026-01-26T10:49:01Z"},{"id":32,"issue_id":"kn5000-595","author":"fsanches","text":"REOPENING: Need to verify if reverse-engineering.md 'Sub CPU Startup' section has actual handshake sequence documentation vs generic 'Sequence:' placeholder. Update with documented reset, DMA transfer, latch comm, and ready signal sequence with code addresses.","created_at":"2026-01-26T11:32:40Z"},{"id":33,"issue_id":"kn5000-595","author":"fsanches","text":"Website updated: reverse-engineering.md 'Boot Sequence' section now documents confirmed 8-step startup flow from firmware analysis, plus key sub CPU boot ROM routines table with addresses and functions.","created_at":"2026-01-26T11:36:12Z"}]}
{"id":"kn5000-5a0","title":"Fix 177 divergent bytes in Main CPU ROM (24-bit address encoding issue)","notes":"177 divergent bytes in Main CPU ROM must be fixed for 100% match.\n\n**Current state:** 99.99% match, 177 bytes differ due to 24-bit address encoding issues.\n\n**Required work:**\n- Analyze divergent byte locations\n- Fix ASL macro encodings in tmp94c241.inc\n- Verify instruction semantics match original\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** 100% ROM reconstruction\n**Dependencies:** None\n**Related:** kn5000-kqy (same issue), kn5000-3o6 (ASL macros)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-26T09:26:48.608933687-03:00","created_by":"fsanches","updated_at":"2026-02-21T00:59:58.66673958-03:00","closed_at":"2026-02-21T00:59:58.66673958-03:00","close_reason":"Closed","comments":[{"id":34,"issue_id":"kn5000-5a0","author":"Felipe Correa da Silva Sanches","text":"Note: kn5000-kqy closed as duplicate. All 177-byte tracking consolidated here.","created_at":"2026-01-31T03:02:53Z"},{"id":35,"issue_id":"kn5000-5a0","author":"Felipe Correa da Silva Sanches","text":"RESOLVED (Feb 21): Main CPU ROM now at 100.00% byte-match. All 177 divergent bytes have been fixed. The 24-bit address encoding issues in ASL macros were resolved in earlier sessions. Verified with compare_roms.py.","created_at":"2026-02-21T03:59:58Z"}]}
{"id":"kn5000-5ck","title":"Audio: Document proprietary CC handlers (0x97, 0x9B-0x9D)","notes":"The Voice_CtrlChange handler in Sub CPU has handlers for proprietary Control Change numbers:\n\n- Voice_CC_97 at 0x02A496\n- Voice_CC_9B at 0x02A4AB  \n- Voice_CC_9C at 0x02A4C0\n- Voice_CC_9D at 0x02A4D5\n\nThese are not standard MIDI CCs. Need to:\n1. Trace what parameters they modify\n2. Determine if they control effects, filters, or other synthesis parameters\n3. Document in midi-subsystem.md\n\nReference: subcpu/kn5000_subprogram_v142.asm around line 25167-25210","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:12.278213398-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T04:33:28.899561198Z","closed_at":"2026-02-28T04:33:28.899561198Z","close_reason":"Completed in this session: all 6 proprietary CCs (0x91-0x9D) documented in audio-subsystem.md (Synthesis Architecture section) and midi-subsystem.md. CC91=freq mult, CC95=portamento, CC97=fine pitch, CC9B=vibrato depth, CC9C=vibrato enable, CC9D=tremolo depth."}
{"id":"kn5000-5dc","title":"Video: Document UI widget rendering","description":"Analyze how UI elements are drawn: buttons, sliders, menus, piano keyboard display, waveform displays, level meters. Document widget drawing routines, any sprite system, and how interactive elements are updated.","notes":"UI widget rendering is essential for menu display.\n\n**Current state:** Widget types partially cataloged, rendering unknown.\n\n**Required work:**\n- Identify widget type definitions\n- Trace widget draw routines\n- Document widget hierarchy and layout\n- Map parameter binding to widgets\n\n**Phase:** 2 - Core Functionality\n**Blocks:** Menu system in emulator\n**Dependencies:** Drawing primitives (kn5000-gln), fonts (kn5000-kev)\n**Related:** kn5000-x13 (widget catalog), kn5000-4bt (UI symbols)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:46:03.614860579-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:15:45.299966794Z","closed_at":"2026-02-28T00:15:45.299966794Z","close_reason":"UI widget rendering documented: shape primitives, icon system, progress bars, widget handlers, LCD control.","comments":[{"id":343,"issue_id":"kn5000-5dc","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting UI widget rendering documentation. Dependencies satisfied: drawing primitives (kn5000-gln), fonts (kn5000-kev), screen regions (kn5000-rq0).","created_at":"2026-02-28T00:11:47Z"},{"id":344,"issue_id":"kn5000-5dc","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: UI widget rendering documented:\n- Rectangle primitives: DrawBox (filled), DrawFrame (outline), DrawFrameEx (styled w/ XOR), DrawDesignFrame, DrawDesignBox\n- Icon system: DrawIcons at 0x938000 (separate from bitmap table at 0x913000)\n- Special bitmaps: DrawBitmapSP, DrawBitmapSPFast, DrawBitmapSP2, DrawBitmapFile\n- Progress bars: DrawProgressRectH/V with 3 fill modes (center/left/right)\n- Widget handlers: GroupBoxProc, LabelProc, EditSwProc, TextBoxProc + many domain-specific\n- LCD control: LcdOn/LcdOff, ChangePalette, ChangeWall, ChangeWallPalette\n- All key functions annotated in assembly, documented in display-subsystem.md\nRELEASED: Work complete.","created_at":"2026-02-28T00:15:45Z"}]}
{"id":"kn5000-5il7","title":"LLVM backend: Replace all raw encoding wrappers with semantic instructions","description":"1,345 instructions across all 6 ROMs use raw encoding wrappers (sriXN, erpXN, sd8XN, etc.) instead of semantic TLCS-900 mnemonics. These are opaque byte sequences that need proper instruction definitions in the LLVM backend and converter tiers to emit them. Breakdown: CP (696), AND (116), BIT (91), ADD (86), OR (58), PUSHW (55), LD/LDW (54), STCF/LDCF/XORCF (36), and others. Addressing modes involved: Q-bank registers (erp), register+register indexed (sri), stack-relative (sri with XSP), SFR direct (sd8), 16/24-bit direct (sd16/sd24), post-increment (spi).","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T12:24:27.27339886-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T14:00:15.675026395-03:00","closed_at":"2026-02-23T14:00:15.675026395-03:00","close_reason":"Closed","comments":[{"id":255,"issue_id":"kn5000-5il7","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on eliminating raw encoding wrappers.","created_at":"2026-02-23T15:24:32Z"},{"id":256,"issue_id":"kn5000-5il7","author":"Felipe Correa da Silva Sanches","text":"Starting implementation: catalog wrappers, add ExtAddrModeOpImmInst, define ~150 semantic instructions, update converter.","created_at":"2026-02-23T16:31:27Z"},{"id":257,"issue_id":"kn5000-5il7","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All 2,251 raw encoding wrappers replaced with 219 semantic LLVM instructions. Zero raw wrappers remain. All 6 ROMs: 100% byte match. ExtAddrModeInst class removed from LLVM backend.","created_at":"2026-02-23T17:00:11Z"}]}
{"id":"kn5000-5jy","title":"Homebrew: Development toolkit and SDK planning","notes":"Plan and track homebrew development toolkit creation.\n\n## Toolkit Components\n\n### Assembly Development\n- ASL macro library for common patterns\n- TMP94C241 instruction reference\n- Memory map constants file\n- Example programs\n\n### C Development (Long-term)\n- LLVM backend for TLCS-900/H2 (tracked in kn5000-raw)\n- libc port or minimal runtime\n- Hardware abstraction layer\n\n### Tools\n- Image converter (bin \u003c-\u003e PNG/BMP)\n- MIDI file extractor\n- ROM patcher/builder\n- Emulator integration\n\n## Documentation Needed\n- Getting started guide\n- Hardware programming reference\n- API documentation\n- Example walkthrough\n\n## Related Issues\n- kn5000-9zb: SDK documentation and examples\n- kn5000-raw: LLVM backend development\n- kn5000-pkx: Image converter\n\n## Success Criteria\n- Documented build process for homebrew\n- At least one working example program\n- Community can build and test code","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:47.387097655-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:47.387097655-03:00"}
{"id":"kn5000-618","title":"HDAE5000: Analyze PPI interface at 0x160000","description":"Reverse engineer the 8255 PPI interface used to communicate with HD-AE5000. Document port A/B/C assignments, control register settings, and data transfer protocol. Cross-reference with main CPU firmware at addresses accessing 0x160000.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:33:15.439559064-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:36:43.54449357-03:00","closed_at":"2026-01-26T08:36:43.54449357-03:00","close_reason":"Closed","comments":[{"id":36,"issue_id":"kn5000-618","author":"fsanches","text":"HDAE5000 PPI Interface Analysis (from main CPU firmware):\n\n**PPI Port Addresses:**\n```\nHDAE5000_PPI__PORT_A      = 0x160000  ; Output port\nHDAE5000_PPI__PORT_B      = 0x160002  ; Input port  \nHDAE5000_PPI__PORT_C      = 0x160004  ; Output port (control signals)\nHDAE5000_PPI__CONTROL_REG = 0x160006  ; PPI control register\nHDAE5000_ROM__BASE_ADDR   = 0x280000  ; HDAE5000 ROM (512KB)\n```\n\n**PPI Initialization (HDAE5000_Parport_Setup at 0xEF4BCC):**\n1. Bus control: B5CSL = 0x66 (bus timing for HDAE5000)\n2. PPI control: 0x82 - decoded as:\n   - Mode set (bit 7 = 1)\n   - Port A: Mode 0, Output\n   - Port B: Mode 0, Input  \n   - Port C: Output (both upper and lower nibbles)\n3. Port A = 0x00 (clear output port)\n4. Port C = 0x00, then 0x0F (pulse control signals)\n5. Delay loop (0xDBBA0 iterations)\n6. Port C = 0x00 (clear control signals)\n7. Poll Port B bit 0 until clear (wait for HDAE5000 ready)\n\n**Port C Control Signals (from code at 0xEF4A6A-0xEF4B53):**\n- Bit 0: Strobe signal (SET 0, then RES 0)\n- Bit 1: Secondary strobe\n- Bit 2: Data direction/select (CHG 2 toggles)\n- Bit 3: Another control signal (CHG 3 toggles)\n- Values 0x01, 0x02, 0x04, 0x08 written individually\n\n**Data Transfer Protocol:**\n- Port A is used for data output (byte values written)\n- Port B is used for status input (bit 0 = busy/ready)\n- Port C provides handshaking control signals\n\n**HD-AE5000 Detection (0xEF05B0):**\n```asm\nBIT 0, (PE)           ; Check PE port bit 0\nJR NZ, skip_hdae      ; If set, HD-AE5000 NOT present\nCALR Get_Area_Region_Code\nCP L, 4               ; Check region code\nCALL NZ, HDAE5000_Parport_Setup ; Init if present\n```\n\nThe HD-AE5000 presence is detected via PE port bit 0 (active low).","created_at":"2026-01-26T10:41:24Z"},{"id":37,"issue_id":"kn5000-618","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md HDAE5000 section with actual PPI port addresses (0x160000-0x160006), control register value (0x82), Port C signal assignments, detection code (PE bit 0), and initialization sequence. Currently shows generic 'Tasks:' list.","created_at":"2026-01-26T11:32:29Z"},{"id":38,"issue_id":"kn5000-618","author":"fsanches","text":"Website updated: reverse-engineering.md 'PPI Interface' section now documents port addresses (0x160000-0x160006), control register value (0x82), Port C signal assignments, initialization sequence at 0xEF4BCC, and HDAE5000 detection code at 0xEF05B0.","created_at":"2026-01-26T11:36:43Z"}]}
{"id":"kn5000-61vj","title":"LLVM converter: remaining sub-opcodes — RLD, RETI, INCF (~300 .byte)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:11:07.63703232-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:57:01.101127581-03:00","closed_at":"2026-02-22T15:57:01.101127581-03:00","close_reason":"Closed","comments":[{"id":179,"issue_id":"kn5000-61vj","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work. 250 extpfx remain — all register prefix (C8-EF) with rare sub-opcodes.","created_at":"2026-02-22T18:54:46Z"},{"id":180,"issue_id":"kn5000-61vj","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: 250 remaining extpfx analyzed — all register prefix (C8-EF) with rare sub-opcodes: LINK/UNLK (42), 8-bit MUL/DIV rr (35), MINC/MDEC (33), XORCF/STCF/LDC (36), EX (19), SCC/RLC with extended regs (rest). All correctly encoded. Adding individual converter tiers for 250/232K instructions has diminishing returns. RELEASED.","created_at":"2026-02-22T18:57:00Z"}]}
{"id":"kn5000-67g","title":"Document ROM interleaving formats for all ROM chips","notes":"Different ROM components use different interleaving formats. This caused confusion during table_data bitmap extraction.\n\n**Formats discovered:**\n\n| ROM | Interleaving | Notes |\n|-----|--------------|-------|\n| Main CPU | None (single chip) | 2MB linear |\n| Sub CPU Boot | None (single chip) | 128KB linear |\n| Sub CPU Payload | None (sent by maincpu) | 192KB linear |\n| Table Data | 16-bit WORD-level | odd.ic1 + even.ic3, alternating 16-bit words |\n| HDAE5000 | None (single chip) | 512KB linear |\n\nThe table_data ROM is NOT byte-interleaved but WORD-interleaved:\n- Correct: even[0:2] + odd[0:2] + even[2:4] + odd[2:4] ...\n- Wrong: even[0] + odd[0] + even[1] + odd[1] ...\n\nThis should be documented in:\n1. CLAUDE.md for developer reference\n2. rom-reconstruction.md (partially done)\n3. Hardware architecture docs\n\nReference: kn5000_table_data.rom combination analysis","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:37:50.388569372-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:37:57.061923201-03:00","comments":[{"id":39,"issue_id":"kn5000-67g","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): ROM interleaving formats are well-documented in issue notes. Table data 16-bit WORD-level interleaving was the key discovery. Now that table_data is at 100% byte-match, the interleaving handling is confirmed correct. This issue is primarily about adding the documentation to CLAUDE.md and hardware architecture docs — the knowledge exists but isn't formally documented in all the right places.","created_at":"2026-02-21T04:02:22Z"}]}
{"id":"kn5000-6abu","title":"HDAE5000 FS: Disassemble FS_Write_FSB (5,072 bytes at 0x288295)","description":"Disassemble the HDAE5000_FS_Write_FSB routine (5,072 bytes, currently .incbin blob). This writes the File System Block back to disk. Understanding it will reveal how FSB/FGB/FEB metadata is serialized to disk sectors, complementing the already-disassembled FS_Read_FSB. Located at code_2803c2_28f542.bin offset 32467.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:29:53.567983001Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T05:36:56.129506391Z","closed_at":"2026-02-27T05:36:56.129506391Z","close_reason":"FS_Write_FSB fully disassembled (5072 bytes, 1402 instructions, 100 labels). 100% byte match verified.","comments":[{"id":302,"issue_id":"kn5000-6abu","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting disassembly of FS_Write_FSB using same approach as FS_Init (unidasm + .byte with labels).","created_at":"2026-02-27T05:35:29Z"}]}
{"id":"kn5000-6f7","title":"Update: Document update progress display","description":"Analyze LCD messages during update process. Correlate extracted 1-bit bitmaps with update stages: Flash Memory Update, Please Wait, Now Erasing, FD to Flash Memory, Completed, Turn On AGAIN, Illegal Disk. Document state machine.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:48.307640562-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:34:48.307640562-03:00"}
{"id":"kn5000-6je","title":"Document jump tables in maincpu ROM","notes":"The maincpu ROM contains numerous jump tables used for dispatch. Found patterns include:\n\n**Indirect call patterns:**\n- CALL T, XHL - calls through XHL register\n- CALL T, XIX - calls through XIX register\n- JP T, XIX + WA - indexed jump with WA offset\n- JP T, XIX + BC - indexed jump with BC offset\n- JP T, XIX + DE - indexed jump with DE offset\n\n**Known jump tables:**\n1. HANDLE_UPDATE_OFFSETS (0xE00178) - 16-bit offset table for update file handling\n2. LABEL_EF0D64 - 3-entry address table for state machine\n3. LABEL_EF0DA5 - 16-entry address table for sub-state handling\n4. Large address table at line 36362 (~170 entries for handler dispatch)\n5. Address tables at E1611A, E16128, E16136 (encoder handling)\n6. Jump table at F97D8D with 12+ undisassembled target routines\n\n**Work needed:**\n- Label all jump tables with meaningful names\n- Ensure all target routines are disassembled\n- Document the purpose of each table\n- Create cross-references in comments","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T13:51:31.882738835-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:44.288920485-03:00","comments":[{"id":40,"issue_id":"kn5000-6je","author":"fsanches","text":"Progress on jump table documentation:\n\n**Renamed and documented tables:**\n- FDC_HANDLER_OFFSETS (0xEA98CA) - 12-entry offset table for FDC command dispatch\n- FDC_HANDLER_DISPATCH_BASE (0xF97D8D) - Base routine with 12 handlers (FDC_HANDLER_00-11)\n- UI_STATE_MACHINE_TABLE (0xEF0D64) - 3-entry state machine for UI\n- UI_SUBSTATE_TABLE (0xEF0DA5) - 16-entry sub-state table\n- SOUND_DATA_SECTION_PTRS (0xE023B0) - 16 pointers to sound category data\n- SOUND_CATEGORY_NAMES (0xE023F0) - 18 sound category name strings\n\n**Updated handlers:**\n- FDC_HANDLER_00 through FDC_HANDLER_11 renamed with purpose comments\n- UI state handlers renamed (UI_STATE_0_IDLE, UI_STATE_1_PROCESS, UI_STATE_2_SUBSTATE)\n- UI sub-state handlers renamed (UI_SUBSTATE_CLEAR_FLAGS, etc.)\n\n**Still needs work:**\n- 12 FDC helper routines still in raw bytes (LABEL_F97652 block)\n- Many LDA raw address references still need investigation\n- Need to trace more jump tables from indirect call sites","created_at":"2026-01-26T17:10:21Z"},{"id":41,"issue_id":"kn5000-6je","author":"fsanches","text":"Subagent analysis completed:\n\n**Statistics found:**\n- 118 JP T, XIX + WA patterns (3 documented, 115 need naming)\n- 441 LDA XIX/XHL, 0E/0F*h patterns (raw address loads for jump tables)\n- 11 empty FDC handler routines in F9* range needing disassembly\n\n**New tables documented:**\n- SQTR_DISPATCH_TABLE_1 (0xF20D37) - Sequencer track handler\n- SQTR_DISPATCH_TABLE_2 (0xF20D8E) - Sequencer track handler  \n- APP_EVENT_HANDLER_TABLE (0xF44169) - Application event delivery\n\n**Updated:**\n- reverse-engineering.md with Jump Table Statistics section\n- Assembly source with meaningful names for 3 additional tables\n\n**Remaining work:**\n- 115 jump tables still using LABEL_* naming\n- 11 FDC handler routines need disassembly (tracked in kn5000-kc5)","created_at":"2026-01-26T17:20:00Z"},{"id":42,"issue_id":"kn5000-6je","author":"fsanches","text":"Additional tables documented:\n- NOTE_EVENT_DISPATCH_1 (0xF17155) - 7 note event handlers\n- NOTE_EVENT_DISPATCH_2 (0xF171C4) - 7 note event handlers  \n- UI_COMPONENT_DISPATCH (0xF1A7CB) - 8 UI component handlers\n- RESOURCE_INFO_HANDLERS (0xF1EA4C) - 10 resource info handlers (GetResouceInfo)\n- FDC_COMMAND_DISPATCHER (0xF96DB1) - 12 FDC command handlers\n- FDC_CMD_HANDLER_BASE (0xF96DD6) - FDC handler base address\n\n**Total tables documented in this session: 9**\n- Previous: 6 tables\n- New: 9 tables\n- **Current total: 15 documented jump tables**\n\nBuild verified successful after all changes.","created_at":"2026-01-26T17:22:54Z"},{"id":43,"issue_id":"kn5000-6je","author":"fsanches","text":"Agent 4 (CALL T, XHL) completed:\n- 103 CALL T, XHL patterns found\n- 5 labeled tables: LABEL_EF7809, LABEL_EFA361, LABEL_F24FA0, LABEL_F256B9, LABEL_F652BB\n- 6 undocumented tables using raw hex addresses only\n- High-use tables: 0xE9F11C (13 uses), 0xEA0A16 (12 uses)\n\n**Complete analysis summary:**\n| Pattern | Count |\n|---------|-------|\n| JP T, XIX + WA | 118 |\n| CALL T, XHL | 103 |\n| LDA XIX/XHL, 0E/0F*h | 441 |\n| **Total indirect dispatches** | ~221 |\n\n**Documentation progress:**\n- 15 jump tables now have meaningful names\n- reverse-engineering.md updated with statistics\n- ~200+ tables remaining to document","created_at":"2026-01-26T17:23:41Z"},{"id":44,"issue_id":"kn5000-6je","author":"fsanches","text":"Additional analysis from 6 parallel agents:\n\n**High-use jump tables documented:**\n- 0xE9F11C (13 uses) → EVENT_HANDLER_DISPATCH_TABLE\n  - 11 valid handlers + 2 padding entries\n  - Object/voice event dispatch system\n  \n- 0xEA0A16 (12 uses) → SingleLoadDstHandlerTable  \n  - 12 entries for data transfer subsystem\n  - Used by SingleLoadDstFunc\n\n**JP T, XIX + BC/DE analysis:**\n- 110 total patterns found (54 BC, 56 DE)\n- Only 4 tables documented (3%)\n- 106 tables still using LABEL_* names\n\nPriority groups identified:\n- P1: 22 GridBox parameter handlers\n- P2: 22 Title/display functions  \n- P3: 16 Display/melody functions\n- P4: 5 Window/UI management\n- P5: 21 Unknown context","created_at":"2026-01-26T17:38:23Z"}]}
{"id":"kn5000-6nst","title":"LLVM converter: Fix label-drift relative branches (JR/JRL/CALR) (~200 instructions)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T18:46:17.613092686-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:11:37.904718215-03:00","closed_at":"2026-02-22T19:11:37.904718215-03:00","close_reason":"Closed","comments":[{"id":203,"issue_id":"kn5000-6nst","author":"Felipe Correa da Silva Sanches","text":"DESCRIPTION: ~200 JR/JRL/CALR/JP/CALL instructions remain as .byte because their target label addresses have drifted from original ROM addresses, making PC-relative offsets incorrect. Includes CALR (26), JR (68 across condition codes), JRL (13), JP (41), CALL (76). Fix: improve label address tracking in the converter to handle cases where LLVM section layout shifts labels, or convert to absolute branches where possible.","created_at":"2026-02-22T21:46:23Z"},{"id":210,"issue_id":"kn5000-6nst","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting analysis of label-drift relative branches.","created_at":"2026-02-22T22:01:05Z"},{"id":211,"issue_id":"kn5000-6nst","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Added EQU-to-inline-label promotion for 33 ROM-address EQUs. Converted 18 branch instructions (CALR/JRL) from .byte to native. Remaining 74 branch fallbacks near code are hard cases: drifted labels (FmmDiskMedleySelectFunc etc.), local .name labels, or targets in unresolved data blocks. Would need two-pass label resolution or local label tracking for further improvement. 100% byte-match verified.","created_at":"2026-02-22T22:11:37Z"}]}
{"id":"kn5000-6oxr","title":"Block overflow: 2,328 instructions emitted as comments instead of native code","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T06:48:54.608797473-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T06:49:03.634259328-03:00","closed_at":"2026-02-23T06:49:03.634259328-03:00","close_reason":"Closed","comments":[{"id":228,"issue_id":"kn5000-6oxr","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Working on this issue.","created_at":"2026-02-23T09:49:03Z"},{"id":229,"issue_id":"kn5000-6oxr","author":"Felipe Correa da Silva Sanches","text":"Fixed. Root causes: (1) password_slot_routines.asm had ORG+binclude directives for F92C0E, F94193, F9426A regions that were redundant with medley.asm code, creating segment boundaries that truncated block buffers. (2) LABEL_FC3E63 was misnamed (actual address FC3E65), causing 2-byte block boundary error. Fix: removed all 3 binclude regions, deleted 3 binary files, converted 18 EQU labels to positioned labels in medley.asm, added 7 additional block boundary labels. Result: 0 block overflows (was 2,328), +2,405 native instructions, 0 .byte fallbacks.","created_at":"2026-02-23T09:49:03Z"},{"id":230,"issue_id":"kn5000-6oxr","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Issue resolved.","created_at":"2026-02-23T09:49:03Z"}]}
{"id":"kn5000-6p6","title":"LLVM Phase 3a complete: per-instruction .byte with 100% ROM match","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T19:22:15.905906534-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T19:22:19.946442213-03:00","closed_at":"2026-02-21T19:22:19.946442213-03:00","close_reason":"Closed","comments":[{"id":139,"issue_id":"kn5000-6p6","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Refactored convert_all() from segment-level 16-byte chunks to per-instruction .byte lines. Key innovations: block-based byte buffers (memoryview zero-copy), pre-scanned label boundaries (bisect), macro-def buffer isolation. 364K .byte lines, 25K block corrections, 5.4KB padding. 100.00% byte-match verified. Commit: 320e2e9.","created_at":"2026-02-21T22:22:27Z"}]}
{"id":"kn5000-6qi","title":"Video: Document LCD controller IC206 (MN89304)","description":"Research and document the MN89304 LCD controller. Find datasheet if available. Document: register map, supported video modes, pixel formats, timing parameters, interface to main CPU. Identify memory-mapped I/O addresses used to control the display.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:45:59.919930856-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:38:08.617689402-03:00","closed_at":"2026-01-26T08:38:08.617689402-03:00","close_reason":"Closed","comments":[{"id":45,"issue_id":"kn5000-6qi","author":"fsanches","text":"**MN89304 LCD Controller Analysis (from firmware reverse engineering):**\n\nThe MN89304 is a Panasonic LCD controller that provides **VGA-compatible register interface**.\n\n**I/O Port Addresses (memory-mapped):**\n```\n0x3C0: Attribute Controller Address/Data\n0x3C2: Misc Output Register (write)\n0x3C3: VGA Enable  \n0x3C4/3C5: Sequencer Address/Data\n0x3C6: DAC Mask\n0x3C8: DAC Write Address\n0x3C9: DAC Data (palette RGB)\n0x3CE/3CF: Graphics Controller Address/Data\n0x3D4/3D5: CRTC Address/Data\n0x3DA: Input Status 1\n```\n\n**Video Memory:** 0x1A0000\n\n**Display Characteristics (from CRTC register values):**\n- Horizontal Total: 0x65 (101 chars)\n- Horizontal Display End: 0x27 (39 chars = 320 pixels at 8 pixels/char)\n- Vertical Display End: 0xEF (239 lines → 240 lines)\n- Resolution: **320x240 pixels**\n- Dot clock: 25 MHz (from Misc Output = 0xE3)\n- Refresh: ~60 Hz\n\n**Color Depth:**\n- EGA-compatible 16-color palette at indices 0-15\n- Full 256-color DAC palette programmable via 0x3C8/0x3C9\n- 8-bit color depth (256 colors)\n\n**Key Initialization (Some_VGA_setup at 0xEF55A7):**\n1. Global enable (0x3C3 = 0x01)\n2. Misc output for timing (0x3C2 = 0xE3)\n3. Sequencer reset and clock config\n4. Graphics controller mode setup\n5. CRTC timing parameters\n6. Attribute controller palette\n7. DAC palette colors\n\n**Reference:** See kn5000-t75 for complete initialization sequence.\n\nStatus: Documented from firmware. Datasheet not found but VGA compatibility confirmed.","created_at":"2026-01-26T11:19:42Z"},{"id":46,"issue_id":"kn5000-6qi","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'LCD Controller (MN89304)' section with documented register addresses, initialization sequence, and video modes. Currently just 'Tasks:' placeholders.","created_at":"2026-01-26T11:32:51Z"},{"id":47,"issue_id":"kn5000-6qi","author":"fsanches","text":"Website updated: reverse-engineering.md 'LCD Controller (MN89304)' section now documents all I/O port addresses, display configuration table, initialization sequence steps, and CRTC timing registers. Confirmed VGA compatibility.","created_at":"2026-01-26T11:38:08Z"}]}
{"id":"kn5000-6r49","title":"LLVM converter: 4 LD XHL, imm32 instructions stuck as .byte due to ASL db encoding","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T04:50:21.558573791-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T04:52:06.09756493-03:00","closed_at":"2026-02-23T04:52:06.09756493-03:00","close_reason":"Closed","comments":[{"id":224,"issue_id":"kn5000-6r49","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue. Four LD XHL, imm32 instructions at ASL source lines 178867, 178945, 179005, 179088. The ASL disassembler couldn't handle LD XHL and emitted them as db directives. LLVM assembles 'ld xhl, 4' correctly (encoding: 0x43,imm32_LE). Fix: detect db sequences matching 0x40-0x47 pattern in the converter and emit native ld r32, imm32.","created_at":"2026-02-23T07:50:35Z"},{"id":225,"issue_id":"kn5000-6r49","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Fixed. Extended convert_db comment parsing to handle 'TODO: Fix ASL: LD' pattern. All 4 LD XHL, imm32 now emit native instructions. 100% byte match.","created_at":"2026-02-23T07:52:06Z"}]}
{"id":"kn5000-70b","title":"Update: Document FDC interaction during update","description":"Trace how the Floppy Disk Controller (0x110000) is used during updates. Document: disk detection, file reading sequence, sector layout, error recovery, multi-disk handling (Change FD 2 of 2 message).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:46.756697997-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:17:38.080380391Z","closed_at":"2026-02-28T01:17:38.080380391Z","close_reason":"Already documented in flash-programming.md: FDC_Reset, FDC_ReadSector, FDC_MultiSectorRead with retry loop, Detect_Disk_Type with all 8 disk signatures, multi-disk handling (1/2, 2/2), full update flow (check→detect→validate→erase→program→verify→complete)."}
{"id":"kn5000-72q0","title":"LLVM migration Phase 6: Final documentation cleanup","description":"Update rom-reconstruction docs page to reflect LLVM-only status. Close any remaining ASL-limitation issues. Final cleanup.","status":"closed","priority":3,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-23T11:31:37.853959337-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:33:57.791212409-03:00","closed_at":"2026-02-23T11:33:57.791212409-03:00","close_reason":"Closed","comments":[{"id":250,"issue_id":"kn5000-72q0","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Working on Phase 6 docs cleanup.","created_at":"2026-02-23T14:31:42Z"},{"id":251,"issue_id":"kn5000-72q0","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Phase 6 done. Updated rom-reconstruction.md (LLVM-only assembler, all 6 ROMs 100%, .asm→.s file references). Closed kn5000-3o6 (ASL macros no longer relevant). Updated roms-disasm CLAUDE.md with LLVM-only workflow. Updated MEMORY.md.","created_at":"2026-02-23T14:33:53Z"}]}
{"id":"kn5000-7egk","title":"LLVM: Add bank register prefix (C7/D7/E7) support (~16 instructions)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T18:46:37.653259243-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:17:15.616458916-03:00","closed_at":"2026-02-22T19:17:15.616458916-03:00","close_reason":"Closed","comments":[{"id":205,"issue_id":"kn5000-7egk","author":"Felipe Correa da Silva Sanches","text":"DESCRIPTION: 14-16 instructions use C7/D7/E7 bank register prefix (previous bank register set). The LLVM backend has no register definitions for bank registers. Fix: add TLCS-900 bank register definitions to the backend and converter handling. Minimal impact — only 16 instructions affected.","created_at":"2026-02-22T21:46:42Z"},{"id":215,"issue_id":"kn5000-7egk","author":"Felipe Correa da Silva Sanches","text":"Only 14-16 instructions use bank registers (C7/D7/E7 prefix). These would require LLVM backend changes to add bank register definitions. Extremely low impact. Closing as won't-fix.","created_at":"2026-02-22T22:17:15Z"}]}
{"id":"kn5000-7q2k","title":"LLVM codegen: direct addressing patterns for global/static variables","description":"Add ISel patterns to use direct addressing instructions (ADD32_da16, LD32_da16, CP32_da16, etc.) for operations on global/static variables instead of loading the address into a register first. Saves a register and an instruction per access.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T18:48:25.84443494-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:03:15.474652894-03:00","closed_at":"2026-02-23T19:03:15.474652894-03:00","close_reason":"Closed","comments":[{"id":270,"issue_id":"kn5000-7q2k","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on direct addressing patterns.","created_at":"2026-02-23T22:02:40Z"},{"id":271,"issue_id":"kn5000-7q2k","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Investigation shows the backend ALREADY uses direct addressing (E2/F2 24-bit prefixes) for global variable loads, stores, and ALU. The ISel patterns for LD32rm/LD32mr/ADD32mr etc. already match global addresses via the tlcs900_wrapper pattern. No additional work needed. Closing as already implemented.","created_at":"2026-02-23T22:03:15Z"}]}
{"id":"kn5000-7v8","title":"Update: Document complete update procedure for users","description":"Write end-user documentation for performing system updates. Include: required materials, step-by-step instructions, troubleshooting, safety warnings about power loss during update. Add to documentation website.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-25T05:34:54.524548425-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:34:54.524548425-03:00"}
{"id":"kn5000-7vw","title":"Update: Identify Flash ROM chip types","description":"Document the Flash ROM chips used for updatable storage. From service manual: identify manufacturer, part numbers, capacity, sector size, command set (JEDEC, AMD, Intel). Chips at 0xE00000 (program) and 0x300000 (custom data).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T05:34:42.200878262-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:40:04.928352206-03:00","closed_at":"2026-01-26T08:40:04.928352206-03:00","close_reason":"Closed","comments":[{"id":48,"issue_id":"kn5000-7vw","author":"fsanches","text":"**Flash ROM Chip Identification (from service manual schematic):**\n\n**Program ROM (0xE00000 - 2MB total):**\n| IC | Part Number | Type | Size | Bus |\n|----|-------------|------|------|-----|\n| IC4 | QV1GFKN5KAX1 | Flash ROM | 8Mbit (1MB) | EVEN bytes |\n| IC6 | QV1GFKN5KAX1 | Flash ROM | 8Mbit (1MB) | ODD bytes |\n\n**Custom Data Flash (0x300000 - 1MB):**\n| IC | Part Number | Type | Size |\n|----|-------------|------|------|\n| IC19 | QV1GFKN5KAX1 | Flash ROM | 8Mbit (1MB) |\n\n**Chip Analysis:**\n- Part number \"QV1GFKN5KAX1\" appears to be Matsushita/Panasonic custom\n- QV prefix = Panasonic semiconductor\n- KN5K suffix likely indicates KN5000-specific mask/configuration\n- 8Mbit = 1 megabyte capacity per chip\n- Program ROM uses 2 chips in even/odd configuration for 16-bit bus\n\n**Memory Organization:**\n- IC4 (EVEN): Addresses 0xE00000, 0xE00002, 0xE00004... (even bytes)\n- IC6 (ODD): Addresses 0xE00001, 0xE00003, 0xE00005... (odd bytes)\n- Combined: 2MB addressable as 16-bit words\n\n**Command Set:**\nLikely AMD/JEDEC compatible (common for era). Flash programming routines in firmware would reveal exact command sequences.\n\n**Related Firmware:**\n- FLASH_MEM_UPDATE routine at 0xEF???? handles programming\n- Issues kn5000-1tn and kn5000-dkx track Flash program/erase algorithms\n\nStatus: Chip identification documented. Command set needs firmware analysis.","created_at":"2026-01-26T11:25:30Z"},{"id":49,"issue_id":"kn5000-7vw","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Flash ROM Chips' section with documented chip types (QV1GFKN5KAX1), locations (IC4/IC6), capacities, and sector sizes. Also add to hardware-architecture.md if not present.","created_at":"2026-01-26T11:33:03Z"},{"id":50,"issue_id":"kn5000-7vw","author":"fsanches","text":"Website updated: reverse-engineering.md 'Flash ROM Chips' section documents QV1GFKN5KAX1 chips at IC4/IC6 (Program Flash) and IC19 (Custom Data). hardware-architecture.md Memory table already had this info.","created_at":"2026-01-26T11:40:04Z"}]}
{"id":"kn5000-81p","title":"Audio: Document Technics SysEx message format","notes":"The KN5000 likely uses Technics-specific System Exclusive messages for:\n\n1. Bulk data dumps (sounds, sequences, settings)\n2. Parameter editing\n3. Remote control features\n4. Device identification\n\nNeed to:\n1. Find SysEx handling in Main CPU MIDI code\n2. Document manufacturer ID and message structure\n3. Catalog known SysEx commands\n4. Test with external MIDI tools if possible\n\nSearch maincpu for: 0xF0 (SysEx start), 0xF7 (SysEx end), manufacturer ID bytes.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:52.770942735-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:03:52.770942735-03:00"}
{"id":"kn5000-87m","title":"Update: Create update file parser tool","description":"Build Python tool to parse and analyze update floppy files. Extract: header info, version numbers, payload data, checksums. Enable creation of custom update files for homebrew development.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-25T05:34:52.953978675-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:34:52.953978675-03:00"}
{"id":"kn5000-87u","title":"Images: Find embedded image locations in main CPU ROM","description":"Scan the main CPU ROM for embedded images. Look for: BMP headers (0x42 0x4D), consistent pixel data patterns, references in code to image addresses, LCD display routines that load image data. Document offset, size, and apparent format for each image found.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:37:55.765797716-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:45:15.773775921Z","closed_at":"2026-02-27T23:45:15.773775921Z","close_reason":"Already complete. 44 images found and extracted in maincpu/images/: 8 system update bitmaps (1-bit 224x22), 2 logos (Technics 312x45, KN5000 200x36), 13 split point indicators (58x52), 3 drawbar sliders (22x222), 3 MIDI diagrams (296x108), 4 transition effects, 7 accompaniment/edit graphics, worm easter egg (24x24). All have assembly labels with ROM offsets, .incbin directives, and are documented in image-gallery.md with converted PNGs.","comments":[{"id":335,"issue_id":"kn5000-87u","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting search for embedded images in main CPU ROM.","created_at":"2026-02-27T23:43:59Z"}]}
{"id":"kn5000-8dy","title":"Audio: Trace sound category data structures at 0xE023B0","notes":"The Main CPU has a pointer table at 0xE023B0 with 16 sound categories:\n\n0: PIANO, 1: GUITAR, 2: STRINGS \u0026 VOCAL, 3: BRASS, 4: FLUTE,\n5: SAX \u0026 REED, 6: MALLET \u0026 ORCH PERC, 7: WORLD PERC, 8: ORGAN \u0026 ACCORDION,\n9: ORCHESTRAL PAD, 10: SYNTH, 11: BASS, 12: DIGITAL DRAWBAR,\n13: ACCORDION REG., 14: GM SPECIAL, 15: DRUM KITS\n\nNeed to:\n1. Follow pointers to actual sound data\n2. Document sound data format (likely references to waveform ROM)\n3. Understand how sound selection maps to Sub CPU synthesis\n4. Document relationship to Program Change messages\n\nReference: SOUND_DATA_SECTION_PTRS at 0xE023B0 in maincpu.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:04:27.669888949-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:04:27.669888949-03:00"}
{"id":"kn5000-8q2","title":"Update website with service manual findings","description":"After extracting info from service manual schematics, update kn5000-docs website: add hardware architecture page, update control-panel-protocol.md with confirmed signals (DATA/BCK/ROTA/ROTB), add IC reference table, include block diagram description.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T04:09:04.125536919-03:00","created_by":"fsanches","updated_at":"2026-01-25T04:09:04.125536919-03:00","dependencies":[{"issue_id":"kn5000-8q2","depends_on_id":"kn5000-z9k","type":"blocks","created_at":"2026-01-25T04:09:11.501355254-03:00","created_by":"fsanches"}]}
{"id":"kn5000-8r82","title":"LLVM converter: Single-byte opcode tiers for LD r32, PUSH, POP, LDA (~2,500 .byte)","description":"Add converter tiers for single-byte opcodes in range 0x20-0x4F that are currently .byte fallback. These include: LD r32,#imm (0x40+r, ~660 groups), PUSH r32/POP r32 (0x28-0x2F, ~520 groups), PUSH #imm (0x28+size, ~520 groups), LDA XR,nn (0x20+r, ~420 groups), LD (n),#imm I/O writes (0x30+size, ~570 groups). The LLVM backend already defines these instructions — the gap is in the converter not recognizing the byte patterns.","status":"closed","priority":2,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:08:55.013570239-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T18:01:17.127733688-03:00","closed_at":"2026-02-22T18:01:17.127733688-03:00","close_reason":"Closed","comments":[{"id":197,"issue_id":"kn5000-8r82","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on single-byte opcode conversion.","created_at":"2026-02-22T20:56:00Z"},{"id":198,"issue_id":"kn5000-8r82","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Analysis shows all single-byte opcodes (0x20-0x5F) are already 99.98%+ converted. The ~2,500 estimate was from before previous sessions. Only 1,183 .byte instruction fallbacks remain total: 1,038 macro expansions (VGA/RegObjTabl), 66 direct-addressing via 0xBF, 42 label-drift branches, 37 misc edge cases. Closing as already complete.","created_at":"2026-02-22T21:01:16Z"}]}
{"id":"kn5000-8ro","title":"Documentation: Complete all subsystem placeholder pages","notes":"Track completion of all documentation website subsystem pages.\n\n## Placeholder Pages Needing Content\n1. audio-subsystem.md - Sound hardware and protocols\n2. display-subsystem.md - LCD and graphics system\n3. midi-subsystem.md - MIDI I/O and processing\n4. ui-framework.md - Widget system and rendering\n5. sequencer.md - Song/sequence playback\n6. storage-subsystem.md - Partial, needs completion\n\n## Pages Already Documented\n- control-panel-protocol.md ✓\n- inter-cpu-protocol.md ✓\n- hdae5000-disk-interface.md ✓\n- boot-sequence.md ✓\n- rom-reconstruction.md ✓\n\n## Success Criteria\n- All placeholder pages have substantive content\n- Code references link to assembly symbols\n- Each page has at least one diagram or table","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:27.268799925-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:27.268799925-03:00","comments":[{"id":51,"issue_id":"kn5000-8ro","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Documentation status check. Pages with substantial content: display-subsystem.md (architecture, VRAM layout, pixel format, palette — current and thorough), audio-subsystem.md (inter-CPU comm, payload transfer, ToneGen, MIDI dispatch, hardware ICs — current and detailed), rom-reconstruction.md (all ROM scores current at 100%, firmware version history — very current), control-panel-protocol.md, inter-cpu-protocol.md, boot-sequence.md. Still need content: midi-subsystem.md, ui-framework.md, sequencer.md, storage-subsystem.md.","created_at":"2026-02-21T04:00:42Z"}]}
{"id":"kn5000-8z5","title":"MAME: Display subsystem emulation milestone","notes":"Track completion of display subsystem emulation for MAME.\n\n## Required Components\n- [ ] VGA register emulation (MN89304 controller)\n- [ ] Framebuffer memory at 0x1A0000\n- [ ] Pixel format (16-bit RGB565 suspected)\n- [ ] Color palette handling\n- [ ] Drawing primitives\n\n## Related Issues\n- kn5000-ezo: VGA register documentation\n- kn5000-3c5: Framebuffer memory layout\n- kn5000-hy8: Pixel format and palette\n- kn5000-gln: Drawing primitives\n\n## Success Criteria\n- LCD displays boot splash correctly\n- UI elements render accurately\n- Text/fonts appear correctly","status":"open","priority":1,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:12.326930069-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:12.326930069-03:00","comments":[{"id":52,"issue_id":"kn5000-8z5","author":"Felipe Correa da Silva Sanches","text":"MAJOR PROGRESS (Feb 20): Display subsystem partially working in MAME. Framebuffer at 0x1A0000 confirmed as 320x240 8bpp linear. Palette load via DAC registers working. Mines homebrew renders game board correctly. MN89304 VGA controller emulated with mem_linear_r/w for VRAM access. SFR 0x0D53 bit 3 controls firmware display ownership. Remaining: full VGA register map, firmware boot splash rendering, font/text system.","created_at":"2026-02-21T03:33:01Z"},{"id":53,"issue_id":"kn5000-8z5","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Major display milestones achieved. Closed kn5000-3c5 (framebuffer at 0x1A0000: 320x240 8bpp linear) and kn5000-hy8 (pixel format: 8bpp indexed, 4-bit RAMDAC, palette via 0x1703C8/C9). MAME renders HDAE5000 homebrew content correctly. Mines game board displays with correct colors. Remaining: kn5000-ezo (full VGA register map — partial progress), kn5000-gln (drawing primitives — VRAM_FillRect identified, others unknown).","created_at":"2026-02-21T04:00:24Z"}]}
{"id":"kn5000-8zr","title":"LLVM: Fix bug #10 — register x/y swap on inlining","notes":"LLVM TLCS-900 backend bug #10: When functions are inlined, IX and IY registers get swapped in the generated code. Current workaround: use __attribute__((noinline)) on affected functions (e.g., tile_vram_ptr in Mines). This is one of 2 remaining active bugs in the TLCS-900 backend. Tracked in Mines memory (llvm-encoding-bugs.md).","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:33:36.547010281-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T05:00:12.264732172Z","closed_at":"2026-02-28T05:00:12.264732172Z","close_reason":"No longer reproducible. Original analysis used wrong register-parameter mapping. Code generation is correct with the XDE-first calling convention.","comments":[{"id":54,"issue_id":"kn5000-8zr","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Bug #10 remains UNFIXED in the LLVM TLCS-900 backend. Workaround still active in Mines video.c (line 82): __attribute__((noinline)) on tile_vram_ptr(). Recent LLVM work (10 commits) focused on LDIR/LDDR block transfers, peephole optimizations, frame pointer support, and 8-bit register encoding — none address this bug.","created_at":"2026-02-21T04:00:58Z"},{"id":370,"issue_id":"kn5000-8zr","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting investigation of Bug #10 after fixing Bug #11.","created_at":"2026-02-28T04:52:29Z"},{"id":371,"issue_id":"kn5000-8zr","author":"Felipe Correa da Silva Sanches","text":"Investigation complete: Bug #10 appears to be NO LONGER REPRODUCIBLE. The original analysis incorrectly assumed XBC=first parameter, but the calling convention (TLCS900CallingConv.td) has always been XDE-first, XBC-second: CCAssignToReg\u003c[XDE, XBC, XIX, XIY]\u003e. With this corrected mapping, the generated code for inlined tile_vram_ptr is correct: mul xbc,2560 multiplies dst_y (in XBC) by row stride, and sla xde,3 shifts dst_x (in XDE) for column offset. Constant-folded test set_tile(5,10,42) produces correct address 0x1A6428 = VRAM_BASE + 10*2560 + 5*8. Recommend: remove __attribute__((noinline)) workaround from Mines video.c and verify on MAME.","created_at":"2026-02-28T05:00:08Z"}]}
{"id":"kn5000-95a","title":"LLVM parallel build: Phase 3 - Progressive native instruction replacement","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T20:01:31.496817328-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T20:02:02.454425161-03:00","closed_at":"2026-02-21T20:02:02.454425161-03:00","close_reason":"Closed","comments":[{"id":140,"issue_id":"kn5000-95a","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Documenting Phase 3 completion.","created_at":"2026-02-21T23:01:45Z"},{"id":141,"issue_id":"kn5000-95a","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Phase 3 fully implemented in scripts/asl_to_llvm.py. All tiers done:\n\nStep 3a: Refactored convert_all() back to per-instruction .byte emission (from 16-byte chunks). Labels emitted as .set directives. 100% byte-match verified.\n\nStep 3b Tier Results (all 100% byte-match verified):\n- T1: Zero-operand (NOP, RET, RETI, HALT) — 5,284 native instructions\n- T2: 32-bit reg-imm loads (LD XWA,#imm) — 8,556 native instructions  \n- T3: Reg-reg ALU + single-reg ops + INC/DEC — 32,792 native instructions\n- T4: Reg-imm ALU (ADD/SUB/CP/AND/OR/XOR/ADC/SBC) — 11,751 native instructions\n- T5: Unconditional JP/CALL with hardcoded addresses — 14,952 native instructions\n- T6: PUSH/POP 32-bit registers — 9,207 native instructions\n- T7: Register-indirect LD (load/store via XBC/XHL/XSP etc) — 8,067 native instructions\n\nFinal stats: ~91K native instruction lines (24.9%), 592,545 native bytes (28.3% of ROM), 1,504,607 fallback bytes (71.7%).\n\nKey findings:\n- LLVM pads JR/JRL/CALR to 4 bytes (NOP padding) — cannot convert relative branches\n- 16-bit reg loads use different encoding (3-byte ROM vs 4-byte LLVM)\n- Short-form immediates (values 0-7) use 2-byte encoding LLVM doesn't produce\n- ROM byte verification essential: 771 ASL disassembly mismatches caught in T3 alone\n- Labels in block overflow regions at wrong addresses — use numeric JP/CALL targets\n\n8 commits: 320e2e9 through efac108","created_at":"2026-02-21T23:01:59Z"}]}
{"id":"kn5000-98j","title":"Sound: Document rhythm/accompaniment engine","description":"Analyze how auto-accompaniment works. Document: rhythm pattern format, chord detection algorithm, bass/chord/rhythm part generation, style structure (intro/main/fill/ending), variation switching.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:45.835760472-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:14:34.210306222Z","closed_at":"2026-02-28T01:14:34.210306222Z","close_reason":"Rhythm/accompaniment engine documented: style structure (3 vars × 6 sections × 5 channels), pattern loading pipeline, chord detection modes, key RAM addresses, drum kit loading. All in sequencer.md.","comments":[{"id":364,"issue_id":"kn5000-98j","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting analysis of auto-accompaniment/rhythm engine. Will trace rhythm ROM data format, pattern playback, chord detection, style structure (intro/main/fill/ending), and variation switching in the main CPU firmware.","created_at":"2026-02-28T01:11:30Z"},{"id":365,"issue_id":"kn5000-98j","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Auto-accompaniment engine documented in sequencer.md. Style structure: 3 variations (A/B/C) × 6 sections each. 5 channels per pattern (drums, bass, accomp1-3). Pattern loading via RhythmROM_PatternDispatcher with address formula: 0x400000 + base + (selector \u003c\u003c 8) + (type \u003c\u003c 14). 1024-byte pattern blocks into double-buffered RAM at 0x94800/0x95C00. 5 chord maps for chord detection modes. Key RAM addresses documented.","created_at":"2026-02-28T01:14:34Z"}]}
{"id":"kn5000-99f","title":"ROM Reconstruction: Achieve 100% byte-matching for all ROMs","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-25T02:47:58.902534555-03:00","created_by":"fsanches","updated_at":"2026-02-21T01:43:02.134982844-03:00","closed_at":"2026-02-21T01:43:02.134982844-03:00","close_reason":"Closed","dependencies":[{"issue_id":"kn5000-99f","depends_on_id":"kn5000-cfe","type":"blocks","created_at":"2026-01-25T02:52:43.370783157-03:00","created_by":"fsanches"},{"issue_id":"kn5000-99f","depends_on_id":"kn5000-kqy","type":"blocks","created_at":"2026-01-25T02:52:48.145433712-03:00","created_by":"fsanches"},{"issue_id":"kn5000-99f","depends_on_id":"kn5000-hlw","type":"blocks","created_at":"2026-01-25T02:52:52.023257522-03:00","created_by":"fsanches"}],"comments":[{"id":55,"issue_id":"kn5000-99f","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): 5 of 6 ROMs now at 100% byte-match! maincpu (100%), subcpu boot (100%), subcpu payload (100%), table_data (100%), hdae5000 (100%). Only custom_data remains at 0% (ROM not being built at all — 1MB). Overall romset: 82.80%. Dependencies kn5000-5a0 and kn5000-hlw now closed. New blocker: custom_data ROM reconstruction (new issue to be created).","created_at":"2026-02-21T04:00:14Z"},{"id":56,"issue_id":"kn5000-99f","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All 6 KN5000 ROMs now at 100% byte-match! maincpu (100%), subcpu boot (100%), subcpu payload (100%), table_data (100%), custom_data (100%), hdae5000 (100%). Overall romset: 100.00%. The last ROM (custom_data, IC19) was reconstructed in commit d9f77b7.","created_at":"2026-02-21T04:42:58Z"}]}
{"id":"kn5000-9a0","title":"Maintain documentation website","description":"Keep the kn5000-docs Jekyll website in sync with reverse engineering progress. Update status, add findings, maintain open questions list. Website repo: claude_jail/kn5000-docs/","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-25T03:23:05.168418102-03:00","created_by":"fsanches","updated_at":"2026-01-25T03:23:05.168418102-03:00"}
{"id":"kn5000-9bd","title":"Boot: Document audio subsystem initialization","description":"Trace initialization of tone generator and audio path. Document: sub CPU commands for audio init, DAC setup (IC310), DSP initialization (IC311), any audio self-test or calibration, when audio becomes ready for playback.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:44:56.398045446-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:49:27.187958307Z","closed_at":"2026-02-27T23:49:27.187958307Z","close_reason":"Substantially complete per existing comment from Jan 30. Audio_System_Init at 0x01FACB documented: InterCPU_Latch_Setup → DSP_System_Init → DSP2_Init → DSP_Init_Channels → ToneGen_Init. DSP state buffers, channel config, and audio subsystem docs all updated.","comments":[{"id":57,"issue_id":"kn5000-9bd","author":"Felipe Correa da Silva Sanches","text":"Substantially addressed by audio subsystem reverse engineering:\n\n- Documented Audio_System_Init routine at 0x01FACB\n- Call sequence: InterCPU_Latch_Setup -\u003e DSP_System_Init -\u003e DSP2_Init -\u003e DSP_Init_Channels -\u003e ToneGen_Init\n- Documented DSP state buffer initialization (0x041342, 0x041368)\n- Documented DSP channel configuration (4 channels at 0x130000)\n- All findings added to audio-subsystem.md\n\nBoot sequence is now understood for audio subsystem.","created_at":"2026-01-30T04:02:51Z"}]}
{"id":"kn5000-9jq","title":"Symbols: Rename remaining LABEL_* in Sub CPU audio code","notes":"While major audio routines were renamed, many helper labels remain as LABEL_*:\n\nSub CPU areas needing attention:\n- Voice helper routines (LABEL_02C6CD -\u003e Voice_SetPitch, etc.) - some done, verify completeness\n- DSP helper routines in 0x035xxx-0x036xxx range\n- Ring buffer helper labels\n- Audio processing loop internal labels\n\nApproach:\n1. Grep for remaining LABEL_02* and LABEL_03* in subcpu asm\n2. Analyze context to determine purpose\n3. Create meaningful names\n4. Add to sed script and apply\n\nReference: audio_subsystem_rename.sed for pattern.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:36.046478136-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:03:36.046478136-03:00","comments":[{"id":58,"issue_id":"kn5000-9jq","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 16-18): Massive semantic renaming campaign completed in sound subsystem. Renamed 100+ labels across maincpu and subcpu: melody sequencer, rhythm subsystem, sequencer/rhythm ROM, audio mixer init, sequencer ring buffer, Feature Demo. Both maincpu and subcpu assembly files now have predominantly semantic names for audio subsystem routines. Remaining: DSP helper routines in 0x035xxx-0x036xxx range, some internal loop labels.","created_at":"2026-02-21T03:33:21Z"},{"id":59,"issue_id":"kn5000-9jq","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Sound subsystem semantic renaming campaign made huge strides. Recent 8 commits renamed 100+ labels: melody sequencer (13 labels), rhythm subsystem (17 labels), sequencer/rhythm ROM (16 labels), audio mixer init, sequencer ring buffer (22 labels), Feature Demo (26 labels in maincpu), DSP ring buffer (1 in subcpu), and 19 address-based labels in subcpu. Both maincpu and subcpu now have predominantly semantic names for audio subsystem routines. Remaining: DSP helper routines in 0x035xxx-0x036xxx range, some internal loop labels.","created_at":"2026-02-21T04:01:03Z"}]}
{"id":"kn5000-9lg","title":"MAME: Create milestone tracking issue for emulator completion","notes":"Master tracking issue for MAME emulator completion milestones.\n\nCurrent MAME PR: #14558 (in progress)\n\n**Phase 1 - Boot and Display** (blocks visual output):\n- [ ] VGA register emulation (kn5000-ezo)\n- [ ] Framebuffer rendering (kn5000-3c5)\n- [ ] LCD output working\n- [ ] Fix 177 divergent bytes (kn5000-5a0, kn5000-kqy)\n\n**Phase 2 - Audio** (blocks sound output):\n- [ ] DSP emulation or HLE (kn5000-1oy)\n- [ ] DAC output (kn5000-xel)\n- [ ] Basic sound synthesis (kn5000-tvq)\n\n**Phase 3 - Input** (blocks interaction):\n- [ ] Control panel HLE complete (kn5000-qhm)\n- [ ] Encoder/wheel input (kn5000-3c7)\n- [ ] Button response (kn5000-j3c)\n\n**Phase 4 - Storage** (blocks file operations):\n- [ ] FDC emulation (kn5000-ima)\n- [ ] HDAE5000 emulation (kn5000-kuu)\n- [ ] Custom data persistence (kn5000-bqe)\n\n**Phase 5 - Polish**:\n- [ ] Full UI framework (kn5000-4bt)\n- [ ] Sequencer playback\n- [ ] Feature demo mode (kn5000-h7o)","status":"closed","priority":0,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:57:13.751200311-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:08:34.342314623-03:00","closed_at":"2026-01-31T00:08:34.342314623-03:00","close_reason":"Fulfilled: Created phase completion milestones (kn5000-dbi, kn5000-dnl, kn5000-9m6, kn5000-nca) and subsystem epics (kn5000-8z5, kn5000-y18, kn5000-1vz, kn5000-a0k)"}
{"id":"kn5000-9m6","title":"Phase 3 Completion: Full documentation coverage","notes":"Meta-issue tracking Phase 3 completion (Complete Documentation).\n\n## Phase 3 Goals\nAll subsystems fully documented in the documentation website.\n\n## Deliverables\n- kn5000-8ro: All placeholder pages completed\n- Audio details: SysEx format, CC handlers, voice allocation\n- Storage details: Custom Data Flash, HDAE5000 filesystem\n- Boot/Init: Complete timeline documentation\n\n## Documentation Pages to Complete\n1. audio-subsystem.md\n2. display-subsystem.md\n3. midi-subsystem.md\n4. ui-framework.md\n5. sequencer.md\n6. storage-subsystem.md (expand)\n\n## Depends On\n- Phase 2 completion (functional emulation enables testing)\n\n## Success Criteria\n- [ ] No placeholder pages remaining\n- [ ] All subsystem pages have code references\n- [ ] Symbol names in docs match assembly source\n- [ ] All P2/P3 documentation issues closed","status":"open","priority":2,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:08:05.492183189-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:08:05.492183189-03:00"}
{"id":"kn5000-9os","title":"Document binary include e0bb90_e0e974.bin data structure (~46KB)","notes":"Binary include at 0xE0BB90-0xE0E974 (~46KB). Medium-sized undocumented block. Check for table structure, code, or known data patterns.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:04.119269229-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:20.534138247-03:00"}
{"id":"kn5000-9w1z","title":"LLVM converter: Native remaining misc instructions (~2,000+ instructions)","description":"## Goal\nConvert remaining miscellaneous instruction types from .byte fallback to native LLVM.\n\n## Instruction forms and counts\n\n### SCC cc, reg — 218 instances\nSet register to 1 if condition true, 0 if false.\n- 3-byte: prefix + 0x70+cc  (prefix encodes register)\n- Example: scc nz, a\n\n### DJNZ reg, target — 129 instances\nDecrement and jump if not zero (loop instruction).\n- 3-byte: prefix + 0x1C + d8\n- Already supported as PrefixDJNZ format in MCCodeEmitter\n- Needs PC-relative target label resolution (like JR)\n\n### EI level — 301 instances\nEnable interrupts at specified level.\n- 2-byte: 0x06, level (0-7)\n- Already supported as SingleByteImm8 format\n\n### RETD imm16 — 68 instances\nReturn and deallocate stack frame.\n- 3-byte: 0x0F, d16_LE\n- Already supported as SingleByteImm8 format (special case for 0x0F)\n\n### RET / RETI — ~621 instances (some already native?)\n- RET: 1-byte (0x0E) — should be in Tier 1 NATIVE_ZERO_OPS\n- RETI: 1-byte (0x07) — should be in Tier 1\n- Check if these are actually already handled; if 549 remain as fallback, some forms may differ\n\n### EX F,F' — 31 instances\nExchange flag registers. 1-byte: 0x16.\n\n### MUL/MULS/DIV/DIVS — ~1,989 instances total\n- MULS WA,reg: 2-byte prefix + 0x08 (multiply signed)\n- MUL WA,reg: 2-byte prefix + 0x00 (multiply unsigned)  \n- DIVS WA,reg: 2-byte prefix + 0x09\n- DIV WA,reg: 2-byte prefix + 0x01\n- These may need new converter tiers since they're specialized reg-reg ops\n\n### LDIR/LDIRW — ~583 instances\nBlock transfer instructions (repeat).\n- LDIR: 2-byte (0x80, 0x10)\n- LDIRW: variant\n- Already supported as BlockTransfer format\n\n## LLVM backend status\nMost of these formats are already supported in the MCCodeEmitter:\n- PrefixDJNZ, SingleByteImm8, PrefixShift, BlockTransfer, SingleByte\n- Some may need new converter logic but no backend changes\n\n## Priority\nLower priority than LD/LDA/CP which have 10-50x more instances. Implement after the big categories.\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:27:22.520456416-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T07:33:49.947155961-03:00","closed_at":"2026-02-22T07:33:49.947155961-03:00","close_reason":"Closed","comments":[{"id":164,"issue_id":"kn5000-9w1z","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on misc instructions (PUSHW, EI, RETD, SCC, MUL/DIV, LDIR, EX).","created_at":"2026-02-22T10:11:35Z"},{"id":165,"issue_id":"kn5000-9w1z","author":"Felipe Correa da Silva Sanches","text":"Progress: Tiers 20-24 done. EI(301), RETD(68), MUL/DIV reg-reg(94), PUSHW imm(1851), RETcc(545) = 2,859 converted. LLVM backend extended with PUSHW_imm and RETcc instructions. Native: 174,121. 100% byte match.","created_at":"2026-02-22T10:28:25Z"},{"id":166,"issue_id":"kn5000-9w1z","author":"Felipe Correa da Silva Sanches","text":"Complete: Total 3,070 instructions converted (EI:301, RETD:68, MUL/DIV:94, PUSHW imm:1851, RETcc:545, SCC:211). Exceeds 2K+ target. LLVM backend extended with PUSHW_imm, RETcc, SCC8/SCC16, EX_FF, PrefixCondCode format. Remaining items (DJNZ/LDIR/MUL-imm/bank-regs) need separate tracking. Native: 174,332. RELEASED: Closing issue.","created_at":"2026-02-22T10:33:49Z"}]}
{"id":"kn5000-9ye","title":"Control Panel Protocol: Reverse engineer serial communication for HLE","description":"Reverse engineer the serial protocol between maincpu and control panel MCUs (LEDs, buttons, rotary encoders). The MCUs lack ROM dumps, so MAME emulation requires HLE based on protocol understanding. Analyze maincpu-side code to document all commands, responses, and state machines.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T03:10:07.603877099-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:19:41.367602474Z","closed_at":"2026-02-27T23:19:41.367602474Z","close_reason":"Complete. Serial protocol fully reverse-engineered: state machines, commands, button mapping, LED mapping, encoder format, data wheel mechanism, and HLE device all documented. Protocol doc is comprehensive MAME HLE implementation guide. Only remaining undisassembled routine is LABEL_FC4C34 (23 bytes, a helper).","dependencies":[{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-p2c","type":"blocks","created_at":"2026-01-25T03:11:08.309309518-03:00","created_by":"fsanches"},{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-j3c","type":"blocks","created_at":"2026-01-25T03:11:09.114300497-03:00","created_by":"fsanches"},{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-ljl","type":"blocks","created_at":"2026-01-25T03:11:09.85726164-03:00","created_by":"fsanches"},{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-unb","type":"blocks","created_at":"2026-01-25T03:11:10.576744795-03:00","created_by":"fsanches"},{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-32b","type":"blocks","created_at":"2026-01-25T03:11:11.391280017-03:00","created_by":"fsanches"},{"issue_id":"kn5000-9ye","depends_on_id":"kn5000-qhm","type":"blocks","created_at":"2026-01-25T03:11:12.152112102-03:00","created_by":"fsanches"}],"comments":[{"id":328,"issue_id":"kn5000-9ye","author":"Felipe Correa da Silva Sanches","text":"All 6 dependency tasks completed. The serial protocol is now comprehensively documented in control-panel-protocol.md:\n- State machines (10 SM states, all labeled)\n- All serial commands documented with parameters\n- Button state arrays fully mapped (22 segments)\n- LED row/pattern fully mapped (15 rows)\n- Encoder/analog controller format documented (absolute ADC values via Type 2 packets)\n- Data wheel mechanism identified (ROTA/ROTB quadrature → event 0x1C0001F)\n- HLE device designed and implemented (kn5000_cpanel.cpp on branch)\n- LED packet handlers fully disassembled (CPanel_LED_HandlePacket2, CPanel_LED_HandlePacketN)\n\nOnly remaining undisassembled routine: LABEL_FC4C34 (23 bytes) — a helper routine.\n\nThis issue can be closed: the protocol reverse engineering goal is achieved.","created_at":"2026-02-27T23:19:36Z"}]}
{"id":"kn5000-9zb","title":"Homebrew: Create SDK documentation and examples","notes":"Enable homebrew development for KN5000 hardware.\n\n**Current state:** Assembly knowledge accumulated, no SDK exists.\n\n**Required work:**\n- Create getting-started guide\n- Document essential APIs (display, audio, input)\n- Provide example programs\n- Document memory map for user code\n- Create build system templates\n\n**Phase:** 4 - Quality \u0026 Polish\n**Blocks:** Community homebrew development\n**Dependencies:** Complete subsystem documentation\n**Related:** All subsystem documentation issues","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:58:30.315603371-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:58:38.32018866-03:00"}
{"id":"kn5000-a0k","title":"MAME: Storage subsystem emulation milestone","notes":"Track completion of storage subsystem emulation for MAME.\n\n## Required Components\n- [ ] FDC emulation (floppy disk controller at 0x110000)\n- [ ] HDAE5000 expansion interface\n- [ ] Custom Data Flash at 0x300000\n- [ ] Table Data ROM access\n\n## Related Issues\n- kn5000-ima: FDC subsystem symbols\n- kn5000-kuu: HDAE5000 ROM disassembly\n- kn5000-bqe: Custom Data Flash organization\n- kn5000-44c: HDAE5000 filesystem\n\n## Success Criteria\n- Floppy disk loading works\n- Custom styles/songs can be saved/loaded\n- HDAE5000 (if present) is detected","status":"open","priority":2,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:22.982156427-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:22.982156427-03:00"}
{"id":"kn5000-a0mw","title":"LLVM converter: JR cc with local labels falls back (7 fallbacks)","description":"JR Z/NZ/C with local label targets (.wait_loop, .wdi_wait_remove, etc.) fall back because ADDR_TO_LABEL doesn't find the target. The qualified local labels may not be registered. All 7 in table_data.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.190726975-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:19:00.58456555-03:00","closed_at":"2026-02-23T08:19:00.58456555-03:00","close_reason":"Closed","comments":[{"id":237,"issue_id":"kn5000-a0mw","author":"Felipe Correa da Silva Sanches","text":"NOT A REAL FALLBACK: These JR cc instructions are written as raw 'db' bytes in the ASL source. They're intentional data directives preserved as .byte in the LLVM output. Converter correctly processes them as data. Closing as invalid.","created_at":"2026-02-23T11:19:00Z"}]}
{"id":"kn5000-a6uy","title":"LLVM converter: Split macro expansion .byte lines into individual instructions (~5,000 instructions)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T18:46:08.399667738-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:00:52.127888567-03:00","closed_at":"2026-02-22T19:00:52.127888567-03:00","close_reason":"Closed","comments":[{"id":202,"issue_id":"kn5000-a6uy","author":"Felipe Correa da Silva Sanches","text":"DESCRIPTION: ASL macros (RegObjTabl, RegTitle, _VGA_SEQUENCER, VGA_COLOR_CRTC, etc.) expand to 6-40 bytes of packed instructions emitted as a single .byte line. 1,035 commented lines (28,925 bytes, ~5,000 instructions). Fix: parse the packed bytes using instruction length info from the ASL listing, split into individual instructions, and convert each one. Related to kn5000-28dn — same root cause (multi-instruction byte sequences treated as atomic).","created_at":"2026-02-22T21:46:13Z"},{"id":208,"issue_id":"kn5000-a6uy","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on splitting macro expansions into individual instructions.","created_at":"2026-02-22T21:52:00Z"},{"id":209,"issue_id":"kn5000-a6uy","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Implemented macro expansion splitting with guess_mnemonics_from_opcode(). Also fixed Tier 19 syntax bug (elif→if). +7,099 native instructions, 26.9KB converted. 100% byte-match verified.","created_at":"2026-02-22T22:00:49Z"}]}
{"id":"kn5000-a8s","title":"Testing: Establish emulation validation procedures","notes":"Define testing procedures for validating MAME emulation accuracy.\n\n## Testing Categories\n\n### Boot Sequence Validation\n- ROM checksum verification\n- Peripheral init order matches real hardware\n- Sub CPU payload transfer timing\n\n### Display Validation\n- Boot splash appearance\n- UI element positioning\n- Font rendering accuracy\n- Color reproduction\n\n### Audio Validation\n- Basic tone generation\n- MIDI input response\n- Effects processing\n- Timing/latency\n\n### Input Validation\n- Button press response\n- Rotary encoder behavior\n- Analog controller range\n\n## Test Data Needed\n- Screenshots from real hardware\n- Audio recordings\n- Timing measurements\n- Logic analyzer captures\n\n## Success Criteria\n- Documented test procedures\n- Baseline captures from real hardware\n- Automated comparison where possible","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:30.995967273-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:30.995967273-03:00"}
{"id":"kn5000-aar","title":"Symbols: Create naming convention guide in CLAUDE.md","notes":"Document the naming conventions established during audio subsystem renaming:\n\nPrefixes used:\n- Audio_* - General audio subsystem routines\n- MIDI_* - MIDI message parsing/dispatch\n- Voice_* - Voice parameter manipulation\n- DSP_* / DSP2_* - DSP hardware control\n- RingBuf_* - Ring buffer operations\n- InterCPU_* - Inter-CPU communication\n- ToneGen_* - Tone generator (keyboard input)\n- HDAE5000_* - HDAE5000 expansion board\n- TableData_* - Table Data ROM operations\n- FDC_* - Floppy disk controller\n- UI_* / Widget_* - UI framework\n- Display_* - Display/video routines\n- CPanel_* - Control panel protocol\n- Encoder_* - Rotary encoder handling\n\nAdd to CLAUDE.md so future work maintains consistency.","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:04:12.461917724-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:04:12.461917724-03:00"}
{"id":"kn5000-acu","title":"Update: Document validation and error handling","description":"Trace update validation routines. Document: file header validation, checksum algorithms, version checking, ROM verification after write, error recovery procedures, what triggers 'Illegal Disk' message.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:49.832196678-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:34:49.832196678-03:00"}
{"id":"kn5000-ake","title":"Sound: Document MIDI implementation","description":"Fully document MIDI capabilities. Trace: MIDI IN/OUT/THRU handling, channel assignments, supported controllers (CC), SysEx commands, GM/GS/XG compatibility, MIDI clock sync, sequencer integration.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:44.907820841-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:04:40.823547269Z","closed_at":"2026-02-28T01:04:40.823547269Z","close_reason":"MIDI implementation documented in midi-subsystem.md and audio-subsystem.md: all MIDI status handlers, all standard CCs, all 6 proprietary CCs (0x91-0x9D) fully decoded, 26-channel architecture, ring buffer protocol, voice parameter structure. External MIDI I/O architecture diagram added. Remaining: SysEx format and Main CPU MIDI routing.","comments":[{"id":60,"issue_id":"kn5000-ake","author":"Felipe Correa da Silva Sanches","text":"Substantially addressed by audio subsystem reverse engineering:\n\n- Documented MIDI_Dispatch routine at 0x034D93\n- Documented status byte parsing (0x80-0xF0 ranges)\n- Documented all MIDI status handlers: NoteOn, CtrlChange, ProgChange, ChanPressure, PitchBend, System\n- Documented Voice parameter handlers: Voice_NoteOn, Voice_CtrlChange, etc.\n- Documented standard CC handlers (ModWheel, Volume, Pan, Expression, Sustain, etc.)\n- Identified proprietary CC handlers (0x91, 0x95, 0x97, 0x9B-0x9D)\n- All findings added to midi-subsystem.md\n\nRemaining: Document external MIDI I/O on Main CPU.","created_at":"2026-01-30T04:02:52Z"}]}
{"id":"kn5000-amhh","title":"LLVM converter: 2 remaining TMP94C241-specific LD (XIX+d8), imm8 fallbacks","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T04:50:21.341892976-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T05:03:36.804559861-03:00","closed_at":"2026-02-23T05:03:36.804559861-03:00","close_reason":"Closed","comments":[{"id":223,"issue_id":"kn5000-amhh","author":"Felipe Correa da Silva Sanches","text":"ROM addresses 0xF20DAD and 0xF20DCD. Encoding: 0xF1,0x5C,0x8F,{0xB8|0xB0}. The TMP94C241 supports an alternate encoding for LD (XIX+d8), imm8 using the 0xF1 extended prefix. LLVM's assembler produces the standard 0xBC prefix encoding (functionally identical, different bytes). Fixing requires adding a TMP94C241 alternate encoding mode to the LLVM backend — not justified for 2 instructions. Leave as .byte.","created_at":"2026-02-23T07:50:27Z"},{"id":226,"issue_id":"kn5000-amhh","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work. Will investigate the exact encoding to determine best approach.","created_at":"2026-02-23T07:54:05Z"},{"id":227,"issue_id":"kn5000-amhh","author":"Felipe Correa da Silva Sanches","text":"RESOLVED: The ASL comments were wrong — bytes 0xF1,0x5C,0x8F,0xB8/0xB0 are SET 0,(0x8F5C) and RES 0,(0x8F5C), not LD (XIX+5Ch),imm8. Extended convert_db() comment parser to handle ADDR: MNEMONIC format and opcode-based guessing. Both instructions now emit native setda/resda. 100% ROM byte match verified.","created_at":"2026-02-23T08:03:33Z"}]}
{"id":"kn5000-aq9","title":"LLVM converter: Native 8/16-bit register immediate loads (~11,834 instructions)","description":"## Goal\nConvert LD r8,#imm8 and LD r16,#imm16 from .byte fallback to native LLVM instructions.\n\n## Instruction forms\n\n### LD r8, #imm8 (2-byte: 0x20+r, imm8) — 5,533 instances\n- Opcode range: 0x20-0x27 (W=0, A=1, B=2, C=3, D=4, E=5, H=6, L=7)\n- Example: .byte 0x21, 0x00 → ld a, 0x0\n\n### LD r16, #imm16 (3-byte: 0x30+r, imm16_LE) — 6,301 instances  \n- Opcode range: 0x30-0x37 (WA=0, BC=1, DE=2, HL=3, IX=4, IY=5, IZ=6, SP=7)\n- Example: .byte 0x33, 0x00, 0x00 → ld hl, 0x0\n\n## LLVM backend status\n- LD r8,#imm8: Already supported as SingleByteImm8 format (opcode range in _SIMPLE_LENGTHS confirmed as 2 bytes)\n- LD r16,#imm16: Already supported as SingleByteRegImm format with 16-bit immediate\n- Both formats are already encodable by the MCCodeEmitter\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\n### Tier 11a: LD r8, #imm8\n- Check: nbytes == 2, 0x20 \u003c= rom_bytes[0] \u003c= 0x27, mnem_upper in ('LD',)\n- Register index: rom_bytes[0] - 0x20\n- Register names: {0:'w', 1:'a', 2:'b', 3:'c', 4:'d', 5:'e', 6:'h', 7:'l'}\n- Immediate: rom_bytes[1]\n- Emit: ld \u003cr8\u003e, 0x\u003cimm\u003e\n\n### Tier 11b: LD r16, #imm16\n- Check: nbytes == 3, 0x30 \u003c= rom_bytes[0] \u003c= 0x37, mnem_upper in ('LD', 'LDW')\n- Register index: rom_bytes[0] - 0x30\n- Register names: {0:'wa', 1:'bc', 2:'de', 3:'hl', 4:'ix', 5:'iy', 6:'iz', 7:'sp'}\n- Immediate: rom_bytes[1] | (rom_bytes[2] \u003c\u003c 8)\n- Emit: ld \u003cr16\u003e, 0x\u003cimm\u003e\n\n## Verification\n1. Regenerate: python scripts/asl_to_llvm.py maincpu/kn5000_v10_program.asm\n2. Build: make rebuilt_ROMs/kn5000_v10_program.llvm.rom\n3. Match: python scripts/compare_roms.py → 100.00%\n4. Spot-check: grep -cP '^\\s+ld [a-z]+, 0x' in output\n\n## Caution\n- The 2-byte LD check overlaps with Tier 3 (reg-reg). Place AFTER Tier 3 or verify rom_bytes[0] range.\n- Don't confuse with Tier 2 (5-byte LD r32,#imm32) — different byte count.\n- PUSH r16 (0x28-0x2F) and POP r16 (0x48-0x4F) are adjacent opcodes — handle separately.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:25:00.260280861-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T05:50:50.273063009-03:00","closed_at":"2026-02-22T05:50:50.273063009-03:00","close_reason":"Closed","comments":[{"id":151,"issue_id":"kn5000-aq9","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T08:31:48Z"},{"id":152,"issue_id":"kn5000-aq9","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Implemented 8,200 native LD r8/r16 immediate instructions across 3 encoding forms: ldb (1,891 short-form 8-bit), ldw (2,372 short-form 16-bit), lds (3,937 small-immediate 0-7). Added 3 new LLVM instructions (LD8ri_short, LD16ri_short, LD16ri_small) with PrefixSmallImm format. Also added prefix-form conversion (Tiers 13-14) which matched 0 instructions since firmware always uses shorter encodings. Fallback: 131K→96K. ROM 100% byte match.","created_at":"2026-02-22T08:50:46Z"}]}
{"id":"kn5000-ayt","title":"SubCPU: Identify sub CPU type and memory map","description":"Determine the sub CPU chip type (IC27 on main board). Document its memory map: where the 128KB boot ROM resides, where the 192KB payload is loaded, RAM areas, and any memory-mapped I/O for tone generator control. Check service manual schematics.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:35:38.633211293-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:03.866107425Z","closed_at":"2026-02-27T23:48:03.866107425Z","close_reason":"Already complete. Sub CPU identified as TMP94C241F (IC27) in cpu-subsystem.md. Memory map documented in boot-sequence.md: Boot ROM at 0xFE0000-0xFFFFFF (128KB), payload loaded to 0x0400-0x02FFFF (192KB), RAM at 0x0000-0x0FFF (4KB internal), I/O at 0x100000 (audio/DSP), 0x110000 (tone gen), 0x120000 (inter-CPU latch), 0x130000 (DSP control)."}
{"id":"kn5000-azj7","title":"LLVM converter: drifted Fmm medley labels (4 fallbacks)","description":"Four .byte fallbacks for JRL/CALR to Fmm medley function labels:\n- JRL T, FmmSmfMedleyFunc (lines 309196, 314038 as CALR)\n- JRL T, FmmPdMedleyFunc (line 309212)\n- CALR FmmDiskMedleySelectFunc (line 309220)\n\nThese labels exist in the LLVM output but at wrong addresses (drifted). The converter's address tracker accumulates errors before reaching these labels, so the computed branch offset doesn't match the ROM bytes.\n\nFix approach: trace the address tracking from the segment start to identify where the byte count goes wrong. Likely a mislabeled LABEL_XXXXXX (like the FE730F→FE7310 fix) or incorrect instruction size in get_instruction_size_from_rom().","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T01:07:10.010417818-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T09:41:19.767889782-03:00","closed_at":"2026-02-23T09:41:19.767889782-03:00","close_reason":"Closed","comments":[{"id":219,"issue_id":"kn5000-azj7","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on drifted Fmm medley label fallbacks.","created_at":"2026-02-23T04:17:11Z"},{"id":220,"issue_id":"kn5000-azj7","author":"Felipe Correa da Silva Sanches","text":"Progress: FmmDiskMedleySelectFunc was at the correct address — removed from DRIFTED_LABEL_NAMES (committed 88836dc). FmmSmfMedleyFunc and FmmPdMedleyFunc remain drifted by 425 and 2482 bytes respectively. The drift is caused by password_slot_routines.asm binclude ORG creating a segment boundary at F92C0E that cuts through medley.asm code. Converted forward-reference ORG+LABEL to EQU (committed 27e580a) which helps but doesn't fully fix the block buffer limit. Attempted ORIGINAL_ROM fallthrough for block overflow — abandoned due to double byte emission with padding segments. 3 fallbacks remain: JRL T FmmSmfMedleyFunc, JRL T FmmPdMedleyFunc, CALR FmmSmfMedleyFunc. RELEASED: blocked on fundamental block overflow design.","created_at":"2026-02-23T04:46:24Z"},{"id":240,"issue_id":"kn5000-azj7","author":"Felipe Correa da Silva Sanches","text":"All medley label fallbacks eliminated by Phase 2 improvements: comment operands extraction, macro name stripping, and proper label validation in convert_db(). Maincpu now at 0 fallbacks, 239,683 native instructions.","created_at":"2026-02-23T12:41:15Z"}]}
{"id":"kn5000-b0h","title":"Sub CPU: Complete emulation accuracy documentation","notes":"Document all requirements for accurate Sub CPU emulation.\n\n## Current Status\n- Sub CPU boot ROM: 100% disassembled\n- Sub CPU payload: 100% disassembled\n- Inter-CPU latch protocol: Documented\n\n## Missing Documentation\n- Exact timing requirements for latch communication\n- DMA transfer behavior\n- Interrupt priority and timing\n- Audio output synchronization\n\n## Related Issues\n- kn5000-51z: Boot sequence handshake\n- kn5000-1ru: Payload memory layout\n- kn5000-ayt: Sub CPU type identification\n\n## Hardware Details\n- Sub CPU: 65C02 variant at IC27\n- Boot ROM: 0xFE0000-0xFFFFFF\n- Payload loaded to: 0x000400\n- Communication via latch at 0x120000\n\n## Success Criteria\n- All timing-critical behaviors documented\n- MAME can boot Sub CPU with correct behavior\n- Audio output produces correct results","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:40.430604096-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:40.430604096-03:00","comments":[{"id":61,"issue_id":"kn5000-b0h","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Sub CPU emulation accuracy has improved. Sub CPU boot ROM and payload are both at 100% byte-match. Sound subsystem repo has completed a major semantic renaming campaign (100+ labels renamed across maincpu and subcpu). MAME Sub CPU payload transfer working (524K HDMA). Inter-CPU latch protocol documented. DSP ring buffer routines renamed with semantic names. Key gap: exact timing requirements for latch communication still undocumented.","created_at":"2026-02-21T04:02:18Z"}]}
{"id":"kn5000-b21","title":"SubCPU Boot: Fix remaining 1,981 byte divergences","description":"The subcpu_boot ROM is at 98.48% match with 1,981 divergent bytes remaining.\n\nProgress so far:\n- Started at 2,303 bytes (98.24%)\n- Created macros: JRL_T, LDIR_94, CALL_ABS24, LD_A, LD_D\n- Added routines: SUB_8437, SUB_850E, SUB_853A, COPY_WORDS, FILL_WORDS, CHECKSUM_CALC\n\nRemaining work:\n- ~850 bytes of DMA transfer routines at 0xFF8604-0xFF8955\n- Additional encoding fixes as discovered\n\nGoal: Achieve 100% byte match.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T20:45:58.105246938-03:00","created_by":"fsanches","updated_at":"2026-01-26T03:15:46.858695699-03:00","closed_at":"2026-01-26T03:15:46.858695699-03:00","close_reason":"Closed","comments":[{"id":62,"issue_id":"kn5000-b21","author":"fsanches","text":"COMPLETED - Sub CPU boot ROM now at 100% byte-perfect match!\n\nAll divergences fixed:\n- DMA Transfer Routines fully disassembled (539 bytes)\n- All instruction encodings verified against MAME unidasm\n- Comments reviewed and improved based on analysis findings\n\nNew macros added to tmp94c241.inc for TMP94C241 instructions.","created_at":"2026-01-26T06:15:55Z"}]}
{"id":"kn5000-baz","title":"Document binary include e0b250_e0ba60.bin data structure (~8KB)","notes":"Binary include at 0xE0B250-0xE0BA60 (~8KB). Relatively small block that may be easier to analyze. Check for table structure, code, or known data patterns.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:03.936101897-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:20.34906926-03:00"}
{"id":"kn5000-bcn","title":"Identify control panel MCU chip type from schematics","description":"The block diagram shows CPL and CPR boards have '8BIT MICROCOMPUTER' ICs. Analyze the detailed schematics (II-35, II-38) to identify the exact chip type. Look for part numbers, pin counts, and package markings. This is critical for understanding the serial protocol.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:08:39.513467217-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:40:34.631562603-03:00","closed_at":"2026-01-26T08:40:34.631562603-03:00","close_reason":"Closed","comments":[{"id":63,"issue_id":"kn5000-bcn","author":"fsanches","text":"REOPENING: Website documentation may be partial. Verify hardware-architecture.md has M37471M2196S MCU documented with part number, architecture (740 series), and pin assignments. If not, add this information.","created_at":"2026-01-26T11:33:12Z"},{"id":64,"issue_id":"kn5000-bcn","author":"fsanches","text":"Website already documented: hardware-architecture.md has 'Chip Identification' section showing M37471M2196S, 740 series architecture, 8-bit CMOS MCU. CPL/CPR boards both shown with same chip type.","created_at":"2026-01-26T11:40:34Z"}]}
{"id":"kn5000-bds","title":"FeatureDemo: Reverse engineer slide record format","description":"Document the binary format of each slide record. Identify fields: slide type, duration/timing, background image ID, widget list pointer, MIDI file pointer, transition effects. Create struct definition documenting each field offset and size.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:58:15.756574527-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:10:17.428877499Z","closed_at":"2026-02-28T01:10:17.428877499Z","close_reason":"Slide record format documented. Demo uses XML-driven presentation (not binary records). Bitmap resources are filename references; interactive objects are container handlers. File entry struct (24 bytes) documented in feature-demo.md.","comments":[{"id":361,"issue_id":"kn5000-bds","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Analyzing ftdemo01-48 UI object definitions in Program ROM. The 'slide records' are actually XML SHOW OBJ references to named objects defined in the main CPU firmware.","created_at":"2026-02-28T01:08:17Z"},{"id":362,"issue_id":"kn5000-bds","author":"Felipe Correa da Silva Sanches","text":"RELEASED: The 'slide records' are not binary structs — they are XML SHOW OBJ references to named resources. For bitmap resources (ftdemo01-48), the format is simple filename strings. For interactive objects (Accordion, Drawbar, Sdmixer), they are container objects with handler procedures. The actual record format is the FeatureDemo_FileEntry struct (24 bytes: filename + reserved + data_ptr + file_size). All documented in feature-demo.md.","created_at":"2026-02-28T01:10:17Z"}]}
{"id":"kn5000-bjw","title":"Docs: Explain 'Disables firmware display (SET bit 3 of SFR 0x0D53)'","notes":"The documentation mentions 'Disables firmware display (SET bit 3 of SFR 0x0D53)' but does not explain what this means, how it works, or why homebrew code needs it. Need to research the SFR register, trace firmware behavior, and add a clear explanation to the relevant docs.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:24.170586384-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T03:26:32.462904753-03:00","closed_at":"2026-02-21T03:26:32.462904753-03:00","close_reason":"Closed","comments":[{"id":65,"issue_id":"kn5000-bjw","author":"Felipe Correa da Silva Sanches","text":"NOTE (Feb 21): SFR 0x0D53 bit 3 has been confirmed through MAME development. Setting bit 3 disables the firmware's display update loop, allowing homebrew code to take exclusive ownership of VRAM at 0x1A0000. This is documented in display-subsystem.md. The explanation should be expanded in the homebrew guide (hdae5000-homebrew.md) with the specific mechanism: the firmware checks this bit in its main event loop and skips LCD rendering when set.","created_at":"2026-02-21T04:02:07Z"},{"id":66,"issue_id":"kn5000-bjw","author":"Felipe Correa da Silva Sanches","text":"COMPLETED (Feb 21): Expanded documentation in both display-subsystem.md and hdae5000-homebrew.md. Added: (1) All 4 firmware check locations (0xEF77DF, 0xEFAA40, 0xF59C11, 0xF59D65), (2) Display_ResetDirtyFlags / Display_UpdateDirtyRegions routines that are skipped, (3) Relationship to 0x0D65 display state byte, (4) Assembly and C code examples for setting/clearing the flag, (5) Practical guidance on when the flag is needed vs Frame_Handler timing, (6) Note that Mines does NOT use this flag. Committed to kn5000-docs.","created_at":"2026-02-21T06:26:29Z"}]}
{"id":"kn5000-bq4","title":"Boot: Document control panel initialization","description":"Trace initialization of control panel serial communication. Document: when serial channel to CPL/CPR MCUs is configured, initial command sequence sent to panels, LED initialization pattern, how main CPU confirms panel MCUs are responding.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:44:54.701312324-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:47.958617065Z","closed_at":"2026-02-27T23:48:47.958617065Z","close_reason":"Already complete. Control panel initialization documented in boot-sequence.md (lines 1093-1103) and comprehensively in control-panel-protocol.md. Covers: CPanel_InitHardware serial setup (250kHz), init command sequence (HWRESET 0x1F/0xDA, CONFIGURE 0x1F/0x1A, INIT_LEFT 0x1D, INIT_BOTH 0xDD, FINAL 0x1E/0x80), LED initialization, panel detection via PING commands, 42-iteration polling loop."}
{"id":"kn5000-bqe","title":"Storage: Document Custom Data Flash organization at 0x300000","notes":"Custom Data Flash (1MB @ 0x300000) stores user settings and sequences.\n\nCurrent state: Address known, internal layout unknown.\n\nRequired work:\n- Identify file/record structure\n- Document user settings storage format\n- Map custom sound/style save locations\n- Document sequence storage format\n\nPriority: Medium - needed for save/restore functionality\nPhase: 3 - Complete Documentation\nDependencies: Sequencer format (for sequence storage)\nRelated: Storage subsystem documentation","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:57:06.249904965-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:57:06.249904965-03:00"}
{"id":"kn5000-bquc","title":"LLVM: Remaining memory prefix sub-opcodes (80-BF) — ~427 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:21:00.631434921-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T16:52:40.662708067-03:00","closed_at":"2026-02-22T16:52:40.662708067-03:00","close_reason":"Closed","comments":[{"id":186,"issue_id":"kn5000-bquc","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on remaining memory prefix sub-opcodes.","created_at":"2026-02-22T19:21:14Z"},{"id":187,"issue_id":"kn5000-bquc","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Memory prefix sub-opcodes analysis complete. 234/431 are d8=0 (covered by kn5000-lb20). 157 are sub=0x19 (LD mem-to-mem, would need new LLVM format). Remaining 40 are misc rare sub-opcodes. These are already assembling correctly via ExtPrefixInst.","created_at":"2026-02-22T19:52:34Z"}]}
{"id":"kn5000-br1","title":"FeatureDemo: Create ASL macros for widget definitions","description":"Implement widget-specific macros: TEXT x,y,font,color,\"string\" / IMAGE x,y,id / RECT x,y,w,h,color / LINE x1,y1,x2,y2,color / BUTTON x,y,w,h,label. Ensure macros handle alignment and padding correctly.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:20.395561988-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:11:23.976707513Z","closed_at":"2026-02-28T01:11:23.976707513Z","close_reason":"Superseded: Feature Demo widgets are bitmap filename references and container object handler procedures, not structured binary records. No binary widget format exists to create ASL macros for."}
{"id":"kn5000-c3p","title":"SubCPU: Trace payload transfer initialization","description":"Find and document the main CPU code that initializes the sub CPU payload transfer. Identify: source address (payload location in main ROM), destination address (sub CPU memory), transfer size (192KB), DMA mode settings, and any handshaking with sub CPU before/during/after transfer.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:35:37.547233434-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:36:11.396763368-03:00","closed_at":"2026-01-26T08:36:11.396763368-03:00","close_reason":"Closed","comments":[{"id":67,"issue_id":"kn5000-c3p","author":"fsanches","text":"Findings from Sub CPU boot ROM analysis:\n\n**Payload reception (Sub CPU side):**\n- Boot ROM waits in MAIN_LOOP for bit 6 of SUBCPU_STATUS_FLAGS (0x04FE)\n- E3 command (0xE3) sets this bit, signaling payload is ready\n- When ready, EI 6 enables interrupt level 6\n- Then calls PAYLOAD_ENTRY at 0x0400\n\n**Pre-payload handshake:**\n- INTERCPU_STATUS (0x34) bit 0 = sub CPU ready\n- INTERCPU_STATUS (0x34) bit 4 = main CPU ready (polled by sub CPU)\n- DMA_SYNC_FLAG (0x0516) tracks transfer state\n\n**DMA transfer commands:**\n- E1: Multi-stage DMA (6 bytes to CMD_E1_BUFFER at 0x0544)\n- E2: Payload DMA (10 bytes to CMD_E2_BUFFER at 0x054A)\n- Variable-length: Up to 32 bytes to CMD_DATA_BUFFER at 0x051E\n\n**Transfer state machine (CMD_PROCESSING_STATE at 0x0518):**\n- State 1: Process received data, dispatch to handler\n- State 2: Secondary DMA using CMD_E1_BUFFER parameters\n- State 3: Set completion flags (bit 7 of 0x0554)\n- State 4: Clear ready flag, return to idle\n\n**To complete this task:** Need to find main CPU code that sends these commands and trace payload source address in main ROM.","created_at":"2026-01-26T10:36:34Z"},{"id":68,"issue_id":"kn5000-c3p","author":"fsanches","text":"**Summary of Payload Transfer Protocol:**\n\n**Sub CPU Boot ROM receives payload via:**\n1. Main CPU sends E2 command with 10-byte parameter block containing:\n   - Source address (main CPU memory)\n   - Destination address (sub CPU memory) \n   - Transfer count\n2. Sub CPU DMA controller transfers data in chunks\n3. Main CPU sends E3 command when all data sent\n4. Sub CPU detects E3, sets status flag, jumps to PAYLOAD_ENTRY (0x0400)\n\n**Payload Size:** 192KB (kn5000_subprogram_v142.rom)\n\n**Destination:** Sub CPU RAM, executed from 0x0400 onwards\n\n**Main CPU side:** Not yet traced in firmware. The routine likely:\n- Loads payload from ROM (probably in 0xE00000+ area)\n- Sends E2 commands iteratively for 192KB\n- Sends E3 to signal completion\n\n**Note:** Sub CPU side fully documented. Main CPU sender routine location unknown but protocol behavior understood.\n\nStatus: Protocol documented. Main CPU routine location remains open question but doesn't block understanding.","created_at":"2026-01-26T11:20:53Z"},{"id":69,"issue_id":"kn5000-c3p","author":"fsanches","text":"REOPENING: Need to verify website documentation was updated with payload transfer findings. Check reverse-engineering.md 'Sub CPU Payload Loading' section for documented DMA routines (0xFF8604-0xFF8955), E1/E2/E3 command details, and transfer sequence.","created_at":"2026-01-26T11:32:30Z"},{"id":70,"issue_id":"kn5000-c3p","author":"fsanches","text":"Website updated: reverse-engineering.md 'MicroDMA Mechanism' section includes DMA transfer routines table (DMA_SEND_CHUNKED, DMA_SEND_BLOCK, etc.) with addresses and sizes. Boot sequence section documents payload transfer flow.","created_at":"2026-01-26T11:36:11Z"}]}
{"id":"kn5000-c47b","title":"HDAE5000 FS: Map RAM data structures used by filesystem","description":"Create a comprehensive map of all RAM addresses used by the HDAE5000 filesystem code. Known so far: 0x22AA9C (filesystem buffer base, 20 entries), 0x22B430 (sector data table, 20KB), 0x230884 (directory entry table, 40 x 9-byte entries), 0x230E72 (entry count), 0x229D99-0x229DAE (CHS params + state flags from ATA IDENTIFY), 0x23A1A2 (dispatch pointer), 0x2304E0-0x2304EE (file save state). Document each field's purpose, size, and which routines read/write it.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:30:15.867399231Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T23:43:38.605480012Z","closed_at":"2026-02-27T23:43:38.605480012Z","close_reason":"Comprehensive RAM data structure map added to hdae5000-filesystem.md: 80+ addresses documented across 10 functional groups (ATA params, CHS UI, FSB buffers, sector allocation, file operation state, filenames, audio settings, directory entries, UI framework, vtable offsets). Cross-referenced with routines that read/write each address.","comments":[{"id":334,"issue_id":"kn5000-c47b","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on RAM data structure mapping.","created_at":"2026-02-27T23:39:13Z"}]}
{"id":"kn5000-c5gn","title":"HDAE5000 FS: Annotate sector allocation and VarInt encoding","description":"Document the sector allocation scheme used by the HDAE5000 filesystem. The Calc_Disk_Space routine (0x28E48B) and VarInt_Encode/Decode routines (0x28F36B/0x28F3BD) are already disassembled. Add detailed comments explaining: (1) How the sector table at 0x22B430 (20KB) is organized, (2) The 7-bit VarInt encoding format (bit 7 = continuation), (3) How free space is calculated, (4) The max sector limit of 20,457, (5) How File_Format uses this for partition formatting.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:30:07.04498436Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T23:36:36.538890677Z","closed_at":"2026-02-27T23:36:36.538890677Z","close_reason":"Annotated VarInt_Encode, VarInt_Decode, Calc_Disk_Space, File_Format, Read_Table_Word, Read_Table_Multi with comprehensive field-level comments. Documented sector table layout (0x22B430, +22 descriptor offset), MIDI-style VarInt format, error codes, and max 20,457 sector limit.","comments":[{"id":332,"issue_id":"kn5000-c5gn","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting annotation of VarInt encoding and sector allocation.","created_at":"2026-02-27T23:29:26Z"}]}
{"id":"kn5000-c7ug","title":"LLVM: Replace ld_sril3/srib3/sriw3 with semantic register+displacement mnemonics","description":"The ld_sril3, ld_srib3, ld_sriw3 family of instructions use opaque raw-byte notation like 'ld_sril3 xwa, 0xE1, 0x88, 0x0E' which hides the actual operation 'ld xwa, (xwa + 0x0E88)'. These are register-indirect loads with 16-bit displacement (d16 addressing mode). The LLVM backend must support proper mnemonics like 'ld xwa, (xwa + 0x0E88)' for all register bases and operand sizes. 354 instances in HDAE5000 assembly alone. This is the highest-impact improvement for readability.","status":"closed","priority":1,"issue_type":"feature","owner":"juca@members.fsf.org","created_at":"2026-02-26T02:25:48.856204712Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T10:29:26.211501158Z","closed_at":"2026-02-27T10:29:26.211501158Z","close_reason":"2,859 of ~2,893 instances converted. 34 register-offset mode instances remain (different addressing sub-mode, not d16).","comments":[{"id":306,"issue_id":"kn5000-c7ug","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on replacing ld_sril3/srib3/sriw3 with semantic register+displacement mnemonics.","created_at":"2026-02-27T10:12:38Z"},{"id":307,"issue_id":"kn5000-c7ug","author":"Felipe Correa da Silva Sanches","text":"Completed: 2,859 ld_sril3/sriw3/srib3 → ld_sril/sriw/srib (d16 mode, across all 6 ROMs). 34 register-offset mode instances remain as raw bytes. LLVM SriD16Reg format added (InstFormat 61). RELEASED: Moving to next issue.","created_at":"2026-02-27T10:29:24Z"}]}
{"id":"kn5000-c9c","title":"Document binary include e02510_e06baf.bin data structure (~295KB)","notes":"Large binary include at 0xE02510-0xE06BAF (~295KB). This is one of the largest undocumented blocks in the ROM. Need to analyze structure: could be sound data, lookup tables, compressed assets, or code.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:03.592665786-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:19.991066325-03:00"}
{"id":"kn5000-car","title":"LLVM: Document recent backend improvements (LDIR/LDDR, peepholes, frame pointer)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T01:01:14.35198559-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T03:28:08.618163697-03:00","closed_at":"2026-02-21T03:28:08.618163697-03:00","close_reason":"Closed","comments":[{"id":71,"issue_id":"kn5000-car","author":"Felipe Correa da Silva Sanches","text":"LLVM TLCS-900 backend has had 10 unpushed commits with significant new features: (1) LDIR block transfer ISel for memcpy, (2) LDDR block transfer ISel for memmove with runtime direction check, (3) BIT test peephole: AND+CP+JPcc -\u003e BIT+JPcc, (4) SET/RES/CHG peephole for power-of-2 ops, (5) Frame pointer support using XIZ register, (6) 8-bit register encoding fix (sub-register HWEncoding), (7) ELF object file round-trip test, (8) Assembler support for 8-bit/16-bit memory load/store, (9) Four disassembler bug fixes. These should be documented in the LLVM project's docs or CLAUDE.md.","created_at":"2026-02-21T04:01:23Z"},{"id":72,"issue_id":"kn5000-car","author":"Felipe Correa da Silva Sanches","text":"COMPLETED (Feb 21): Added 'Recent Backend Improvements (Feb 2026)' section to LLVM CLAUDE.md documenting: (1) New features: LDIR/LDDR ISel for memcpy/memmove, BIT test peephole (AND+CP+JPcc→BIT+JPcc), SET/RES/CHG peephole for power-of-2 ops, frame pointer support using XIZ, 8/16-bit assembler load/store support. (2) Bug fixes: 8-bit register HWEncoding, INC/DEC I3 field, 4 disassembler fixes. (3) Testing: ELF round-trip, asm/disasm round-trip, rewritten disassembler test. (4) Known active bugs #10 and #11 with workarounds. Committed to LLVM repo.","created_at":"2026-02-21T06:28:03Z"}]}
{"id":"kn5000-cav","title":"Boot: Document memory initialization sequence","description":"Trace RAM initialization: DRAM refresh setup (IC9/IC10), SRAM initialization (IC21), memory mapping configuration. Document any memory tests performed at boot and how the memory controller registers are configured.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:44:52.913226814-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:35:06.97768021-03:00","closed_at":"2026-01-26T08:35:06.97768021-03:00","close_reason":"Closed","comments":[{"id":73,"issue_id":"kn5000-cav","author":"fsanches","text":"Sub CPU memory controller initialization (from boot ROM):\n\n**Memory Controller Block Configuration:**\n\nBlock 0-5 Start Addresses (MSAR):\n- MSAR0 (0x143) = 0x10\n- MSAR1 (0x144) = 0x11\n- MSAR2 (0x145) = 0xFF\n- MSAR3 (0x146) = 0x00\n- MSAR4 (0x147) = 0x12\n- MSAR5 (0x148) = 0x13\n\nAddress Masks (MAMR):\n- MAMR0 (0x142) = 0x07\n- MAMR1 (0x146) = 0x03\n- MAMR2 (0x14A) = 0x01\n- MAMR3 (0x14E) = 0x1F or 0x0F (depends on P8_DATA bit 0)\n- MAMR4 (0x152) = 0x01\n- MAMR5 (0x156) = 0x01\n\nBlock Control Low (wait states):\n- B0CSL (0x140) = 0x66\n- B1CSL (0x144) = 0x66\n- B2CSL (0x148) = 0x22\n- B3CSL (0x14C) = 0x22\n- B4CSL (0x150) = 0x66\n- B5CSL (0x154) = 0x66\n\nBlock Control High (bus width, mode):\n- B0CSH (0x141) = 0x81\n- B1CSH (0x145) = 0x81\n- B2CSH (0x149) = 0xC0\n- B3CSH (0x14D) = 0x8A or 0x89 (depends on P8_DATA bit 0)\n- B4CSH (0x151) = 0x80\n- B5CSH (0x155) = 0x81\n\n**DRAM Controller:**\n- DRAM_TIMING1 (0x165) = 0x71\n- DRAM_REFRESH (0x162) = 0x8B\n- DRAM_CTRL (0x163) = 0x58\n- DRAM_TIMING2 (0x166) bit 4 cleared\n\n**Memory Test (INIT_MEMORY_TEST at 0xFF8956):**\n- Tests RAM with patterns 0x5A5A5A5A and 0xA5A5A5A5\n- Uses config table at 0xFF8020 (10 bytes per region)\n- Stores result flags in MEMTEST_RESULT (0x0556)\n- Performs ROM checksum verification (ROM_CHECKSUM at 0xFF8AB4)","created_at":"2026-01-26T06:36:11Z"},{"id":74,"issue_id":"kn5000-cav","author":"fsanches","text":"**Main CPU Memory Initialization (RESET_HANDLER at 0xEF03C6):**\n\n**Memory Segment Configuration (MSAR/MAMR):**\n```\nMSAR0 = 0x1E, MAMR0 = 0x0F  ; Segment 0: start 0x1E0000, mask 0x0F (64KB?)\nMSAR1 = 0x10, MAMR1 = 0x3F  ; Segment 1: start 0x100000, mask 0x3F (256KB?)\nMSAR2 = 0xC0, MAMR2 = 0x7F  ; Segment 2: start 0xC00000, mask 0x7F (512KB?)\nMSAR3 = 0x00, MAMR3 = 0x1F  ; Segment 3: start 0x000000, mask 0x1F (128KB?)\nMSAR4 = 0x80, MAMR4 = 0xFF  ; Segment 4: start 0x800000, mask 0xFF (Table Data ROM)\nMSAR5 = 0x00, MAMR5 = 0xFF  ; Segment 5: start 0x000000, mask 0xFF (1MB?)\n```\n\n**DRAM Initialization Sequence (at 0xEF04A1):**\n1. Short delay loop (BC = 0x400 iterations)\n2. DRAM1REF = 0x81 (initial refresh config)\n3. Longer delay loop (BC = 0x2000 iterations)\n4. DRAM1REF = 0x71 (final refresh config)\n5. DRAM1CRL = 0x8B (DRAM control low)\n6. DRAM1CRH = 0x58 (DRAM control high)\n7. PMEMCR bit 4 cleared\n\n**Bus Chip Select Configuration:**\n```\nB0CSL = 0x11, B0CSH = 0x80\nB1CSL = 0x33, B1CSH = 0x81\nB2CSL = 0x11, B2CSH = 0xC2\nB3CSL = 0x22, B3CSH = 0x8A\nB4CSL = 0x11, B4CSH = 0x82\nB5CSL = 0x22, B5CSH = 0x81\n```\n\n**Self-Test (called from 0xEF0529):**\n- MainCPU_self_test_routines performs RAM test\n- Tests likely include pattern writes (0x5A5A/0xA5A5)\n\nBoth Main CPU and Sub CPU follow similar patterns:\n1. Configure memory segment registers\n2. Initialize DRAM controller with delays\n3. Set bus timing/width per segment\n4. Run memory tests\n\nStatus: Issue can be considered documented - both CPUs covered.","created_at":"2026-01-26T10:47:22Z"},{"id":75,"issue_id":"kn5000-cav","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Memory Initialization' section (lines ~517-528) with actual findings. Replace 'Tasks:' with documented MSAR/MAMR values, DRAM init sequence (0xEF04A1), BxCS bus configuration, memory test patterns. Add main CPU memory map details to memory-map.md.","created_at":"2026-01-26T11:32:17Z"},{"id":76,"issue_id":"kn5000-cav","author":"fsanches","text":"Website updated: reverse-engineering.md 'Memory Initialization' section now documents MSAR/MAMR segment table, DRAM init sequence (0xEF04A1-0xEF04BC), bus chip select configuration, and memory test patterns.","created_at":"2026-01-26T11:35:06Z"}]}
{"id":"kn5000-cfe","title":"subcpu: Get payload build working","description":"The subcpu payload ROM (kn5000_subprogram_v142.rebuilt.rom) is not being generated. The Makefile target exists but the build is failing or incomplete. Need to diagnose and fix so we can track subcpu match percentage.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-25T02:48:44.457038448-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:20:06.910407097-03:00","closed_at":"2026-01-25T05:20:06.910411889-03:00"}
{"id":"kn5000-cox","title":"Sound: Extract and catalog all instrument patches","description":"Extract instrument definitions from ROM. Document: patch names, sample mappings, envelope settings, filter settings, effects assignments. Create patch list matching front panel sound groups.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-25T04:50:46.739889691-03:00","created_by":"fsanches","updated_at":"2026-01-25T04:50:46.739889691-03:00"}
{"id":"kn5000-cpx9","title":"LLVM: Post-increment/pre-decrement addressing (C4/C5/D4/D5/E4/E5/F4/F5) — ~581 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:20:59.249550938-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T17:11:31.009329445-03:00","closed_at":"2026-02-22T17:11:31.009329445-03:00","close_reason":"Closed","comments":[{"id":191,"issue_id":"kn5000-cpx9","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on post-increment/pre-decrement addressing.","created_at":"2026-02-22T20:06:59Z"},{"id":192,"issue_id":"kn5000-cpx9","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Converted 183 of 192 SPI/SPD instructions using 21 ExtAddrModeSuffixInst definitions. Remaining 9 have trailing operand bytes or undefined sub-opcodes. 100% byte-match verified.","created_at":"2026-02-22T20:11:30Z"}]}
{"id":"kn5000-cw5c","title":"LLVM converter: Semantic direct-addressing instructions (C0-F5 prefix) (~150 instructions)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T18:46:28.088983843-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:17:10.501884644-03:00","closed_at":"2026-02-22T19:17:10.501884644-03:00","close_reason":"Closed","comments":[{"id":204,"issue_id":"kn5000-cw5c","author":"Felipe Correa da Silva Sanches","text":"DESCRIPTION: ~150 instructions using C0-F5 direct-addressing prefix are currently ExtAddrMode (instruction boundaries correct but not fully semantic). Includes C1 (8-bit src), E9 (XHL+d8 word), EF (XSP+d8 long), F1/F2 (dst direct), F5 (dst post-inc). Fix: add converter tiers or LLVM instruction definitions for direct-addressing ALU/LD/CP with absolute addresses. Low priority — readability improvement only, no functional impact.","created_at":"2026-02-22T21:46:34Z"},{"id":213,"issue_id":"kn5000-cw5c","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting analysis of remaining direct-addressing instruction fallbacks.","created_at":"2026-02-22T22:11:53Z"},{"id":214,"issue_id":"kn5000-cw5c","author":"Felipe Correa da Silva Sanches","text":"Analysis complete. The ~150 direct-addressing instructions (C0-F5 prefix) are actually already handled by the existing ExtAddrMode format — they have correct instruction boundaries and byte encoding. Making them 'more semantic' (using register names instead of prefix bytes) would require new LLVM instruction definitions. Low impact, closing as won't-fix for now.","created_at":"2026-02-22T22:17:10Z"}]}
{"id":"kn5000-d1x","title":"Table Data: Document ROM internal structure and indexing","notes":"Table Data ROM (2MB @ 0x800000) internal organization needs reverse engineering.\n\n**Current state:** 32.42% disassembled, mostly binary assets. Structure unknown.\n\n**Required work:**\n- Identify index tables for sound/style/demo data\n- Document header formats for embedded assets\n- Map data type regions within the ROM\n- Create tools to extract and catalog assets\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** Full Table Data ROM disassembly, asset loading in emulator\n**Dependencies:** None\n**Related:** kn5000-hlw (improve match %), kn5000-16s (find images)","status":"open","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:56:59.448880992-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:57:28.131228115-03:00","comments":[{"id":77,"issue_id":"kn5000-d1x","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Table data ROM now at 100% byte-match (was 32.42%). All binary asset regions, bootloader code, and index structures are correctly reconstructed in the assembly source. The internal structure is now implicitly documented through the disassembly layout. Remaining: explicit documentation of index table formats, asset header formats, and data type regions for developer reference.","created_at":"2026-02-21T04:00:34Z"}]}
{"id":"kn5000-d38","title":"Sound: Document Waveform ROM (IC306-307)","description":"Analyze the waveform ROM chips. Document: total size, data format, sample encoding (PCM bits, compression), how samples are indexed, instrument mapping. These contain the raw sound samples for synthesis.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:50:30.606958657-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:03:01.683813227Z","closed_at":"2026-02-28T01:03:01.683813227Z","close_reason":"Documented hardware facts (4x32Mbit, IC inventory, CPU interface). Sample format is opaque to CPU firmware — IC303 accesses waveform ROMs directly. Further progress requires hardware analysis (ROM dumping/decapping).","comments":[{"id":357,"issue_id":"kn5000-d38","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting analysis of waveform ROM addressing. IC304-IC307 are 4×32Mbit waveform ROMs accessed by the tone generator IC303, not directly by the CPU. Will trace firmware code that configures waveform ROM access patterns.","created_at":"2026-02-28T01:00:49Z"},{"id":358,"issue_id":"kn5000-d38","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Analysis complete. Key finding: waveform ROMs (IC304-IC307, 4×32Mbit = 16MB total) are accessed directly by the tone generator IC303 hardware — the CPU never reads waveform data. The CPU only configures which samples to play via tone generator register writes at 0x100000/0x100002. Program Change (0xC0) handler at Voice_ProgChange (0x037864) maps MIDI program numbers to voice register values, but the register-to-waveform-address translation happens inside IC303's internal logic. Sample format (PCM depth, compression, addressing) cannot be determined from firmware analysis — requires hardware probing or ROM dumping. Hardware facts documented: 4×32Mbit ROMs + 2×4Mbit DRAM (IC308-IC309) for DSP work RAM.","created_at":"2026-02-28T01:03:01Z"}]}
{"id":"kn5000-dbi","title":"Phase 1 Completion: All MAME blockers resolved","notes":"Meta-issue tracking Phase 1 completion (Foundation - MAME Blockers).\n\n## Phase 1 Goals\nGet basic MAME emulator running with display and sound output.\n\n## Component Milestones\n- kn5000-8z5: Display subsystem emulation\n- kn5000-y18: Audio subsystem emulation\n- kn5000-5a0: Fix 177 divergent bytes\n- kn5000-d1x: Table Data ROM structure\n\n## Blockers to Resolve\n1. **Display** - Need pixel format, palette, framebuffer layout\n2. **Audio** - Need DSP effects, Sub CPU command protocol\n3. **ROM** - 177 bytes at 0xFDDE5F need instruction audit\n\n## Success Criteria\n- [ ] MAME boots to splash screen\n- [ ] Basic audio output works\n- [ ] Main CPU ROM at 100%\n- [ ] All P1 display issues closed\n- [ ] All P1 audio issues closed\n\n## Timeline Estimate\nPhase 1 represents the critical path to functional emulation.","status":"open","priority":0,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:52.70916765-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:52.70916765-03:00","comments":[{"id":78,"issue_id":"kn5000-dbi","author":"Felipe Correa da Silva Sanches","text":"PROGRESS UPDATE (Feb 20): Significant progress on Phase 1. Display: framebuffer layout, pixel format, and palette now fully understood (kn5000-3c5, kn5000-hy8 effectively resolved). MAME renders HDAE5000 homebrew content correctly. Audio: sine wave tone gen working, Sub CPU payload transfer working. ROM: Main CPU still at 99.99% (177 bytes). Remaining blockers: full VGA register map, DSP effects, waveform ROM playback, 177 divergent bytes.","created_at":"2026-02-21T03:33:24Z"},{"id":79,"issue_id":"kn5000-dbi","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Phase 1 nearing completion. Updated success criteria: [x] Main CPU ROM at 100% — DONE (kn5000-5a0 closed). [x] MAME boots to splash screen — DONE (firmware boots, LCD renders). [~] Basic audio output works — PARTIAL (sine wave tone gen working, needs waveform ROM playback). [x] Framebuffer layout documented (kn5000-3c5 closed). [x] Pixel format documented (kn5000-hy8 closed). [ ] Full VGA register map (kn5000-ezo still open). [ ] DSP effects (kn5000-1oy still open). Remaining Phase 1 blockers: VGA register completion, DSP/waveform audio, drawing primitives.","created_at":"2026-02-21T04:00:20Z"}]}
{"id":"kn5000-de13","title":"LLVM converter: JRL T falls back to .byte (1 fallback)","description":"JRL T, Boot_Init+014Bh (opcode 0x78 + d16) falls back because mnem_upper is 'JRL_T' not 'JRL'. Or label arithmetic (Boot_Init+014Bh) isn't resolved. 1 instance in table_data.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.904431767-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:18:51.013484469-03:00","closed_at":"2026-02-23T08:18:51.013484469-03:00","close_reason":"Closed","comments":[{"id":234,"issue_id":"kn5000-de13","author":"Felipe Correa da Silva Sanches","text":"FIXED: Tier 9 now accepts JRL_T and other cc-suffixed mnemonics (mnem_upper.startswith('JRL_')). Also handles single-operand form (no comma) and converts ASL hex notation via convert_expression().","created_at":"2026-02-23T11:18:50Z"}]}
{"id":"kn5000-dj3","title":"Video: Extract and document all fonts","description":"Extract font data from ROMs as usable assets. Convert to standard format (BDF, TTF, or PNG atlas). Document character coverage, sizes, styles. Add font samples to image gallery on website.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:46:05.46532404-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:45:37.148049923Z","closed_at":"2026-02-28T00:45:37.148049923Z","close_reason":"All 10 fonts extracted as BDF and PNG. Variable-width kerning table format reverse engineered. Font catalog added to website.","comments":[{"id":347,"issue_id":"kn5000-dj3","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on font extraction and documentation.","created_at":"2026-02-28T00:30:35Z"},{"id":348,"issue_id":"kn5000-dj3","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Completed. Extracted all 10 firmware fonts:\n- Font 0-1, 7-8: 8x16 fixed-width (standard/bold variants)\n- Font 2: 16x16 fixed-width (wide/bold)\n- Font 3: 6x8 fixed-width (small)\n- Font 4, 9: 11x16 fixed-width (medium-wide)\n- Font 5: variable-width proportional (3-10px, kerning table at 0x94C620)\n- Font 6: 8x10 fixed-width (compact)\n\nDiscovered kerning table format: 4-byte entries {word width, word glyph_offset}.\nEach font has 224 characters (ASCII 0x20-0xFF).\nExported as BDF files and PNG atlas images.\nScript: scripts/extract_fonts.py","created_at":"2026-02-28T00:45:32Z"}]}
{"id":"kn5000-dkx","title":"Update: Reverse engineer Flash erase algorithm","description":"Trace the Flash ROM erase routine in firmware. Document: chip unlock sequence, sector erase commands, chip erase commands, erase verification, timeout handling. Note any chip-specific variations. Cross-reference with Flash datasheet.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:43.704720594-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:17:37.766375381Z","closed_at":"2026-02-28T01:17:37.766375381Z","close_reason":"Already documented in flash-programming.md: AMD/Atmel flash protocol, 6-byte chip erase sequence, Flash_ChipErase_16bit (0x9FB968), Flash_ChipErase_32bit (0x9FBD17), unlock sequences, device ID validation (AM29F040/F400B/F800B/LV800B)."}
{"id":"kn5000-dnl","title":"Phase 2 Completion: Core functionality working","notes":"Meta-issue tracking Phase 2 completion (Core Functionality).\n\n## Phase 2 Goals\nUser interaction and file I/O fully working in MAME.\n\n## Component Milestones\n- kn5000-1vz: Input/Control subsystem emulation\n- kn5000-a0k: Storage subsystem emulation\n\n## Key Deliverables\n1. **UI/Input** - Font system, widget rendering, control panel HLE\n2. **Storage** - FDC working, HDAE5000 detected, custom data accessible\n\n## Depends On\n- Phase 1 completion (kn5000-dbi)\n\n## Success Criteria\n- [ ] UI navigation works via keyboard/mouse\n- [ ] Floppy disk loading functional\n- [ ] Custom styles can be loaded/saved\n- [ ] All P2 UI/input issues closed\n- [ ] All P2 storage issues closed","status":"open","priority":1,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:08:00.678620003-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:08:00.678620003-03:00"}
{"id":"kn5000-dnsp","title":"Mines: Game exit and cleanup (QUIT button, remove auto-activate, clean debug markers)","description":"Game is fully functional (display, input, game logic). Remaining cleanup: (1) QUIT button should cleanly return display ownership to firmware, (2) Remove auto-activate in Boot_Init for interactive builds, (3) Remove diagnostic debug markers from startup.s and main.c. Low priority since game works correctly as-is.","status":"closed","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-24T03:44:43.772843291-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-24T05:55:33.918604836-03:00","closed_at":"2026-02-24T05:55:33.918604836-03:00","close_reason":"Closed","comments":[{"id":291,"issue_id":"kn5000-dnsp","author":"Felipe Correa da Silva Sanches","text":"PROGRESS: (1) Added clean return of display ownership to firmware on exit by clearing bit 3 of 0x0D53. (2) Removed auto-activate in Boot_Init for interactive builds. Remaining: remove diagnostic debug markers.","created_at":"2026-02-24T08:42:24Z"}]}
{"id":"kn5000-dqi","title":"FeatureDemo: Document widget parameter formats","description":"For each widget type, document all parameters: position (x,y), size (w,h), colors, font ID, text string pointer, image ID, alignment, padding, border style, animation params. Create comprehensive widget parameter reference.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:18.08871888-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:11:23.651611979Z","closed_at":"2026-02-28T01:11:23.651611979Z","close_reason":"Superseded: Feature Demo uses bitmap resource name references (ftdemo01-48 are simple strings), not structured widget records with position/size/color parameters. Interactive objects (Accordion, Drawbar, Sdmixer) have parameters embedded deep in handler procedure code, not in structured data tables."}
{"id":"kn5000-du3c","title":"LLVM migration: Phase 4 scaffolding removal (deferred)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T09:41:48.085995647-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:13:51.748447155-03:00","closed_at":"2026-02-23T11:13:51.748447155-03:00","close_reason":"Closed","comments":[{"id":242,"issue_id":"kn5000-du3c","author":"Felipe Correa da Silva Sanches","text":"The converter's block buffer scaffolding (BLOCK_BUFFER, BLOCK_CURSOR, self-correction, drifted labels, prescan) handles 25K+ address corrections in maincpu alone. This cannot be removed until the LLVM backend encodes every instruction identically to the original ROM. Currently ~200-350 lines of scaffolding code. See the migration plan in proud-skipping-llama.md for details.","created_at":"2026-02-23T12:41:54Z"},{"id":243,"issue_id":"kn5000-du3c","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting investigation of block correction patterns to determine feasibility of scaffolding removal.","created_at":"2026-02-23T13:16:01Z"},{"id":244,"issue_id":"kn5000-du3c","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Completed. Block buffer scaffolding fully removed (-334 lines). Key findings: (1) Only 2 actual drifts existed (maincpu 68 bytes, subcpu 8 bytes), rest were zero-gap transitions. (2) Maincpu drift fixed by filtering backward-jumping labels in prescan. (3) Subcpu drift was caused by the block mechanism itself (data overflow), fixed by removing the mechanism. All 6 ROMs 100% byte-identical. Subcpu gained +1 native instruction, maincpu gained 15,110 symbolic .long replacements.","created_at":"2026-02-23T14:13:47Z"}]}
{"id":"kn5000-dui","title":"SubCPU: Analyze inter-CPU latch protocol at 0x120000","description":"Document the latch-based communication mechanism at 0x120000. Determine: latch register layout (command, status, data bytes), handshaking signals, how main CPU signals 'payload ready', how sub CPU acknowledges receipt, and any checksumming or verification.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:35:37.903037668-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:36:10.02422211-03:00","closed_at":"2026-01-26T08:36:10.02422211-03:00","close_reason":"Closed","comments":[{"id":80,"issue_id":"kn5000-dui","author":"fsanches","text":"Significant findings from DMA routine analysis:\n\nINTER_CPU_LATCH (0x120000):\n- Single byte command/data register\n- Commands sent by sub CPU: E1, E2, E3, and variable-length (high 3 bits = handler, low 5 bits = count-1)\n\nINTERCPU_STATUS (0x34 in sub CPU SFR):\n- Bit 0: Sub CPU ready flag (set when ready, cleared when starting transfer)\n- Bit 1: Completion signal from interrupt handler\n- Bit 2: Gate for command processing in INT_HANDLER_9\n- Bit 4: Main CPU ready flag (polled by sub CPU)\n\nProtocol flow:\n1. Sub CPU polls bit 4 until main CPU ready\n2. Sub CPU clears bit 0, sends command to 0x120000\n3. Sub CPU polls bit 4 for acknowledgment\n4. Sub CPU sets bit 0, initiates DMA transfer\n5. DMA_SYNC_FLAG tracks transfer phase (0=idle, 1=single, 2=multi-stage)\n6. INT_HANDLER_37 decrements sync flag on DMA completion\n\nCommands discovered:\n- E1: Multi-stage DMA (two-phase transfer with 200-cycle delays)\n- E2: Payload transfer (10-byte parameter block)\n- E3: Payload ready signal (sets bit 6 of SUBCPU_STATUS_FLAGS)","created_at":"2026-01-26T06:16:13Z"},{"id":81,"issue_id":"kn5000-dui","author":"fsanches","text":"**Complete Protocol Summary:**\n\n**Latch Address:** 0x120000 (shared between main and sub CPU)\n\n**Command Encoding:**\n| Byte Range | Format | Description |\n|------------|--------|-------------|\n| 0x00-0x1F | `HHHLLLLL` | Handler (bits 7-5) + data length-1 (bits 4-0) |\n| 0xE1 | Fixed | Multi-stage DMA, 6-byte param block |\n| 0xE2 | Fixed | Payload transfer, 10-byte param block |\n| 0xE3 | Fixed | Payload ready signal |\n\n**Handshaking Register (0x34):**\n```\nBit 0: SUB_READY - Sub CPU ready to receive\nBit 1: COMPLETION - Transfer complete signal\nBit 2: GATE - Processing gate for INT_HANDLER_9\nBit 4: MAIN_READY - Main CPU ready (polled by sub)\n```\n\n**Transfer Sequence (Sub CPU → Main CPU):**\n1. Poll MAIN_READY (bit 4) until set\n2. Clear SUB_READY (bit 0)\n3. Write command byte to 0x120000\n4. Poll MAIN_READY for acknowledgment\n5. Set SUB_READY, initiate DMA\n6. Wait for COMPLETION (bit 1) via interrupt\n\n**Status Flags (0x04FE in sub CPU RAM):**\n- Bit 6: Payload data ready\n- Bit 7: Transfer complete\n\n**No checksumming** observed in protocol - relies on handshaking for reliability.\n\nStatus: Protocol fully documented. Close.","created_at":"2026-01-26T11:20:31Z"},{"id":82,"issue_id":"kn5000-dui","author":"fsanches","text":"REOPENING: Website documentation partially complete (reverse-engineering.md has protocol details) but memory-map.md needs Inter-CPU Communication section updated with INTERCPU_STATUS (0x34) bit definitions and DMA state machine details. Also verify reverse-engineering.md section matches findings.","created_at":"2026-01-26T11:32:29Z"},{"id":83,"issue_id":"kn5000-dui","author":"fsanches","text":"Website updated: reverse-engineering.md 'Inter-CPU Communication' section now documents command encoding table, INTERCPU_STATUS register bits at SFR 0x34, transfer sequence, and status flags at 0x04FE. Replaced 'Tasks:' with protocol specification.","created_at":"2026-01-26T11:36:09Z"}]}
{"id":"kn5000-e7f","title":"Update: Document HDAE5000 update procedure","description":"Analyze how HD-AE5000 firmware is updated. Document: separate update disk format, communication via PPI (0x160000), Flash chips on expansion board, version compatibility checks. Reference v1.10i through v2.0i updates.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T05:34:51.401684113-03:00","created_by":"fsanches","updated_at":"2026-01-25T05:34:51.401684113-03:00"}
{"id":"kn5000-e8qs","title":"Decode remaining 199 x_ extended addressing mode instructions to proper TLCS-900 mnemonics","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T15:51:22.546626731-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T17:15:39.211180147-03:00","closed_at":"2026-02-23T17:15:39.211180147-03:00","close_reason":"Closed","comments":[{"id":261,"issue_id":"kn5000-e8qs","author":"Felipe Correa da Silva Sanches","text":"Context: Per-register consolidation (kn5000-h1fe) converted 12,514 instructions (82%) to register-operand form. The remaining 2,784 x_ instructions (18%) across 199 ExtAddrMode defs are diverse TLCS-900 operations — NOT per-register variants.\n\nThese need a sub-opcode decoding table mapping each sub-opcode byte to its TLCS-900 mnemonic. Operations include:\n- ALU with immediates (ADD/SUB/AND/OR/CP (mem), #imm)\n- Shift/rotate (RLC/RRC/RL/RR/SLA/SRA/SLL/SRL)\n- Bit operations (RES/SET/CHG/BIT/TSET)\n- Block transfer (LDI/LDIR/LDD/LDDR/CPI/CPIR/CPD/CPDR)\n- Flag operations (ANDCF/ORCF/XORCF/LDCF/STCF)\n- Exchange (EX), PUSH/POP, DJNZ, etc.\n\nFamilies: DD82 (30 defs), SRIW4 (27), SRIB4 (21), DRI4 (17), DD163 (14), SRIL4 (13), ERPW2/ERPB2 (12), and smaller families.\n\nApproach: Build a lookup table from the TLCS-900/H2 datasheet, create native instruction definitions for each operation type, write transform scripts for .s files.","created_at":"2026-02-23T18:51:33Z"},{"id":262,"issue_id":"kn5000-e8qs","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on sub-opcode decoding.","created_at":"2026-02-23T18:52:08Z"},{"id":263,"issue_id":"kn5000-e8qs","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All 2,681 x_ instructions eliminated across 3 rounds:\nRound 1 (SRI ALU): 236 transforms, 56→24 LLVM defs\nRound 2 (Destination table): 1,433 transforms, 70→26 LLVM defs  \nRound 3 (ERP/SRI-src/SD8/SD16/SD24/SPI): 1,115 transforms, 72→76 LLVM defs\nTotal: 2,784→0 x_ instructions. Net LLVM: 198 old defs removed, 126 new consolidated defs added. All 6 ROMs 100% byte-match, 49/49 lit tests pass. RELEASED.","created_at":"2026-02-23T20:15:36Z"}]}
{"id":"kn5000-ezo","title":"Display: Document VGA register set for MN89304 controller","notes":"The MN89304 VGA controller at 0x170000 needs complete register documentation.\n\n**Current state:** Hardware location known, but register meanings undocumented.\n\n**Required work:**\n- Identify VGA register port addresses (standard VGA at 0x3C0-0x3DF?)\n- Document initialization sequence from boot code\n- Map control registers for resolution, timing, color depth\n- Document any non-standard extensions\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** Display rendering in MAME emulator\n**Dependencies:** None\n**Related:** kn5000-hy8 (color palette), kn5000-gln (drawing primitives)","status":"open","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:56:52.860635654-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:57:24.770917953-03:00","comments":[{"id":84,"issue_id":"kn5000-ezo","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 20): Key VGA registers documented from Mines homebrew development. DAC write index at 0x1703C8, DAC data at 0x1703C9, CRTC index/data at 0x1703D4/0x1703D5. MN89304 uses 4-bit RAMDAC (not standard 6-bit). SFR 0x0D53 bit 3 controls display enable/disable. Still need: full register map, initialization sequence from boot code, timing registers.","created_at":"2026-02-21T03:32:55Z"},{"id":85,"issue_id":"kn5000-ezo","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Additional VGA registers confirmed through MAME development: MN89304 at 0x170000 uses standard VGA register offsets. CRTC index/data at 0x1703D4/0x1703D5. Attribute controller. SFR 0x0D53 bit 3 controls display ownership (firmware vs homebrew). 4-bit RAMDAC confirmed (not standard 6-bit). Still needed: complete register map from boot initialization sequence, timing registers, any non-standard MN89304 extensions.","created_at":"2026-02-21T04:00:48Z"}]}
{"id":"kn5000-f6d8","title":"LLVM converter: Data formatting improvements (.ascii, .long, .short)","description":"Improve readability of the ~90,000 data .byte lines by emitting higher-level directives where appropriate: .ascii for ASCII string data, .long for aligned 32-bit values, .short for aligned 16-bit values, .zero for zero-fill regions. This is a cosmetic/readability improvement — it doesn't change the binary output. Requires detecting data regions (consecutive .byte without instruction context) and pattern-matching for strings, aligned values, and zero runs.","status":"closed","priority":3,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:09:06.124709785-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:50:00.851902066-03:00","closed_at":"2026-02-23T11:50:00.851902066-03:00","close_reason":"Closed","comments":[{"id":252,"issue_id":"kn5000-f6d8","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on data formatting improvements.","created_at":"2026-02-23T14:34:26Z"},{"id":253,"issue_id":"kn5000-f6d8","author":"Felipe Correa da Silva Sanches","text":"Completed .zero/.fill data formatting: 6,288 directives across all ROMs. Also fixed binclude path resolution bug (binary includes not found when ASL sources in archive/asl/). All 6 ROMs 100% byte-identical, 0 fallbacks. The .ascii/.asciz detection was already implemented. .short/.long grouping for raw data would add complexity for minimal readability gain — not pursuing.","created_at":"2026-02-23T14:49:51Z"},{"id":254,"issue_id":"kn5000-f6d8","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Work completed.","created_at":"2026-02-23T14:49:57Z"}]}
{"id":"kn5000-fjwn","title":"LLVM: Replace memory-immediate instruction mnemonics (cpmi8, ldmi8, ldmw, cpmi16) with standard syntax","description":"Instructions like cpmi8, cpmi16, ldmi8, ldmw use invented mnemonics for standard memory-immediate operations. They should use standard TLCS-900 syntax: 'cp (xsp+29), 0x08' instead of 'cpmi8 (xsp+29), 0x08', 'ld (xsp+4), 0x0001' instead of 'ldmw (xsp+4), 0x0001'. Note: these overlap with existing 'cp' and 'ld' mnemonics for register operands, so the assembler needs to disambiguate by operand type. Affected: ldmi8 (48), ldmw (40), cpmi8 (25), cpmi16 (10). Total ~123 instances.","status":"closed","priority":1,"issue_type":"feature","owner":"juca@members.fsf.org","created_at":"2026-02-26T02:25:58.742606834Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T10:41:53.501903378Z","closed_at":"2026-02-27T10:41:53.501903378Z","close_reason":"Memory-immediate mnemonics replaced with standard forms.","comments":[{"id":310,"issue_id":"kn5000-fjwn","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on memory-immediate mnemonic replacements.","created_at":"2026-02-27T10:38:09Z"},{"id":311,"issue_id":"kn5000-fjwn","author":"Felipe Correa da Silva Sanches","text":"Completed: 5,582 renames across all ROMs. cpmi8→cp, cpmi16→cpw, ldmi8→ld, ldmw→ldw. ldmi16 kept (different encoding from ldmw, 81 uses). RELEASED.","created_at":"2026-02-27T10:41:53Z"}]}
{"id":"kn5000-fmq","title":"SubCPU: Document MicroDMA registers on TMP94C241F","description":"Document the MicroDMA controller registers on the TMP94C241F. Include DMAS (source), DMAD (destination), DMAC (count), DMAM (mode) registers. Reference TMP94C241F datasheet for register addresses and bit definitions. Identify which DMA channel is used for sub CPU payload transfer.","notes":"Additional macros created for DMA register access:\n\nNew macros in tmp94c241.inc:\n- LDIR_94: Block copy with TMP94C241 encoding (83 11 vs ASL's 85 11)\n- JRL_T: Relative long jump (78 LL HH)\n- CALL_ABS24: Absolute call with 24-bit address (1d LL MM HH)\n\nBoot ROM uses DMA channels 0 and 2:\n- Channel 0: Inter-CPU latch source (DMAS0, DMAC0)\n- Channel 2: Inter-CPU latch destination (DMAS2, DMAD2, DMAC2)\n\nDMA transfer routines at 0xFF8604-0xFF8955 use these extensively.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:35:37.176013536-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:36:08.732016639-03:00","closed_at":"2026-01-26T08:36:08.732016639-03:00","close_reason":"Closed","comments":[{"id":86,"issue_id":"kn5000-fmq","author":"fsanches","text":"Additional macros created during DMA routine disassembly:\n\nDMA Register Access:\n- LDC_DMAS2_XDE, LDC_DMAS2_XWA, LDC_DMAS2_XBC, LDC_DMAS2_XHL: Set DMA source\n- LDC_DMAD2_XWA, LDC_DMAD0_XWA, LDC_DMAD0_XBC: Set DMA destination  \n- LDC_DMAC2_BC, LDC_DMAC2_WA, LDC_DMAC2_A: Set DMA count\n- LDC_DMAC0_WA, LDC_DMAC0_A: Set DMA count channel 0\n\nDMA Control:\n- DMA_MODE_REG (0x0102): Mode configuration, set to 0x16 for transfers\n- T01MOD bit 2: Start DMA transfer when set\n\nDMA routines fully disassembled:\n1. DMA_SEND_CHUNKED: 69 bytes - sends data in 32-byte chunks\n2. DMA_SEND_BLOCK: 99 bytes - single block transfer with handshaking\n3. SEND_E3_CMD: 48 bytes - payload ready signal\n4. WAIT_DMA_THEN_E2: 112 bytes - wait then send E2 command\n5. DMA_MULTI_STAGE: 211 bytes - two-phase transfer with E1 command","created_at":"2026-01-26T06:16:31Z"},{"id":87,"issue_id":"kn5000-fmq","author":"fsanches","text":"**TMP94C241F MicroDMA Register Map (from datasheet):**\n\nThe TMP94C241F has 4 DMA channels (0-3). Each channel has these registers:\n\n| Register | Ch0 Addr | Ch1 Addr | Ch2 Addr | Ch3 Addr | Description |\n|----------|----------|----------|----------|----------|-------------|\n| DMASn | 0x100 | 0x110 | 0x120 | 0x130 | Source Address (24-bit) |\n| DMADn | 0x104 | 0x114 | 0x124 | 0x134 | Destination Address (24-bit) |\n| DMACn | 0x108 | 0x118 | 0x128 | 0x138 | Transfer Count (16-bit) |\n| DMAMn | 0x10C | 0x11C | 0x12C | 0x13C | Mode Register |\n\n**LDC Instruction Encoding for DMA Registers:**\nThe DMA registers are accessed via special LDC (Load Control) instructions:\n```\nLDC DMAS0, XWA  →  e8 2e 00  (load source ch0 from XWA)\nLDC DMAD0, XWA  →  e8 2e 20  (load dest ch0 from XWA)\nLDC DMAC0, WA   →  d8 2e 40  (load count ch0 from WA)\nLDC DMAS2, XDE  →  ea 2e 08  (load source ch2 from XDE)\nLDC DMAD2, XWA  →  e8 2e 28  (load dest ch2 from XWA)\nLDC DMAC2, BC   →  d9 2e 48  (load count ch2 from BC)\n```\n\n**DMA Mode Register Bits (DMAMn):**\n```\nBits 7-6: Transfer mode (00=burst, 01=cycle-steal, 10=single)\nBits 5-4: Source addressing (00=fixed, 01=inc, 10=dec)\nBits 3-2: Dest addressing (00=fixed, 01=inc, 10=dec)  \nBits 1-0: Data size (00=byte, 01=word, 10=long)\n```\n\n**Sub CPU Boot ROM Usage:**\n- Channel 0: Latch reads (source=0x120000 fixed, dest=RAM incrementing)\n- Channel 2: Payload transfers (configurable source/dest)\n- DMA_MODE_REG (0x102) = 0x16: Enables DMA, sets trigger mode\n- Trigger: Write 0x0A to 0x0100, or set T01MOD bit 2\n\nStatus: Register map documented. Consider closing.","created_at":"2026-01-26T11:19:15Z"},{"id":88,"issue_id":"kn5000-fmq","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'MicroDMA Mechanism' section (lines ~66-78) with actual register addresses (0x100-0x13C), LDC instruction encodings, DMA channel usage (0 and 2), and mode register bits. Memory-map.md should include DMA register addresses.","created_at":"2026-01-26T11:32:18Z"},{"id":89,"issue_id":"kn5000-fmq","author":"fsanches","text":"Website updated: reverse-engineering.md 'MicroDMA Mechanism' section now documents all register addresses (0x100-0x13C), LDC instruction encodings with hex bytes, third-byte selector table, mode register bits, and DMA transfer routines table. Replaced 'Tasks:' with detailed technical documentation.","created_at":"2026-01-26T11:36:08Z"}]}
{"id":"kn5000-gaha","title":"Mines: Display ownership — firmware overwrites game VRAM","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-24T02:49:57.550926089-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-24T03:40:34.97317966-03:00","closed_at":"2026-02-24T03:40:34.97317966-03:00","close_reason":"Closed","comments":[{"id":279,"issue_id":"kn5000-gaha","author":"Felipe Correa da Silva Sanches","text":"The Mines game loop runs correctly (6781 gameplay_update frames in 30s), but the firmware's own display routine overwrites VRAM between Frame_Handler calls, making the game invisible on screen. Need to: (1) Find firmware mechanism to suppress display updates when game is active, OR (2) Take over VGA control (reprogram display timing/framebuffer), OR (3) Use firmware drawing primitives instead of direct VRAM writes. The original HDAE5000 used the firmware's UI framework, so option (1) is most likely — there should be a flag or callback that suppresses the firmware's normal rendering.","created_at":"2026-02-24T05:50:04Z"},{"id":282,"issue_id":"kn5000-gaha","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Investigating display ownership mechanism.","created_at":"2026-02-24T05:51:07Z"},{"id":283,"issue_id":"kn5000-gaha","author":"Felipe Correa da Silva Sanches","text":"RESOLVED: Per-frame redraw approach works. Firmware rendering runs BEFORE our Frame_Handler in the main loop, so we redraw everything (palette + VRAM clear + minefield borders + cells) right before yielding. Game content is the last thing written to VRAM each frame. Performance: ~22 FPS at 99% MAME speed. Future optimization: investigate why firmware rendering path isn't gated by 0xD53 bit 3 (was always 0 during testing), or find the actual rendering suppression mechanism to avoid redundant work.","created_at":"2026-02-24T06:40:31Z"}]}
{"id":"kn5000-gels","title":"LLVM: Replace 24-bit address instruction mnemonics with readable forms","description":"Instructions like ldada_24, ldda32_24, ldda8_24, stda32_24, stda8_24, stdi8_24, cpdi8_24, adddm32_24, subda32_24 use encoded naming that obscures their meaning. They should use natural assembly syntax like 'ld xwa, (0x23A1A2)' or 'ld (0x160006), a' instead of 'ldda32_24 xwa, 2335138' or 'stda8_24 1441798, a'. Affected: ldada_24 (228 uses), ldda32_24 (215), stda8_24 (20), stdi8_24 (19), stda32_24 (17), cpdi8_24 (11), ldda8_24 (10), subda32_24 (1), adddm32_24 (1). Total ~522 instances.","status":"closed","priority":1,"issue_type":"feature","owner":"juca@members.fsf.org","created_at":"2026-02-26T02:25:54.416948202Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T10:37:59.932453753Z","closed_at":"2026-02-27T10:37:59.932453753Z","close_reason":"All 24-bit address mnemonics renamed to shorter forms, all decimal addresses converted to hex.","comments":[{"id":308,"issue_id":"kn5000-gels","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on replacing 24-bit address mnemonics.","created_at":"2026-02-27T10:29:31Z"},{"id":309,"issue_id":"kn5000-gels","author":"Felipe Correa da Silva Sanches","text":"Completed: 6,715 decimal→hex address conversions + 7,959 mnemonic renames across all 6 ROMs. New shorter mnemonics: ld32_24, ld16_24, ld8_24, lda_24, st32_24, st16_24, st8_24, sti8_24, sti16_24, cpi8_24, addm32_24, sub32_24. RELEASED.","created_at":"2026-02-27T10:37:58Z"}]}
{"id":"kn5000-gkhu","title":"HDAE5000 FS: Disassemble FS_Init (3,711 bytes at 0x2870D6)","description":"Disassemble the HDAE5000_FS_Init routine (3,711 bytes, currently .incbin blob). This is the filesystem initialization function — likely reveals the on-disk layout of FSB/FGB/FEB structures since it reads and parses master metadata from disk. Highest priority for understanding the custom filesystem format. Located at code_2803c2_28f542.bin offset 27924.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:29:51.526779993Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T05:35:18.152026794Z","closed_at":"2026-02-27T05:35:18.152026794Z","close_reason":"FS_Init fully disassembled (3711 bytes, 1154 instructions). Using .byte with labels for guaranteed byte-match. 100% verified on all 6 ROMs.","comments":[{"id":301,"issue_id":"kn5000-gkhu","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting disassembly of FS_Init.","created_at":"2026-02-26T12:30:31Z"}]}
{"id":"kn5000-gkqf","title":"Complete TLCS-900 MCDisassembler coverage","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T18:22:22.069590641-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T18:22:32.608751351-03:00","closed_at":"2026-02-23T18:22:32.608751351-03:00","close_reason":"Closed","comments":[{"id":265,"issue_id":"kn5000-gkqf","author":"Felipe Correa da Silva Sanches","text":"Phases 1-4 complete: unified 8/16/32-bit register prefix decoder, all single-byte instructions, expanded memory prefix (multi-size, IsDstMem), direct addressing (C1-E2/F1-F2). Coverage expanded from ~40% to ~85%. Remaining: extended addressing stubs (SRI C3/D3/E3/F3, PI C4/D4/E4/F4, SPD C5/D5/E5/F5, ERP C7/D7/E7) and 8-bit direct I/O (C0/D0/E0/F0). 50/50 tests passing.","created_at":"2026-02-23T21:22:28Z"}]}
{"id":"kn5000-gln","title":"Video: Reverse engineer drawing primitives","description":"Find and document graphics drawing routines in firmware: pixel plotting, line drawing, rectangle fill, bitmap blitting (BLT), text rendering. Document function addresses, parameters, and any hardware acceleration used.","notes":"Drawing primitives are needed for UI rendering.\n\n**Current state:** VRAM_FillRect identified at 0xEF50DF, other routines unknown.\n\n**Required work:**\n- Trace graphics API entry points\n- Document line, rect, fill, blit operations\n- Map sprite/bitmap rendering\n- Document clipping and coordinate systems\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** UI rendering in emulator\n**Dependencies:** Framebuffer documentation (kn5000-3c5)\n**Related:** kn5000-5dc (widget rendering), kn5000-kev (fonts)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:46:02.368724528-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:59:40.645546546Z","closed_at":"2026-02-27T23:59:40.645546546Z","close_reason":"All drawing primitives identified, annotated in assembly, and documented on website.","comments":[{"id":337,"issue_id":"kn5000-gln","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on reverse engineering video drawing primitives.","created_at":"2026-02-27T23:51:27Z"},{"id":338,"issue_id":"kn5000-gln","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Identified and documented all video drawing primitives:\n- Memory: Copy_DE_words (0xEF18D7), Fill_memory (0xEF18E0)\n- Pixel: ReadPixel (0xFAA7B4), ModifyPixel (0xFAA7E4), ModifyPixelEx (0xFAA84A) with 5 drawing modes\n- Rect: VRAM_FillRect (0xEF50DF), DrawWall (0xFABB74)\n- Line: DrawLine (0xFAA98A), DrawLineEx (0xFAAA3E) - Bresenham algorithm\n- Bitmap: DrawBitmap (0xFABC3A), DrawBitmapFast (0xFABE0E) - table at 0x913000 (8B/entry)\n- Text: DrawString (0xFACACE) + Centered/Left/Right/Reverse variants - font table at 0x945C00 (16B/entry)\n- Helpers: SetChangeRect (0xFAA760), MovePixels (0xFABA60), Set_XWA_to_320_times_XDE (0xEF5023)\nAdded header annotations to all routines in assembly. Updated display-subsystem.md with comprehensive drawing primitives section.\nRELEASED: Work complete.","created_at":"2026-02-27T23:59:37Z"}]}
{"id":"kn5000-gqu","title":"Document binary include e06f30_e0adcf.bin data structure (~254KB)","notes":"Large binary include at 0xE06F30-0xE0ADCF (~254KB). Need to analyze structure: could be sound data, lookup tables, compressed assets, or code.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:03.77745035-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:20.168925279-03:00"}
{"id":"kn5000-gwsz","title":"LLVM converter: Add RLD, RRD, RETI, INCF/DECF sub-opcodes (~300 .byte)","description":"Add instruction definitions and converter tiers for remaining rare single-byte opcodes: RLD/RRD rotate digit (0x10-0x15, ~130 groups), RETI return from interrupt (0x1F, ~90 groups), INCF/DECF increment/decrement flag register (0x07, ~80 groups). These are low-frequency instructions that need both LLVM backend instruction definitions and converter tier matching.","status":"closed","priority":3,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:09:02.470974637-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:18:02.386635679-03:00","closed_at":"2026-02-22T19:18:02.386635679-03:00","close_reason":"Closed","comments":[{"id":216,"issue_id":"kn5000-gwsz","author":"Felipe Correa da Silva Sanches","text":"Investigation shows only 11 remaining single-byte instruction fallbacks (7 RETI, 3 INCF, 1 DECF). Most are already handled by existing tiers. The ~300 estimate was inaccurate — likely included data bytes. RLD/RRD would need new LLVM instruction definitions for very few instructions. Closing as low-impact.","created_at":"2026-02-22T22:18:02Z"}]}
{"id":"kn5000-h1fe","title":"Replace extended addressing mode wrappers with native LLVM instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T14:26:23.773183146-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T15:51:18.075525359-03:00","closed_at":"2026-02-23T15:51:18.075525359-03:00","close_reason":"Closed","comments":[{"id":258,"issue_id":"kn5000-h1fe","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work — replacing ExtAddrModeSuffix/OpImm/ExtPrefix wrappers with native LLVM instructions using typed operands. Plan has 7 phases.","created_at":"2026-02-23T17:26:28Z"},{"id":259,"issue_id":"kn5000-h1fe","author":"Felipe Correa da Silva Sanches","text":"Phase 4 complete: SRI/DRI consolidated (48+72 per-register → 6+4 native defs, 6,922 .s transforms). DPI also consolidated (21 x_dpi2 defs → 4 native, 327 .s transforms). Fixed ERPReg encoder for dest prefixes (\u003e=0xF0). Remaining: 199 ExtAddrMode defs (diverse ops: ALU+imm, bit ops, shifts — NOT per-register patterns), ~2,803 x_ usages in .s files. Per-register consolidation essentially complete.","created_at":"2026-02-23T18:47:48Z"},{"id":260,"issue_id":"kn5000-h1fe","author":"Felipe Correa da Silva Sanches","text":"Per-register consolidation complete. Summary:\n\nConsolidated (register-operand form): 12,514 instructions (82%)\n- ERP (bank register): 5,047 uses across ~40 native defs\n- SRI (source reg-indirect): 3,818 uses across 6 native defs  \n- DRI (dest reg-indirect): 3,104 uses across 4 native defs\n- SPI/SPD (post-inc/pre-dec): 218 uses across 11 native defs\n- DPI (dest post-inc): 327 uses across 4 native defs\n\nRemaining opaque (x_ prefixed): 2,784 instructions (18%)\n- 199 ExtAddrMode defs covering diverse operations (ALU+imm, shifts, bit ops, block transfer)\n- These are NOT per-register variants — each x_ def is a different TLCS-900 operation\n- Decoding requires building a full sub-opcode → operation mapping table\n\nAlso fixed ERPReg encoder to handle destination prefixes (\u003e=0xF0) correctly.\n\nRELEASED: Per-register consolidation complete. Remaining x_ decode is a separate effort.","created_at":"2026-02-23T18:51:14Z"}]}
{"id":"kn5000-h7o","title":"FeatureDemo: Locate slide data structures in ROM","description":"Find where Feature Demo presentation data is stored. Search for references to FTBMP01-06 images. Identify: slide table/index, per-slide data records, pointers to resources (images, text, MIDI). Document base addresses and overall structure.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:58:14.135743894-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:08:08.052363778Z","closed_at":"2026-02-28T01:08:08.052363778Z","close_reason":"All slide data structures located and documented: metadata header (0x87FFF0), XML script (0x88000E), 6 bitmaps (0x880418+), file entry index (0x8CE01C). Struct formats, addresses, and sizes all documented in feature-demo.md.","comments":[{"id":359,"issue_id":"kn5000-h7o","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting analysis of Feature Demo slide data structures. Will search for FTBMP references, slide table pointers, and presentation data in ROM disassembly.","created_at":"2026-02-28T01:05:17Z"},{"id":360,"issue_id":"kn5000-h7o","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Slide data structures fully located and documented in feature-demo.md. Metadata header at 0x87FFF0 (struct format documented), XML action sequence at 0x88000E (hkst_55.ssf, 27 actions), 6 bitmap images at 0x880418-0x8BAFE6 (318KB total), file entry index at 0x8CE01C (24-byte struct format documented). Demo mode handlers documented with input dispatch architecture.","created_at":"2026-02-28T01:08:07Z"}]}
{"id":"kn5000-hhj1","title":"Block overflow: 2328 instructions emitted as comments due to block buffer exhaustion","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T05:20:50.701430608-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T09:41:43.650177951-03:00","closed_at":"2026-02-23T09:41:43.650177951-03:00","close_reason":"Closed","comments":[{"id":241,"issue_id":"kn5000-hhj1","author":"Felipe Correa da Silva Sanches","text":"Note: With the full ASL→LLVM migration (Phases 1-5), all 6 ROMs now build at 100% byte match via LLVM. Block overflow is a converter scaffolding issue (25K+ corrections in maincpu) that only matters for the ASL→LLVM conversion pipeline. Phase 4 (scaffolding removal) is deferred until LLVM backend encoding exactly matches original ROM for all instructions.","created_at":"2026-02-23T12:41:43Z"}]}
{"id":"kn5000-hlw","title":"table_data: Improve from 32.42% match","description":"Table data ROM (kn5000_table_data.rebuilt.rom) is at 32.42% match with 1,417,294 incorrect bytes. This ROM is mostly binary data (images, assets). Lower priority than code ROMs - focus on verifying include() paths and binary data extraction.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:50:01.43993595-03:00","created_by":"fsanches","updated_at":"2026-02-21T01:00:01.044534446-03:00","closed_at":"2026-02-21T01:00:01.044534446-03:00","close_reason":"Closed","comments":[{"id":90,"issue_id":"kn5000-hlw","author":"Felipe Correa da Silva Sanches","text":"RESOLVED (Feb 21): Table data ROM now at 100.00% byte-match! Massive improvement from 32.42% (1,417,294 incorrect bytes) to full match. All binary assets, bootloader code, and data regions are now correctly reconstructed. Verified with compare_roms.py.","created_at":"2026-02-21T04:00:00Z"}]}
{"id":"kn5000-hy8","title":"Video: Document pixel format and color palette","description":"Determine exact pixel format used by the display. Document: bits per pixel (likely 8bpp indexed), palette format and location, how palette is loaded, any direct color modes. Analyze extracted images to confirm format.","notes":"Pixel format and color palette documentation is essential for display rendering.\n\n**Current state:** 8-bit indexed color known, palette location at 0xEB37DE documented.\n\n**Required work:**\n- Verify 6-bit per channel DAC (0x3C8/0x3C9 ports)\n- Document palette loading sequence\n- Map default system palette\n- Document any palette animation support\n\n**Phase:** 1 - Foundation (MAME Blockers)\n**Blocks:** Correct color rendering\n**Dependencies:** VGA register documentation (kn5000-ezo)\n**Related:** kn5000-gln (drawing primitives)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:46:01.745559963-03:00","created_by":"fsanches","updated_at":"2026-02-21T01:00:08.512091326-03:00","closed_at":"2026-02-21T01:00:08.512091326-03:00","close_reason":"Closed","comments":[{"id":91,"issue_id":"kn5000-hy8","author":"Felipe Correa da Silva Sanches","text":"MAJOR PROGRESS (Feb 20): Pixel format and palette fully documented and working. Format: 8bpp indexed color with 4-bit RAMDAC (not standard 6-bit VGA). Palette load: write index to 0x1703C8, then RGB values to 0x1703C9 (auto-increment). 6-bit color values shifted \u003e\u003e 2 for 4-bit DAC. System palette at 0xEB37DE confirmed. Mines game renders with correct colors. Documented in display-subsystem.md.","created_at":"2026-02-21T03:32:52Z"},{"id":92,"issue_id":"kn5000-hy8","author":"Felipe Correa da Silva Sanches","text":"RESOLVED (Feb 21): Pixel format and color palette fully documented and working in MAME. Format: 8bpp indexed color with 4-bit RAMDAC (not standard 6-bit VGA). Palette write: index to 0x1703C8, RGB to 0x1703C9 (auto-increment). 6-bit values shifted \u003e\u003e2 for 4-bit DAC. System palette at 0xEB37DE. Mines game renders with correct colors. Documented in display-subsystem.md.","created_at":"2026-02-21T04:00:08Z"}]}
{"id":"kn5000-ii4","title":"SubCPU Boot: Disassemble DMA transfer routines (0xFF8604-0xFF8955)","description":"About 850 bytes of code from 0xFF8604 to 0xFF8955 need to be disassembled.\n\nThis section contains DMA transfer and inter-CPU communication routines:\n- Multiple timeout loops with 0xEA60 counter\n- DMA channel 2 configuration (DMAS2, DMAC2)\n- Latch communication at 0x120000\n- Status flag handling at 0x0516\n- Memory buffer operations at 0x0502\n\nFrom unidasm analysis, routines include:\n- SUB_8604: DMA transfer setup with timeout\n- SUB_8649: Channel setup helper\n- SUB_86AC: Status polling routine\n- SUB_86DC: Alternate transfer handler\n- Several more helper routines\n\nCross-reference with kn5000_subcpu_boot.ic30.unidasm for disassembly.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T20:46:18.822805977-03:00","created_by":"fsanches","updated_at":"2026-01-26T03:06:50.258894436-03:00","closed_at":"2026-01-26T03:06:50.258894436-03:00","close_reason":"Closed","comments":[{"id":93,"issue_id":"kn5000-ii4","author":"fsanches","text":"COMPLETED! All 5 DMA Transfer Routines fully disassembled (539/539 bytes):\n1. DMA_SEND_CHUNKED (0xFF8604-0xFF8648): 69 bytes\n2. DMA_SEND_BLOCK (0xFF8649-0xFF86AB): 99 bytes\n3. SEND_E3_CMD (0xFF86AC-0xFF86DB): 48 bytes\n4. WAIT_DMA_THEN_E2 (0xFF86DC-0xFF874B): 112 bytes\n5. DMA_MULTI_STAGE (0xFF874C-0xFF881E): 211 bytes\n\nSub CPU boot ROM maintains 100% byte-perfect match.\n\nMemory locations discovered: DMA_MODE_REG (0x0102), DMA_PARAM_BLOCK (0x0502), DMA_READY_FLAG (0x04FE), DMA_SYNC_FLAG (0x0516), DMA_BUFFER_1 (0x050C), DMA_BUFFER_2 (0x053E)","created_at":"2026-01-26T06:07:38Z"}]}
{"id":"kn5000-ima","title":"Symbols: Apply semantic naming to FDC subsystem LABEL_* symbols","notes":"FDC subsystem semantic naming and documentation.\n\n**Current state:** Handler at 0x110000 identified, commands not documented.\n\n**Required work:**\n- Rename LABEL_* symbols in FDC code\n- Document uPD72068 command sequences\n- Trace sector read/write implementation\n- Document error handling\n\n**Phase:** 2 - Core Functionality\n**Blocks:** Floppy disk emulation\n**Dependencies:** None\n**Related:** kn5000-70b (FDC during update)","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:33.605770404-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:58:00.192981974-03:00","comments":[{"id":264,"issue_id":"kn5000-ima","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting FDC subsystem analysis and semantic naming.","created_at":"2026-02-23T20:17:27Z"}]}
{"id":"kn5000-iwmk","title":"LLVM converter: Native memory-operand ALU (AND/OR/ADD/SUB/CP with (addr)) (~4,000+ instructions)","description":"## Goal\nConvert ALU operations with memory operands from .byte fallback to native LLVM.\n\n## Instruction forms\nThese use extended addressing prefixes (C0-C5, D0-D5, E0-E5, F0-F5) or register-indirect prefixes (80-BF) followed by ALU sub-opcodes.\n\n### Estimated counts (from fallback mnemonics, memory-operand subset):\n- AND (mem): ~500-800 of 1,322 total AND fallbacks\n- OR (mem): ~400-600 of 1,039 total OR fallbacks  \n- ADD (mem): ~300-500 of 1,124 total ADD fallbacks\n- SUB (mem): ~200-300 of 458 total SUB fallbacks\n- CP (mem): ~2,000+ of 8,195 total CP fallbacks (non-short-form)\n- Total estimate: ~4,000+ instructions\n\n### Encoding patterns\n1. Direct memory addressing: F0/F1/F2 prefix + 24-bit addr + sub-opcode [+ imm]\n   - F0 = 8-bit (from B0 table), F1 = extended 8-bit\n   - F2 = 24-bit direct memory\n   - Example: .byte 0xc1, 0x02, 0x04, 0x3f, 0x04 → cp (0x0402), 4\n   \n2. Register-indirect: 80+r/90+r/A0+r/B0+r prefix + sub-opcode [+ imm]\n   - Already partially handled for LD in Tier 7\n   - ALU sub-opcodes: ADD=0x80, ADC=0x81, SUB=0x82, SBC=0x83, AND=0x84, XOR=0x85, OR=0x86, CP=0x87 (in mem-src table)\n\n## LLVM backend status\n- MemALU format: Already supported (src_mem_prefix + opcode + reg_or_imm)\n- MemStore format: Handles stores\n- Direct addressing via F2 prefix: Already supported\n- All formats encodable by MCCodeEmitter\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\nThis is complex because of the many addressing mode variants. Recommend implementing in sub-phases:\n1. Register-indirect ALU: (Xreg) operands, 2-3 byte forms\n2. Direct memory ALU: (addr) operands, 4-6 byte forms\n\n### Key challenge\nThe converter must match the EXACT LLVM syntax that the backend expects for memory operands. Check LLVM .td files for the expected operand syntax (e.g., does LLVM expect \"and a, (xhl)\" or \"and (xhl), a\"?).\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check: grep -cP '^\\s+(and|or|cp|add|sub) .+\\(' in output","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:26:17.06134984-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T18:01:23.765093782-03:00","closed_at":"2026-02-22T18:01:23.765093782-03:00","close_reason":"Closed","comments":[{"id":159,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T09:08:13Z"},{"id":160,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"Progress: Added Tier 18 for register-indirect memory ALU (both directions, all sizes). 2,244 native instructions (788 no-disp + 1,456 d8-disp). Remaining: ~5,910 memory ALU instructions use direct/extended addressing (C0-F5 prefix + address). These need different converter handling. RELEASED: Partial completion — register-indirect forms done, direct addressing deferred.","created_at":"2026-02-22T09:30:56Z"},{"id":168,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"Progress: MUL/MULS/DIV/DIVS register-immediate forms (8-bit and 16-bit) now converted to native. This adds 1,045 more instructions to the memory-operand ALU total. Remaining memory ALU uses direct addressing (C0-F5 prefix) which needs LLVM backend extensions for direct memory prefixes.","created_at":"2026-02-22T11:11:48Z"},{"id":169,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Investigating direct addressing support (C0-F5 prefix) in LLVM backend.","created_at":"2026-02-22T11:12:29Z"},{"id":170,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"Progress update: ExtPrefix (Tier 43) now generically captures all remaining prefix-byte instructions (\u003e= 0x80, sizes 2-10) including direct addressing memory ALU. These are encoded as extpfxN with literal bytes rather than semantic native instructions, but they're no longer .byte fallback. Total native: 228,545 instructions. The remaining work for full semantic conversion of direct-addressing memory ALU is lower priority since ExtPrefix already establishes instruction boundaries.","created_at":"2026-02-22T14:06:55Z"},{"id":184,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"Update: Memory-operand ALU instructions using direct addressing prefixes are now categorized as semantic ExtAddrMode instructions (sd16/sd24/dd16/dd24/etc.) instead of generic extpfx. 560 additional instructions categorized. Full semantic conversion of direct-addressing ALU operations remains optional — instruction boundaries are already correct.","created_at":"2026-02-22T18:59:07Z"},{"id":199,"issue_id":"kn5000-iwmk","author":"Felipe Correa da Silva Sanches","text":"Closing: Register-indirect ALU forms fully converted. Direct-addressing forms already categorized as ExtAddrMode with correct instruction boundaries. Remaining semantic conversion is optional polish — only 1,183 .byte instruction fallbacks remain in total.","created_at":"2026-02-22T21:01:23Z"}]}
{"id":"kn5000-izk","title":"Boot: Document HDAE5000 detection and init","description":"Trace how main CPU detects presence of HD-AE5000 expansion at boot. Document: PPI probe at 0x160000, ROM detection at 0x280000, initialization sequence if present, graceful handling if absent.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:44:55.829619597-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:48.289901832Z","closed_at":"2026-02-27T23:48:48.289901832Z","close_reason":"Already complete. HDAE5000 detection and init fully documented in boot-sequence.md (lines 912-973): PE.0 port check, XAPR magic string validation at 0x280000, Boot_Init(0x28F576) with workspace pointer 0x027ED2, 9-step initialization (palette load, VRAM copy, handler registration, HD detection), frame handler dispatch at 0x280010."}
{"id":"kn5000-j2uc","title":"LLVM codegen: short LD encoding forms for small constants","description":"Add ISel patterns or peephole to use short-encoded LD forms: LD8ri_short (0x20+r, 2 bytes), LD16ri_small (prefix+A8+imm3, 2 bytes for 0-7), LD32ri_small (prefix+A8+imm3, 2 bytes for 0-7), CP_small (prefix+D8+imm3, 2 bytes for 0-7). Saves 2-4 bytes per load of small constants.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T18:48:32.010558582-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:02:35.347330719-03:00","closed_at":"2026-02-23T19:02:35.347330719-03:00","close_reason":"Closed","comments":[{"id":269,"issue_id":"kn5000-j2uc","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Implemented in same pass as INC/DEC (TLCS900IncDecOpt). LD32ri 0-7 → LD32ri_small (saves 3 bytes), CP32ri 0-7 → CP32_small (saves 4 bytes). All 50 tests pass.","created_at":"2026-02-23T22:02:35Z"}]}
{"id":"kn5000-j3c","title":"Map button indices to physical panel buttons","description":"Analyze STATE_OF_CPANEL_BUTTONS array and related code to understand how button states are indexed. Create a mapping from array index to physical button name/location on the KN5000 front panel.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T03:10:38.277419864-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:09:51.307494155Z","closed_at":"2026-02-27T23:09:51.307494155Z","close_reason":"Complete. All 22 button segments (11 CPR + 11 CPL) are fully mapped in cpanel_constants.s, control-panel-protocol.md tables, and MAME INPUT_PORTS. Every bit position mapped to physical button name.","comments":[{"id":326,"issue_id":"kn5000-j3c","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on mapping button indices to physical panel buttons.","created_at":"2026-02-27T23:08:17Z"}]}
{"id":"kn5000-j5d2","title":"Convert all ROM sources to LLVM syntax (multi-ROM support)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T07:52:09.131874914-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T07:52:21.288330254-03:00","closed_at":"2026-02-23T07:52:21.288330254-03:00","close_reason":"Closed","comments":[{"id":231,"issue_id":"kn5000-j5d2","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All 6 ROMs now have LLVM builds with 100% byte-identical matches. Parameterized asl_to_llvm.py converter, added local label qualification, REPT expansion, DS fill detection, and 3 new LLVM backend instructions (MRID3, MRID4, SD24B3). Native instruction counts: maincpu 239683, subcpu payload 35720, subcpu boot 1329, hdae5000 502, table data 1676, custom data 0 (data-only).","created_at":"2026-02-23T10:52:16Z"}]}
{"id":"kn5000-jhi3","title":"LLVM: Extended register prefix (C7/D7/E7) — ~4,678 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:20:58.400444543-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T17:06:48.49422264-03:00","closed_at":"2026-02-22T17:06:48.49422264-03:00","close_reason":"Closed","comments":[{"id":189,"issue_id":"kn5000-jhi3","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on extended register prefix (C7/D7/E7) semantic conversion.","created_at":"2026-02-22T19:52:49Z"},{"id":190,"issue_id":"kn5000-jhi3","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Converted 4,186 of 4,678 ERP instructions to semantic mnemonics using 109 ExtAddrModeSuffixInst definitions. Remaining 492 have trailing operand bytes (trail!=0) and need a different format. 100% byte-match verified.","created_at":"2026-02-22T20:06:45Z"}]}
{"id":"kn5000-jior","title":"LLVM: Add previous register bank (QWA/QBC/QDE/QHL/QIX/QIY/QIZ/QSP) support","description":"The TLCS-900/H2 CPU has multiple register banks. The 'previous' bank registers (QWA, QBC, QDE, QHL, QIX, QIY, QIZ, QSP) are accessed via prefix bytes D4-D7 (16-bit) and similar ranges for 8/32-bit. The LLVM backend does not support these at all. Currently 3 instances in HDAE5000 assembly use .byte fallbacks: 'ld QIZ, HL' (d7 fa 9b), 'cp QIZ, 0xFFFF' (d7 fa cf ff ff), 'ld HL, QIZ' (d7 fa 8b). The backend needs register definitions and instruction patterns for these.","status":"closed","priority":1,"issue_type":"feature","owner":"juca@members.fsf.org","created_at":"2026-02-26T02:31:21.338736078Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T11:23:25.003572896Z","closed_at":"2026-02-27T11:23:25.003572896Z","close_reason":"Added PrevGR16 register class (QWA-QSP) with 4 PrevBank InstFormats and 23 instruction defs. Expanded TSFlags InstFormat from 6→7 bits. Converted 147 .byte sequences (146 HDAE5000 + 1 maincpu). All 26 encoding tests pass, 49 lit tests pass, all 6 ROMs 100% byte match.","comments":[{"id":313,"issue_id":"kn5000-jior","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-27T10:48:45Z"}]}
{"id":"kn5000-jpp","title":"Docs: Add LLVM backend repo link to hdae5000-homebrew Prerequisites","notes":"At http://arqueologiadigital.org/KN5000-docs/hdae5000-homebrew/ under 'Prerequisites', add a link to the GitHub repo where the LLVM TLCS-900 backend is being developed. Need to find or confirm the repo URL and update the markdown.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:36.160832302-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T00:45:43.188753165-03:00","closed_at":"2026-02-21T00:45:43.188753165-03:00","close_reason":"Fixed: Added link to https://github.com/felipesanches/llvm-project/tree/tlcs900_backend in hdae5000-homebrew.md Prerequisites section. Commit 13b4eb8 in kn5000-docs."}
{"id":"kn5000-jqa","title":"Document binary include e0176c_e01f7f.bin data structure","notes":"Binary include at 0xE0176C-0xE01F7F (~2KB). Part of jump table area following large address table at line 36362. Need to analyze structure and determine if this is code, data tables, or other data.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:03.407010173-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:19.817064169-03:00"}
{"id":"kn5000-js1z","title":"LLVM converter: unresolved JR/JRL branch labels (~1.5K .byte)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:11:06.329595386-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:54:42.122033302-03:00","closed_at":"2026-02-22T15:54:42.122033302-03:00","close_reason":"Closed","comments":[{"id":177,"issue_id":"kn5000-js1z","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T18:54:00Z"},{"id":178,"issue_id":"kn5000-js1z","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Analysis shows all JR/JRL/CALR instructions are already converted. The LLVM output has 22705 JR, 6833 JRL, 6845 CALR — all exceeding the ASL source counts (extras from conditional JP→JR conversions). No unresolved branch labels remain. RELEASED.","created_at":"2026-02-22T18:54:41Z"}]}
{"id":"kn5000-jwk","title":"Document DATA/BCK serial interface pinout","description":"From the block diagram, control panel MCUs connect to main CPU via DATA and BCK (clock) signals. Extract the exact pinout from schematics: which MAIN CPU pins, connector numbers, and signal characteristics (voltage levels, timing if noted).","notes":"Partial progress: Serial interface signals documented - SIN, SOUT, CLK, CNTR1, CMD0-CMD4. Full pinout in hardware-architecture.md. Protocol details still need firmware analysis.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:08:48.309873607-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:40:36.692318797-03:00","closed_at":"2026-01-26T08:40:36.692318797-03:00","close_reason":"Closed","comments":[{"id":94,"issue_id":"kn5000-jwk","author":"fsanches","text":"**Serial Interface Documentation Status:**\n\nFrom hardware-architecture.md, the CPL and CPR boards have documented signals:\n```\nSIN     - Serial data input (from main CPU)\nSOUT    - Serial data output (to main CPU)\nCLK     - Serial clock\nCNTR1   - Control/chip select\nCMD0-4  - Command lines\n```\n\n**Connection to Main CPU:**\nThe TMP94C241F has serial channels SC0 and SC1. From reset handler:\n- SC0MOD = 0x29, SC0CR = 0x00 (configured for control panel communication)\n\n**M37471M2196S MCU Pinout (CPL/CPR boards):**\nThe Mitsubishi M37471M2196S datasheet would specify exact pin numbers.\nThe schematic pages II-35 (CPL) and II-38 (CPR) show the connections.\n\n**Voltage Levels:**\n- 3.3V or 5V logic (typical for this era)\n- Exact levels require schematic verification\n\n**Status:** Hardware signals documented in hardware-architecture.md. Protocol analysis in separate issues (kn5000-p2c, kn5000-32b). Consider closing as pinout is documented.","created_at":"2026-01-26T11:22:24Z"},{"id":95,"issue_id":"kn5000-jwk","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Add DATA/BCK serial interface pinout details to hardware-architecture.md or control-panel-protocol.md. Document pin assignments, signal levels, and timing if known.","created_at":"2026-01-26T11:33:11Z"},{"id":96,"issue_id":"kn5000-jwk","author":"fsanches","text":"Website already documented: hardware-architecture.md has serial interface pinout table showing SIN, SOUT, CLK, CNTR1, CMD0-CMD4 signals. Both CPL and CPR board connections documented with function descriptions.","created_at":"2026-01-26T11:40:36Z"}]}
{"id":"kn5000-jwzk","title":"LLVM converter: LDW (n),#imm16 I/O register writes (2 fallbacks)","description":"Two .byte fallbacks at lines 113198-113199 for LDW to TREG4L/TREG5L timer registers:\n- `.byte 0x0a, 0x90, 0x01, 0x00` ; LDW (TREG4L:24), 0001h\n- `.byte 0x0a, 0x92, 0x09, 0x3d` ; LDW (TREG5L:24), 3d09h\n\nOpcode 0x0A = LDW (n), #imm16: writes a 16-bit immediate to an 8-bit direct address in the TLCS-900 I/O register space. This is a 4-byte instruction (0x0A, addr8, imm16_lo, imm16_hi).\n\nThe LLVM TLCS-900 backend doesn't have an instruction definition for this encoding. Needs a new instruction definition in TLCS900InstrInfo.td and proper encoding support.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T01:07:01.490093976-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T01:58:29.4256051-03:00","closed_at":"2026-02-23T01:58:29.4256051-03:00","close_reason":"Closed","comments":[{"id":221,"issue_id":"kn5000-jwzk","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on LDW (n),#imm16 I/O register instruction definition.","created_at":"2026-02-23T04:51:30Z"},{"id":222,"issue_id":"kn5000-jwzk","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Added LDWIO instruction to LLVM backend (dc0eee98fa80) and ldwio tier 42b to converter (29c1cd4). Both LDW (TREG4L:24) and LDW (TREG5L:24) now emit native ldwio instructions. 100% byte match verified. RELEASED.","created_at":"2026-02-23T04:58:26Z"}]}
{"id":"kn5000-jy9","title":"Sound: Document audio output path","description":"Trace complete audio signal path from DAC to output jacks. Document: analog circuitry, amplifier stages, headphone amp, line out levels, speaker amp (if internal), any analog effects or mixing.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:43.961775269-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:04:40.665757585Z","closed_at":"2026-02-28T01:04:40.665757585Z","close_reason":"Audio output path documented in tone-generator.md: signal chain diagram (IC303 → IC310/IC311 DSPs → IC313 PCM69AU DAC → IC312/IC314 op-amps → FAJ board → speakers), serial audio bus (BCK/SDOR/SDOF), all ICs identified. Further analog circuit details require schematic analysis."}
{"id":"kn5000-kc5","title":"Disassemble TODO routines at F97696-F97D8D range (jump table targets)","notes":"At address 0xF97D8D there's a jump table that references routines at F97696, F976E4, F97835, F97C21, F97C7C, F96BBF, F96BD0, F97984, F97C4B, F97C54, F97C5B, and F96D95. These routines are currently empty ORG labels. Need to disassemble the code at these addresses. Found via jump table pattern: JP T, XIX + WA with LDA XIX, LABEL_F97D8D.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T13:51:03.22885541-03:00","created_by":"fsanches","updated_at":"2026-01-26T13:51:19.622187058-03:00","comments":[{"id":97,"issue_id":"kn5000-kc5","author":"fsanches","text":"Comprehensive FDC routine analysis completed by parallel agents:\n\n**Routines decoded:**\n- F96BBF (11 bytes) - FDC initialization\n- F96BD0 (66 bytes) - FDC config/status verification\n- F96D95 (79+ bytes) - FDC Command Handler/Dispatcher\n- F97696 (77 bytes) - FDC Status/Interrupt Handler\n- F976E4 (77+ bytes) - FDC Command Execution Handler\n- F97835 (147+ bytes) - FDC Sector/Data Transfer\n- F97984 (56+ bytes) - FDC Mode Configuration (Handler 5)\n- F97C21 (41 bytes) - FDC Command Enable Setup\n- F97C4B (9 bytes) - FDC Command Disable\n- F97C54 (7 bytes) - FDC Status Copy\n- F97C5B (33 bytes) - FDC Output Control\n- F97C7C (78 bytes) - FDC Main Interrupt Handler\n\n**FDC Memory Map discovered:**\n- 0x8a20: FDC status/mode flag\n- 0x8a24: Error indicator (0x00 = success)\n- 0x8a40: FDC command code (0-11)\n- 0x8a6c: FDC drive/mode selector\n- 0x8b04: FDC control register\n\nReady for implementation in assembly source.","created_at":"2026-01-26T17:38:23Z"}]}
{"id":"kn5000-kev","title":"Video: Document font system and text rendering","description":"Analyze how text is rendered on the LCD. Document: font data location in ROM, font format (bitmap or vector), character encoding, font sizes available, text drawing routines, any internationalization support.","notes":"Font system documentation is needed for text rendering.\n\n**Current state:** Font location unknown, rendering routines not traced.\n\n**Required work:**\n- Locate font data in ROM (likely in Table Data or Main CPU)\n- Document font format (bitmap? vector?)\n- Trace text rendering routines\n- Document character encoding (ASCII? Shift-JIS?)\n\n**Phase:** 2 - Core Functionality\n**Blocks:** Text display in emulator\n**Dependencies:** Drawing primitives (kn5000-gln)\n**Related:** kn5000-dj3 (extract fonts)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:46:02.953774879-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:04:19.354734665Z","closed_at":"2026-02-28T00:04:19.354734665Z","close_reason":"Font system documented: table format, glyph encoding, character encoding, kerning, all helper functions annotated.","comments":[{"id":339,"issue_id":"kn5000-kev","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting font system documentation. Dependency kn5000-gln (drawing primitives) now complete.","created_at":"2026-02-28T00:00:14Z"},{"id":340,"issue_id":"kn5000-kev","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Font system fully documented:\n- Font table at 0x945C00 (Table Data ROM), 16 bytes/entry\n- Entry format: {width, height, descent, ascent, glyph_ptr, kerning_ptr}\n- Glyph data: 1bpp bitmaps, 8px/byte, MSB-first\n- Character encoding: ASCII with 0x20 offset, 0x7E escape prefix for hex chars\n- Kerning support: optional per-character width table (kerning_ptr != 0)\n- Annotated all font helper functions: GetCharHeight, GetCharDescent, ConvertStrings, CalcTotalWidth, WordwrapStrings, HexDigitToValue\n- Updated display-subsystem.md with character encoding section\nRELEASED: Work complete.","created_at":"2026-02-28T00:04:16Z"}]}
{"id":"kn5000-kqy","title":"maincpu: Fix 177 divergent bytes","description":"Main CPU ROM (kn5000_v10_program.rebuilt.rom) is at 99.99% match with 177 incorrect bytes remaining. Need to identify each divergent byte offset, decode the expected vs actual instruction, and fix the assembly source or macros in tmp94c241.inc.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:49:19.030347293-03:00","created_by":"fsanches","updated_at":"2026-01-31T00:02:48.201128045-03:00","closed_at":"2026-01-31T00:02:48.201128045-03:00","close_reason":"Duplicate of kn5000-5a0. Consolidating tracking to single issue.","comments":[{"id":98,"issue_id":"kn5000-kqy","author":"fsanches","text":"Divergence analysis findings:\n\n**Summary:** 177 bytes across 4 clusters\n\n**Cluster 1-3 (6 bytes total):** Call instruction encoding issues\n- Offsets 1957472, 1957600, 1957901 (ROM 0xFDDE60, 0xFDDEE0, 0xFDDFED)\n- Pattern: orig byte is 1 less than rebuilt (0xF4 vs 0xF5, 0x11 vs 0x12)\n- Likely call target address off-by-one\n\n**Cluster 4 (171 bytes):** Byte shift/alignment issue\n- Starts at offset 1961142 (ROM 0xFDECB6)\n- All bytes after this point are shifted by 1 position\n- Root cause: Extra 0x00 byte inserted at 0xFDECB9 in rebuilt\n- Original: 6e 34 c1 3a 8d 23 d9 12...\n- Rebuilt:  6e 35 c2 3a 8d 00 23 d9 12...\n\n**To fix cluster 4:**\nNeed to find source line near 0xFDECB6 and identify extra byte.\nSearch for: labels near FDECB6, db statements with 00h, or incorrect instruction encoding.\n\n**Reference disassembly at 0xFDECB6:**\n```\nfdecb4: 6e 34           jr NZ,0xfdecea\nfdecb6: c1 3a 8d 23     ld C,(0x8d3a)\nfdecba: d9 12           extz BC\n```","created_at":"2026-01-26T10:34:24Z"},{"id":99,"issue_id":"kn5000-kqy","author":"fsanches","text":"Found likely source of cluster 4 divergence:\n\n**Line 430492:**\n```\nLD C, (8D3Ah:24)\n```\n\nThe `:24` suffix forces 24-bit addressing mode. Reference shows:\n```\nfdecb6: c1 3a 8d 23     ld C,(0x8d3a)\n```\n\nBytes: c1 3a 8d 23 (4 bytes)\n- c1 = opcode for ld r8, (mem)\n- 3a 8d = 16-bit address 0x8D3A (little-endian)\n- 23 = part of instruction encoding (possibly register encoding or mode)\n\nThe `:24` may be causing ASL to use different encoding, inserting extra 0x00 byte.\n\n**Potential fix:** Change to `LD C, (8D3Ah)` without `:24` suffix, or verify correct encoding for this addressing mode.\n\nAlso check lines 430494, 430496, 430499, 430500 for similar issues with address mode suffixes.","created_at":"2026-01-26T10:34:58Z"},{"id":100,"issue_id":"kn5000-kqy","author":"fsanches","text":"**Attempted Fix Analysis:**\n\nTried removing `:24` suffix from line 430492:\n```\nLD C, (8D3Ah:24)  --\u003e  LD C, (8D3Ah)\n```\n\nResult: ROM became 1 byte smaller (2097151 instead of 2097152 bytes), causing massive misalignment.\n\n**Key Insight:**\nThe `:24` suffixes are intentionally placed to maintain total ROM size matching, even though they generate incorrect byte sequences. The divergences form a balanced system where:\n- Some instructions have extra bytes (from `:24` suffixes)\n- These extra bytes pad the ROM to match the original size\n- Simply removing one `:24` without adding padding elsewhere breaks alignment\n\n**Proper Fix Strategy:**\n1. Must analyze ALL 177 divergent bytes together as a system\n2. For each `:24` instruction generating wrong bytes:\n   - Check if original uses 16-bit or 24-bit addressing\n   - If original uses 16-bit, remove `:24` AND find compensating padding\n3. The clusters of divergences suggest systemic encoding differences, not random errors\n\n**Files for Analysis:**\n- Use compare_roms.py to identify exact divergent offsets\n- Cross-reference with listing file (kn5000_v10_program.lst)  \n- May need custom script to map divergences to source lines\n\n**Complexity Level:** HIGH - requires coordinated changes across multiple locations.\n\nStatus: Reverted change, needs comprehensive analysis before reattempting.","created_at":"2026-01-26T10:46:43Z"}]}
{"id":"kn5000-kuu","title":"HDAE5000: Disassemble ROM at 0x280000","description":"Disassemble and analyze the 512KB HDAE5000 ROM mapped at 0x280000. Identify entry points, command handlers, filesystem routines, and communication protocols. Determine CPU type if different from main board.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:33:15.890407873-03:00","created_by":"fsanches","updated_at":"2026-02-27T21:40:32.005523505Z","closed_at":"2026-02-27T21:40:32.005523505Z","close_reason":"HDAE5000 disassembly complete. Code sections fully converted to native TLCS-900 assembly mnemonics: only 25 .byte remain in code (zero-padding + 3 SP-register-blocked). 17,092 .byte in data sections (graphics/fonts/palettes) are data, not instructions. 264+ symbols, 125+ routines identified. All 5 LLVM improvement sub-issues also closed.","comments":[{"id":101,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 20): HDAE5000 ROM disassembly progress. Handler_Registration routine (0x280020-0x28030D) fully disassembled with symbolic labels. Dispatch system symbols added (object dispatch, handler 0x016A data record table). Event codes (EVT_*) added as EQU constants. About 5% disassembled. Mines homebrew successfully uses the extension board interface for game rendering.","created_at":"2026-02-21T03:33:08Z"},{"id":294,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 25): Major structural improvement to HDAE5000 disassembly. Split 3 large binary blocks into labeled routines:\n- code_2803c2_28f542.bin (62KB): 64 routines identified — PPI/IDE I/O, HD setup, filesystem ops, display/menu, file operations, string utilities\n- code_2971b7_29ae9e.bin (16KB): 11 routines — RAM test, HD detection, sprintf library\n- code_28f90c_2953e1.bin (22KB chunk): 50 routines — display table management, 9 cell renderers, workspace callbacks\n\nTotal new symbols: 122 (from 34 to 264 labels). Symbol reference file updated.\nHandler_Registration at 0x280020 was already fully disassembled.\nRemaining binary data is mostly graphics/fonts (159KB font data, 77KB palette) that doesn't benefit from further splitting.","created_at":"2026-02-25T20:33:50Z"},{"id":296,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 25, session 2): Converted 19 small routines from binary includes to native LLVM TLCS-900 assembly instructions, all verified 100% byte-matching. Total converted bytes: ~706 bytes of code now fully disassembled at instruction level. Also split 2 additional binary blocks to add labels for cross-references (Divide_Unsigned, Divide_Signed, File_Read). Established comprehensive unidasm-to-LLVM instruction mapping including: post-increment addressing (F5 prefix), register-indexed addressing (F3 prefix), 24-bit direct addressing (E2/F2 prefix), indirect calls, Q-register operations, and 8-bit memory-immediate operations.","created_at":"2026-02-25T21:25:01Z"},{"id":297,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Session 3 progress: Converted 21 more routines (7+14) to native LLVM assembly, all verified 100% byte match. Added 9 cross-reference labels by splitting binary blocks. Total converted this session: Code_Remainder, MemCopy_Block, Display_Buffer_Validate, MemCompare_Block, PPI_Read_Register, PPI_Transfer_Block, Get_Table_Entry, Cell_Get_Params, Table_Sub_291BDE, Display_Sub_294273, Display_Sub_29429E, PPORT_Cmd_ReceiveDataBlock, PPORT_Cmd_LoadHDtoMemory, PPORT_Utility_2, PPORT_Status, PPORT_Util, PPORT_Menu, PPORT_Handler, PPORT_Dispatch, Display_String. New LLVM patterns: pushw/popw, ldw/ldb, cpdi8_24, stda16_24, ldda16_24, ei, nop. Cumulative total: 43 routines converted across 3 sessions.","created_at":"2026-02-25T21:55:22Z"},{"id":298,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 25, session 2): Converted 10 routines from .incbin to native TLCS-900 assembly (total ~1,490 bytes converted this session):\n- Display_Notify fix (113 bytes) — fixed lds→lds32, cpda→cpdm encoding\n- Config_Init (114 bytes) — MIDI header validation\n- Display_Init (114 bytes) — workspace callback dispatch, ld_sril3 for E3 encoding\n- Extension_Check (153 bytes) — byte-swap helper + workspace callbacks\n- Menu_Register_B (146 bytes) — two sub-routines with 0x01C00015/0x01C00016\n- PPI_Transfer_Byte (130 bytes) — PPI 8255 port I/O with nibble handshaking\n- HD_Wait_Ready (138 bytes) — stack-based param blocks + LDIW template copy\n- Calc_Disk_Space (178 bytes) — dual entry: space calculation + bitmap position finder, uses ret ule and djnz16\n- Set_Menu_Visibility (229 bytes) — 9 identical workspace callbacks\n- Menu_Handler + Menu_Callback (2×248 bytes) — complex menu processors with stack frames\n\nKey LLVM mnemonics discovered: ldmw, ldmi8/ldmi16, cpmi8, bitda_24, ret cc, djnz16, ldada_24, stda16_24 with GPR, lda with XSP.\nAll 100% byte-matched on first or second try. 30 .incbin blocks remaining (smallest: 192 bytes).","created_at":"2026-02-25T23:22:48Z"},{"id":299,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Session progress: Converted 10 more routines (3872 additional bytes):\n- Display_Sub_294301 (275b) - buffer transfer with split paths\n- PPORT_Execute (234b) - command dispatcher with jump table\n- Cell_Validate (347b) - bitmask-driven size validation\n- PPORT_Setup (442b) - 30-handler command dispatch\n- Workspace_Handler (592b) - nested clearing + 16-slot processing\n- Table_Calc_Offset (553b) - 9-slot availability check\n- Table_Lookup (928b) - bitmask builder + entry setup with QIZ\n\nAlso created 5 P1 issues for LLVM mnemonic improvements:\n- kn5000-c7ug: ld_sril3 → semantic register+displacement\n- kn5000-gels: 24-bit address instructions → readable forms\n- kn5000-fjwn: memory-immediate → standard cp/ld syntax\n- kn5000-o6jd: callcc_24/jpcc_24 → symbolic condition codes\n- kn5000-jior: previous register bank (QIZ etc.) support\n\nDiscovered new instructions: setm, incm, popw, ldb, cpdi8_24, ldada_24 for various registers. Previous register bank (QIZ) requires .byte fallbacks.","created_at":"2026-02-26T02:31:35Z"},{"id":300,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 26): Completed code_295642_2971a2.bin conversion to native assembly. This session converted 2 major blocks:\n\n1. HDAE5000_Cmd04_SendFSB (798 bytes at 0x295D3C):\n   Send FSB to PC handler — mask setup, buffer build (9 region descriptors), 9 flag bit tests with region sends.\n\n2. PPORT Cleanup + 9 sub-routines (1773 bytes at 0x296AB6):\n   Cleanup (sentinel write), utility (display + buffer copy), send bytes, receive + write bytes, receive sector data, send two regions, receive custom ROM data, init region descriptors, compute sector descriptor, send region to PC.\n\nCombined this + previous sessions: code_295642_2971a2.bin fully converted (0 remaining incbin refs).\nTotal for code_295642: ~7093 bytes of instruction-level assembly across 34 routines.\nAll 100% byte match, all committed and pushed.\n\nRemaining incbin blocks in other binaries:\n- code_2803c2_28f542.bin: 30 blocks\n- code_28f90c_2953e1.bin: 5 blocks\n- code_2971b7_29ae9e.bin: 8 blocks\n- code_29af2d_2fffff.bin: 10 blocks (includes large data-heavy blocks)","created_at":"2026-02-26T04:03:36Z"},{"id":303,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Progress: All HDAE5000 code blobs now disassembled. 22 code sections converted (80,421 bytes of code). Only 4 data blobs remain (340,790 bytes of fonts/graphics/palettes). Total HDAE5000 disassembly: ~81% by byte count (code), or 100% of executable code.","created_at":"2026-02-27T05:41:40Z"},{"id":304,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Progress (Feb 27, session 2): Upgraded 14,739 .byte instructions to native LLVM mnemonics in HDAE5000.\n\nConversion approach: systematically test each TLCS-900 instruction pattern against LLVM assembler output, convert only when byte-for-byte match is confirmed.\n\nSafe patterns identified and converted:\n- 32-bit: call, ret, push/pop xreg, extz/exts, inc N, or self, ld indirect (all bases, with/without offset), ld stack-relative, div, pushw, ldmw, ldada_24\n- 16-bit: ld store indirect (all bases, with/without offset), extz/exts, or self, inc N\n- Conditional: ret z/nz/lt/ge/le/gt\n\nKey LLVM encoding issues found (preventing further conversion):\n- 16-bit push/pop: different opcode (prefix form vs compact)\n- ld reg, reg (all sizes): operand order swapped in encoding\n- ld reg, imm: uses different opcode family\n- dec: different sub-opcode values\n- add/sub/xor/and reg, reg: operand encoding swapped\n- 8/16-bit loads from memory: wrong register sub-opcodes\n- call cond, xreg / lda / cpl / sll/srl: not supported\n- offset=0: LLVM optimizes to no-offset form (size change)\n\nRemaining .byte breakdown: 18,798 code instructions (LLVM encoding mismatch), 12,631 data bytes. Further conversion requires LLVM backend fixes.","created_at":"2026-02-27T06:05:25Z"},{"id":305,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Progress (Feb 27, session 2 final): HDAE5000 native mnemonic upgrade complete.\n\nFinal statistics:\n- 34,581 native assembly instructions (66.4% of code)\n- 17,483 .byte code instructions (LLVM encoding mismatch)\n- 12,492 .byte data bytes\n- 100% byte match maintained throughout\n\nConversion batches applied:\n1. call, ret, push xreg, extz xwa, pushw imm16, div, ldmw, ldada_24, ld (xsp+N) — 4,077\n2. nop, pop xreg, ret cond, extz/exts, inc 1, or self, ld indirect (all), ld stack — 10,425\n3. 16-bit stores, inc 2/4, extz/exts 16-bit, or 16-bit self — 237\n4. pushw/popw (compact 16-bit push/pop) — 1,292\n5. jp, dec 0, ldirw, ei, halt — 162\nTotal: 16,193 .byte → native upgrades\n\nRemaining .byte requires LLVM backend fixes for:\n- Operand order swap in reg-reg LD/ADD/SUB/XOR encoding\n- 16-bit immediate load uses different opcode family\n- Conditional calls via register (call T,XHL etc.) not supported\n- lda instruction not supported\n- calr (relative call) needs label infrastructure\n- Absolute address loads have wrong second byte\n- dec 1/2/4 use wrong sub-opcode values","created_at":"2026-02-27T10:10:15Z"},{"id":314,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on fixing LLVM encoding bugs to convert remaining .byte instructions.","created_at":"2026-02-27T17:37:26Z"},{"id":315,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS: Converted 2,680 register prefix .byte instructions to native mnemonics (commit 9069d95). Breakdown: LD=848, LD_small=754, ADD=445, CP=179, SUB=134, XOR=82, OR=73, AND=53, INC=43, DEC=27, SCC=16, MUL/DIV=14, ADC/SBC=8, CPL/NEG/PUSH/POP/EXTZ/EXTS=4. Combined with 147 PrevBank conversions. All 6 ROMs still 100% byte match. Remaining .byte code instructions need LLVM backend additions (LDA, conditional call, CALR, etc).","created_at":"2026-02-27T17:54:07Z"},{"id":316,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"PROGRESS: Converted 4,447 more .byte to native mnemonics (commit dbacfd1). Breakdown: memory addressing modes (3,616) + register prefix + immediate (831). Combined session total: 7,958 .byte→native conversions. Remaining multi-byte .byte in HDAE5000: 7,322 (mostly: (R+d16) large displacements, 16-bit direct memory, conditional calls, CALR, shifts/rotates, MUL/DIV with imm). All require LLVM backend additions.","created_at":"2026-02-27T18:12:52Z"},{"id":317,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Converted 246 more register prefix .byte to native: 205 shifts (SLL/SLA/SRL/SRA), 19 MUL/DIV, 11 shift-by-A, 5 rotates, 4 BIT/RES, 2 other. Commit 565ff17. Session total: 4,756 conversions (4,510 + 246).","created_at":"2026-02-27T18:34:40Z"},{"id":318,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Converted 2,498 more .byte to native in two batches:\n- 246 register prefix ops (shifts, rotates, MUL/DIV, unary): commit 565ff17\n- 1,214 branch instructions (JR/JRL/CALR): commit d9561b9\n- 1,038 compact memory ops (CALL/JP/CPW/LD stores): commit 1cffbf0\nRunning total this issue: ~10,456 .byte→native conversions across all sessions.","created_at":"2026-02-27T18:47:28Z"},{"id":319,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Session progress (3 commits this round):\n- 246 register prefix (shifts, rotates, MUL/DIV, unary): 565ff17\n- 1,214 branches (JR/JRL/CALR): d9561b9\n- 1,038 compact memory (CALL/JP/CPW/LD stores): 1cffbf0\n- 523 short LD + compact dst stores: d6035a5\nTotal this round: 3,021 conversions.\n\nHDAE5000 remaining multi-byte .byte: 4,663 (down from 7,019 at start of round).\n\nRemaining categories (all need LLVM backend additions):\n- (R+d16) 32-bit extended: ~970\n- 16-bit direct memory: ~470\n- 8-bit direct memory: ~210\n- F2 imm-to-memory stores: ~400\n- Complex addressing (R+R, predec/postinc): ~300\n- Conditional CALL through register: 8\n- Other unsupported sub-opcodes: ~300","created_at":"2026-02-27T18:52:03Z"},{"id":320,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Session progress: Converted 198 register-indexed addressing .byte to native SRI/DRI mnemonics (C3/D3/E3/F3 prefixes). Added 2 new LLVM defs (adc_sril_mr, or_sril_rm). Also discovered LLVM sub-opcode naming bug: st_dri3b/lda_dri3 have swapped sub-opcodes (0x30/0x40 reversed vs MAME). Bug doesn't affect byte correctness since names are just labels. Combined with previous direct memory work this session: 1080+198 = 1,278 conversions. Remaining HDAE5000 multi-byte .byte: ~1,943 (most in data sections). Next targets: C7/D7 bank prefix, C4/C5/D4/E4/F4/F5 inc/dec prefix patterns.","created_at":"2026-02-27T20:14:08Z"},{"id":321,"issue_id":"kn5000-kuu","author":"Felipe Correa da Silva Sanches","text":"Session progress: Added 5 new LLVM format classes (MemRegImmMod, MemRegRegSuffix, MemRegRegDispSuffix, MemRegImmAfter, MemRegDispImmAfter) and 57 instruction defs for source-memory register-indirect operations. Converted 149 .byte to native mnemonics: 43 carry flag RI, 59 shift/rotate/MUL/DIV RI, 47 LD/LDA/EX/ALU/control flow RI. HDAE5000 code sections (lines 1-42000) now have essentially 0 convertible .byte patterns — only 1 genuine instruction .byte + 3 SP-register-blocked patterns remain. ~164 .byte in data table sections (lines 42000+) are data, not instructions.","created_at":"2026-02-27T21:39:43Z"}]}
{"id":"kn5000-kxw","title":"FeatureDemo: Extract MIDI files as standalone files","description":"Extract all embedded MIDI data as playable .mid files. Parse MIDI structure to find exact boundaries. Name files descriptively. Verify extracted files play correctly in standard MIDI player. Add to project assets.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:22.761167482-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:16:29.686002426Z","closed_at":"2026-02-28T01:16:29.686002426Z","close_reason":"No meaningful MIDI files to extract. Only an empty 22-byte MIDI placeholder exists at 0xF2823E. Demo songs use proprietary rhythm pattern format, not Standard MIDI."}
{"id":"kn5000-lb20","title":"LLVM: Forced d8=0 displacement memory ops — ~234 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:20:59.937802021-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T17:55:21.087859769-03:00","closed_at":"2026-02-22T17:55:21.087859769-03:00","close_reason":"Closed","comments":[{"id":195,"issue_id":"kn5000-lb20","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on forced d8=0 displacement memory ops.","created_at":"2026-02-22T20:43:11Z"},{"id":196,"issue_id":"kn5000-lb20","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Implemented sentinel d8=0 displacement (disp=256 forces d8 prefix with 0x00). Changed MCCodeEmitter emitMemPrefix + 9 converter patterns. ~481 .byte → semantic instructions. 100% byte-match verified.","created_at":"2026-02-22T20:55:17Z"}]}
{"id":"kn5000-lgy2","title":"Mines: Take full video ownership to fix flickering","description":"The Mines game suffers from unpleasant flickering because the Program ROM firmware overwrites VRAM every frame. Setting bit 3 of address 0x0D53 (firmware flag byte) disables firmware display updates, giving the extension ROM exclusive VRAM ownership. We need to set this bit on game activation and clear it on exit.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-24T05:19:37.688548312-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-24T05:42:19.486943987-03:00","closed_at":"2026-02-24T05:42:19.486943987-03:00","close_reason":"Closed","comments":[{"id":289,"issue_id":"kn5000-lgy2","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-24T08:19:47Z"},{"id":290,"issue_id":"kn5000-lgy2","author":"Felipe Correa da Silva Sanches","text":"FIXED: Implemented full video ownership by setting bit 3 of 0x0D53 in startup.s. This disables firmware rendering during gameplay, eliminating flickering. Re-enabled on game exit. Simplified idle_update in video.c as aggressive redraw is no longer needed.","created_at":"2026-02-24T08:42:14Z"}]}
{"id":"kn5000-li65","title":"HDAE5000 FS: Annotate file operations (Save/Load/Delete/Rename/Format)","description":"The five main file operation routines are already disassembled: File_Save (381b at 0x28DA7B), File_Load (564b at 0x28DBF8), File_Delete (579b at 0x28DE2C), File_Rename (280b at 0x28E06F), File_Format (772b at 0x28E187). Add detailed annotations explaining: parameter structures, how each operation modifies the FSB/FGB/FEB, how sector allocation changes on save/delete, how directory entries are updated, and the file type dispatch logic (types 0x7E/0x58/5).","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:30:10.864302848Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T23:39:06.646006246Z","closed_at":"2026-02-27T23:39:06.646006246Z","close_reason":"Annotated all 5 file operation routines: File_Save (type code mapping), File_Load (audio channel dispatch, filename slots), File_Delete (directory backup, type dispatch 0x0D/0x0A), File_Rename (directory search/traversal, DE modes). File_Format was already annotated in kn5000-c5gn.","comments":[{"id":333,"issue_id":"kn5000-li65","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on file operation annotations.","created_at":"2026-02-27T23:36:55Z"}]}
{"id":"kn5000-ljl","title":"Map LED indices to physical panel LEDs","description":"Analyze CPANEL_LED_READ_PTR, CPANEL_LED_WRITE_PTR, and CPANEL_LED_TX_BUFFER to understand LED addressing scheme. Create a mapping from index to physical LED name/location on the KN5000 front panel.","notes":"Analyze CPANEL_LED_READ_PTR, CPANEL_LED_WRITE_PTR, and CPANEL_LED_TX_BUFFER to understand LED addressing scheme. Create a mapping from index to physical LED name/location on the KN5000 front panel.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T03:10:39.02955547-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:09:51.463275207Z","closed_at":"2026-02-27T23:09:51.463275207Z","close_reason":"Complete. All 15 LED rows (9 CPR rows 0x00-0x0C + 6 CPL rows 0xC0-0xC8) are fully mapped in cpanel_constants.s, control-panel-protocol.md tables, and MAME cpanel_leds_w() function. Every bit position mapped to physical LED name."}
{"id":"kn5000-lzqh","title":"LLVM converter: batch small instruction conversions (+5,833)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T08:11:31.119645662-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T08:11:41.419699298-03:00","closed_at":"2026-02-22T08:11:41.419699298-03:00","close_reason":"Closed","comments":[{"id":167,"issue_id":"kn5000-lzqh","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Session converted 5,833 instructions to native LLVM assembly (177,963→183,796 native, 51,650→45,817 fallback). Changes made:\n1. LD immediate-to-memory (B0/B8 prefix, MemStoreImm format): +1,516\n2. LD small-immediate 8/32-bit, INC/DEC count=8 fix, prefix PUSH8/POP8: +4,484\n3. MUL/MULS/DIV/DIVS register-immediate 8/16-bit: +1,045\n4. Indirect CALL (B0+r, 0xE8), flag ops (SCF/RCF/CCF/ZCF), PUSH/POP A/F: +304\nLLVM backend: 4 commits adding MemStoreImm format, LD8/32ri_small, PUSH8/POP8, MUL/DIV imm, flag/misc instructions.\nAll verified: 100% byte-identical ROM output.","created_at":"2026-02-22T11:11:41Z"}]}
{"id":"kn5000-m1j","title":"Disassemble table_data bootloader raw db bytes to proper assembly","notes":"The table_data bootloader contains many routines as raw db bytes with comments. These should be converted to proper assembly for readability and maintainability.\n\nPriority regions (matching maincpu routines):\n- Init_Display_Progress (0x9FCD9A) - currently db bytes, maincpu has VRAM_FillRect\n- Boot utility routines (0x9FBC3C)\n- Boot init routines (0x9FB4F2)\n\nApproach:\n1. Use maincpu disassembly as reference (has proper labels)\n2. Convert db bytes to proper TLCS-900 instructions\n3. Use macros from tmp94c241.inc for unsupported opcodes\n4. Add meaningful labels matching maincpu where applicable\n\nThis will make the table_data bootloader easier to understand and maintain.\n\nReference: maincpu VRAM_FillRect at 0xEF50DF, rom-reconstruction.md","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:37:32.93389301-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T21:54:21.399848015Z","closed_at":"2026-02-27T21:54:21.399848015Z","close_reason":"All instruction .byte patterns in table_data bootloader converted to native TLCS-900 assembly (26 total: 8 JR, 18 CALR). Split bootcode_flash_handlers.bin to expose 6 internal labels. All 6 ROMs 100% byte match. Only data .byte (constants, tables) remain.","comments":[{"id":102,"issue_id":"kn5000-m1j","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Table data ROM is now at 100% byte-match, meaning all bootloader db bytes produce correct output. However, the readability goal of this issue remains: many routines are still represented as raw db bytes with comments rather than proper TLCS-900 assembly mnemonics. The work here is about code quality and maintainability, not correctness.","created_at":"2026-02-21T04:00:37Z"},{"id":322,"issue_id":"kn5000-m1j","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work. Only 48 .byte lines remain, 23 are instructions (8 JR, 15 CALR). Will convert to native mnemonics.","created_at":"2026-02-27T21:41:41Z"}]}
{"id":"kn5000-m91","title":"Video: Document Video RAM IC207 (M5M44265CJ8S)","description":"Document the 4Mbit Video RAM. Determine: memory organization, how it maps to screen pixels, double-buffering if used, access patterns from main CPU. Calculate how 4Mbit supports 320x240 display with various color depths.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:46:00.538213219-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:38:06.89490376-03:00","closed_at":"2026-01-26T08:38:06.89490376-03:00","close_reason":"Closed","comments":[{"id":103,"issue_id":"kn5000-m91","author":"fsanches","text":"**M5M44265CJ8S Video RAM Analysis:**\n\n**Chip Specifications:**\n- Mitsubishi M5M44265CJ8S\n- 4Mbit (512KB) VRAM\n- Likely dual-ported (VRAM vs DRAM) for simultaneous CPU/display access\n\n**Memory Organization for KN5000 Display:**\n\nDisplay: 320x240 @ 8bpp (256 colors)\n```\nFrame buffer size: 320 × 240 × 1 byte = 76,800 bytes (~75 KB)\n```\n\nWith 512KB VRAM available:\n```\n512KB / 75KB ≈ 6.8 frame buffers possible\n```\n\n**Possible Memory Layout:**\n```\n0x1A0000 - 0x1A12BFF: Frame buffer 0 (76,800 bytes)\n0x1A12C00 - 0x1A257FF: Frame buffer 1 (if double-buffered)\n0x1A25800 - 0x1A7FFFF: Additional buffers / sprite data / scratch\n```\n\n**Access Pattern (from firmware):**\n- CPU writes to 0x1A0000 base address\n- VGA controller reads via serializer for display output\n- CRTC Start Address registers (0x0C/0x0D) can select active buffer\n- Current config has Start Address = 0x0000 (buffer 0)\n\n**Color Format:**\n- 8-bit indexed color (palette lookup)\n- Palette stored in DAC registers (0x3C8/0x3C9)\n- Each palette entry: 6-bit R, 6-bit G, 6-bit B (18-bit color)\n\n**Display Timing Integration:**\n- Pixel clock: 25 MHz\n- Horizontal: 320 visible + blanking = ~400 total\n- Vertical: 240 visible + blanking = ~262 total\n- Frame rate: 25MHz / (400 × 262) ≈ 238 Hz pixel rate → ~60 Hz refresh\n\nStatus: Documented based on firmware analysis. Chip datasheet not found but memory organization derived from display parameters.","created_at":"2026-01-26T11:20:08Z"},{"id":104,"issue_id":"kn5000-m91","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Video RAM Organization' section with actual findings about color depth, memory organization, and access patterns. Add VRAM address information to memory-map.md.","created_at":"2026-01-26T11:32:41Z"},{"id":105,"issue_id":"kn5000-m91","author":"fsanches","text":"Website updated: reverse-engineering.md 'Video RAM Organization' section now documents M5M44265CJ8S chip, base address 0x1A0000, memory layout with frame buffers, and access patterns. memory-map.md updated with VRAM address range.","created_at":"2026-01-26T11:38:06Z"}]}
{"id":"kn5000-mfvh","title":"LLVM backend: add LDW memory-to-memory instruction (1 fallback)","description":"LDW_16_16 (mem),(mem) — opcode 0xD1 prefix with sub-opcode 0x19. Memory-to-memory word transfer. The LLVM backend has no instruction definition for this encoding. Need to add LDMM16. 1 instance in subcpu_payload.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.515873266-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:19:03.225367567-03:00","closed_at":"2026-02-23T08:19:03.225367567-03:00","close_reason":"Closed","comments":[{"id":239,"issue_id":"kn5000-mfvh","author":"Felipe Correa da Silva Sanches","text":"NOT A REAL FALLBACK: The LDW memory-to-memory instruction is written as 'db 0d1h, 0b0h, ...' in the ASL source. It's a data directive, not an instruction the converter failed to convert. Closing as invalid.","created_at":"2026-02-23T11:19:03Z"}]}
{"id":"kn5000-mhj","title":"Boot: Create complete boot sequence timeline","description":"Compile all boot documentation into a comprehensive timeline. Create diagram showing: time from power-on, which subsystem initializes when, dependencies between init stages, total boot time to user-ready state. Add to documentation website.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:44:56.95886873-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:49:27.031867031Z","closed_at":"2026-02-27T23:49:27.031867031Z","close_reason":"Already complete. Complete boot timeline exists in boot-sequence.md (lines 1132-1170): Power On (0ms) → Hardware init (1ms) → Memory tests (10ms) → SubCPU payload transfer (15-115ms) → SubCPU payload executing (120ms) → Main CPU subsystem init (150ms) → HDAE5000 init (200ms) → System ready (250ms)."}
{"id":"kn5000-mr3i","title":"LLVM backend+converter: SWI instruction not emitted (1 fallback)","description":"SWI 7 (opcode 0xFF = 0xF8|7). Single-byte instruction with vector embedded in opcode. The LLVM backend SWI definition is wrong (2 bytes instead of 1). Converter has no tier to emit SWI. Fix both. 1 instance in subcpu_payload.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.697707633-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:18:52.855567957-03:00","closed_at":"2026-02-23T08:18:52.855567957-03:00","close_reason":"Closed","comments":[{"id":235,"issue_id":"kn5000-mr3i","author":"Felipe Correa da Silva Sanches","text":"FIXED: Added Tier 1b for SWI (1-byte: 0xF8+imm3). Emits 'swi N' natively. Backend already had correct SWI definition.","created_at":"2026-02-23T11:18:52Z"}]}
{"id":"kn5000-mrx","title":"Sound: Extract and convert waveform samples","description":"Extract raw waveform data from ROM as playable audio. Convert to WAV format. Catalog samples by instrument type. Document sample rates, loop points, root notes. Useful for MAME sound emulation verification.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:50:47.632772772-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:15:26.959647637Z","closed_at":"2026-02-28T01:15:26.959647637Z","close_reason":"Blocked: Waveform ROMs (IC304-IC307) are read internally by the tone generator IC303 — the CPU never accesses sample data. Cannot extract waveform samples from firmware disassembly. Requires ROM dumping hardware."}
{"id":"kn5000-mzz","title":"HDAE5000: Document interface cable pinout","description":"Determine the pinout of the cable connecting HD-AE5000 to KN5000. Identify connector types, signal assignments (accent data, accent control, accent bus, accent power), and voltage levels. Reference service manual if available.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-25T04:33:16.932785356-03:00","created_by":"fsanches","updated_at":"2026-01-25T04:33:16.932785356-03:00"}
{"id":"kn5000-nca","title":"Phase 4 Completion: Production-ready quality","notes":"Meta-issue tracking Phase 4 completion (Quality \u0026 Polish).\n\n## Phase 4 Goals\nProduction-ready emulation and homebrew support.\n\n## Deliverables\n\n### Symbol Cleanup\n- kn5000-9jq: Sub CPU audio code symbols\n- kn5000-4bt: UI framework symbols\n- kn5000-aar: Naming convention guide\n\n### Tool Development\n- kn5000-waa: Slide viewer/editor\n- kn5000-87m: Update file parser\n- kn5000-pkx: Image converter\n- kn5000-5jy: Homebrew SDK\n\n### Documentation Polish\n- kn5000-9a0: Website maintenance\n- kn5000-sf8: Code reference tables\n\n### Validation\n- kn5000-a8s: Emulation validation procedures\n\n## Depends On\n- Phase 3 completion\n\n## Success Criteria\n- [ ] All LABEL_* symbols renamed to semantic names\n- [ ] Homebrew SDK with working examples\n- [ ] MAME driver merged upstream\n- [ ] All tools functional and documented","status":"open","priority":3,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:08:10.750073388-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:08:10.750073388-03:00"}
{"id":"kn5000-nfa","title":"LLVM converter: Native PUSH/POP r16 and PUSH/POP SR (~2,128 instructions)","description":"## Goal\nConvert PUSH r16, POP r16, PUSH SR, and POP SR from .byte fallback to native LLVM.\n\n## Instruction forms\n\n### PUSH r16 (1-byte: 0x28+r) — 1,294 instances\n- Opcode range: 0x28-0x2F (WA=0, BC=1, DE=2, HL=3, IX=4, IY=5, IZ=6, SP=7)\n- Example: .byte 0x28 → push wa\n- Note: PUSH r32 (0x38-0x3F) is already handled in Tier 6.\n\n### POP r16 (1-byte: 0x48+r) — 763 instances\n- Opcode range: 0x48-0x4F (WA=0, BC=1, DE=2, HL=3, IX=4, IY=5, IZ=6, SP=7)\n- Example: .byte 0x48 → pop wa\n- Note: POP r32 (0x58-0x5F) is already handled in Tier 6.\n\n### PUSH SR (1-byte: 0x02) — 40 instances\n### POP SR (1-byte: 0x03) — 31 instances\n\n## LLVM backend status\n- PUSH r16/POP r16: Encoded as SingleByteReg format (opcode 0x28/0x48)\n- PUSH SR/POP SR: Encoded as SingleByte format (opcode 0x02/0x03)\n- All already encodable by MCCodeEmitter\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\n### Extend Tier 6 for r16\nCurrently Tier 6 handles 1-byte PUSH/POP for 32-bit registers (0x38-0x3F, 0x58-0x5F).\nExtend to also handle 16-bit (0x28-0x2F, 0x48-0x4F):\n- Register names for r16: {0:'wa', 1:'bc', 2:'de', 3:'hl', 4:'ix', 5:'iy', 6:'iz', 7:'sp'}\n- ASL mnemonic: PUSH/PUSHW for push, POP/POPW for pop\n\n### Add PUSH SR / POP SR\n- These are in Tier 1 territory (zero-operand, 1-byte). Check if already in NATIVE_ZERO_OPS.\n- If not, add: 'PUSH': ('push sr', 1) when rom_bytes[0] == 0x02, etc.\n- Actually PUSH SR has operand \"SR\", so check operands_str. Simpler: add to Tier 6 with special case for 0x02/0x03.\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check: grep -cP '^\\s+push (wa|bc|de|hl)' and grep -cP '^\\s+pop (wa|bc|de|hl)'","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:25:15.821577163-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T05:56:18.683326153-03:00","closed_at":"2026-02-22T05:56:18.683326153-03:00","close_reason":"Closed","comments":[{"id":153,"issue_id":"kn5000-nfa","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T08:52:23Z"},{"id":154,"issue_id":"kn5000-nfa","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: 2,126 native instructions added — pushw (1,294), popw (763), push_sr (39), pop_sr (30). Added 4 new LLVM instructions (PUSH16_short, POP16_short, PUSH_SR, POP_SR). Fallback: 96,134→94,008. ROM 100% byte match.","created_at":"2026-02-22T08:56:18Z"}]}
{"id":"kn5000-nmg","title":"Video: Document animation and transition effects","description":"Analyze fade-in/fade-out effects, screen transitions, any animated elements. Document: how BitmapFadeIn/FadeOut images work, timing of transitions, any hardware support for effects, scrolling implementation.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:46:04.826007987-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:30:17.525865708Z","closed_at":"2026-02-28T00:30:17.525865708Z","close_reason":"Animation and transition effects fully documented: palette fades, grid dissolves, state machine transitions, software scrolling, VGA blanking. All annotations verified with 100% byte match.","comments":[{"id":345,"issue_id":"kn5000-nmg","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on animation and transition effects documentation.","created_at":"2026-02-28T00:21:53Z"},{"id":346,"issue_id":"kn5000-nmg","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Completed. Documented:\n- Rendering pipeline (offscreen buffer → dirty tracking → VRAM blit)\n- Palette-based fade effects (ChangePalette, palette bank rotation)\n- Grid-based dissolve transitions (AcFadeSetGridBoxProc, FadeSetGridCheck)\n- Pre-computed fade data (4 ROM blobs: FadeIn/Out Picture/Text)\n- Timer-driven animation (IvOneShotTimerProc)\n- Screen transition state machine (SeqState_TransitionMode)\n- Software scrolling (MovePixels, AcRotStrBoxProc)\n- VGA screen blanking during updates\n- 11 annotated functions in kn5000_v10_program.s\n- New section in display-subsystem.md","created_at":"2026-02-28T00:30:14Z"}]}
{"id":"kn5000-nvz7","title":"LLVM converter: reduce instruction .byte fallbacks to minimum","description":"Improve the asl_to_llvm.py converter to convert more instructions to native LLVM assembly form instead of .byte fallbacks.\n\nWork completed in this session:\n1. JR/JRL/CALR operand-based label fallback: when ADDR_TO_LABEL lookup fails, use the ASL operand label name directly. Converted 8 more instructions (6 JR with local dot-labels, 1 JR to SeMenuModeFunc_Handler, 1 CALR to VGA_Extended_Init).\n2. Fixed LABEL_FE730F off-by-1 disassembly error (should be LABEL_FE7310). The converter's self-correction was forcing the address tracker to the wrong position, cascading to 12 misaligned instructions.\n3. db-to-native conversion in convert_db() for instruction-sized DB lines with ASL instruction comments.\n4. Fixed guess_mnemonics_from_opcode() missing 0x38-0x3F (PUSH r32) and 0x48-0x4F (POP r16).\n5. Pre-pass recognition of ASL labels without colons.\n6. DRIFTED_LABEL_NAMES cleanup (removed FmmIntMedleyFunc).\n\nResults: 236,776 native instructions, 8 .byte fallback lines. The 7 remaining instruction fallbacks are:\n- 2 I/O register writes (LDW to TREG4L/TREG5L - needs LLVM backend support)\n- 4 drifted Fmm labels (FmmSmfMedleyFunc, FmmPdMedleyFunc, FmmDiskMedleySelectFunc)\n- 1 JR T to CALR inside VGA_SEQUENCER macro (needs target label)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T21:06:17.382310266-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T21:06:21.636656682-03:00","closed_at":"2026-02-22T21:06:21.636656682-03:00","close_reason":"Closed"}
{"id":"kn5000-nw1y","title":"LLVM codegen: 8/16-bit native operation patterns","description":"Add ISel patterns to use native 8-bit and 16-bit ALU operations (ADD8rr, ADD16rr, etc.) for byte/word-sized data instead of always promoting to 32-bit. Particularly beneficial for tight loops operating on uint8_t/uint16_t arrays. Trade-off: only 4 registers have 8-bit sub-regs, so this needs careful register pressure analysis.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T18:48:28.582744872-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T19:07:33.046731299-03:00","closed_at":"2026-02-23T19:07:33.046731299-03:00","close_reason":"Closed","comments":[{"id":272,"issue_id":"kn5000-nw1y","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Investigating feasibility of 8/16-bit native operations.","created_at":"2026-02-23T22:03:24Z"},{"id":273,"issue_id":"kn5000-nw1y","author":"Felipe Correa da Silva Sanches","text":"INVESTIGATION COMPLETE: After thorough analysis, making i8/i16 legal types is NOT practical for TLCS-900:\n\n1. Only 4 of 8 GPR registers (XWA, XBC, XDE, XHL) have 8-bit sub-registers — severe asymmetric register pressure\n2. Calling convention forces i8/i16→i32 promotion at ABI boundaries, negating benefits\n3. Sub-register liveness tracking would complicate register allocation significantly\n4. Truncating stores and extending loads already handle mixed-width memory access efficiently\n5. Existing peephole passes (INC/DEC, BIT test, DJNZ, short LD/CP) already capture the main code-size wins\n\nAll 8/16-bit instruction definitions exist in InstrInfo.td but with empty ISel patterns (asm-only). This is intentional and correct.\n\nRECOMMENDATION: If further code-size reduction is needed in the future, targeted peephole passes for specific patterns (e.g., AND+CP→CP8 for byte comparisons) would be more appropriate than making i8/i16 legal globally. This would avoid register allocation penalties while capturing localized savings.\n\nRELEASED: Closing as won't-fix (investigation complete, current design is optimal).","created_at":"2026-02-23T22:07:29Z"}]}
{"id":"kn5000-o0o","title":"Refactor shared bootloader code between maincpu and table_data","notes":"Analysis revealed 3,561 bytes of byte-identical code between maincpu and table_data ROMs:\n\n**Shared regions:**\n| Table Data | Main CPU | Size | Content |\n|------------|----------|------|---------|\n| 0x9FCD9A-0x9FD7BD | 0xEF50DF-0xEF5B02 | 2,596 bytes | VRAM_FillRect, display routines |\n| 0x9FBC3C-0x9FBECF | 0xEF3CE0-0xEF3F73 | 660 bytes | Boot utility routines |\n| 0x9FB4F2-0x9FB622 | 0xEF03D0-0xEF0500 | 305 bytes | Boot initialization code |\n\n**Current state:**\n- maincpu: Fully disassembled with meaningful labels (VRAM_FillRect, Write_VGA_Register, etc.)\n- table_data: Same code as raw `db` bytes with comments\n\n**Refactoring approach:**\n1. Create shared include file(s) with the common source code\n2. Use position-independent code (already uses relative jumps JR, not absolute JP)\n3. Each ROM includes the shared file with appropriate ORG statement\n4. Resolve any label naming conflicts\n\n**Challenges:**\n- table_data lacks clean ORG boundaries at these regions\n- Build order dependency if extracting from assembled output\n- Need to maintain both ROMs building correctly\n\n**Benefits:**\n- Single source of truth for shared routines\n- Easier maintenance and documentation\n- Confirms original firmware was built from common codebase\n\nReference: rom-reconstruction.md \"Shared Code with Main CPU\" section","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:32:14.689543672-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:56:16.384804833-03:00","closed_at":"2026-01-31T00:56:16.384804833-03:00","close_reason":"Closed","comments":[{"id":106,"issue_id":"kn5000-o0o","author":"Felipe Correa da Silva Sanches","text":"Implemented shared bootloader code between maincpu and table_data. Created shared/ directory with sfr_tmp94c241.asm (SFR definitions) and boot_hw_init.asm (315 bytes of hardware init). Both ROMs now include the shared files, confirming the original Technics firmware was built from a common codebase. See commit 8a7956a.","created_at":"2026-01-31T03:56:16Z"}]}
{"id":"kn5000-o3u","title":"LLVM: Fix bug #11 — for-loop with uint16_t counter exits after 1 iteration","notes":"LLVM TLCS-900 backend bug #11: for-loops using uint16_t counter variables exit after only 1 iteration. Current workaround: use do-while loops with uint32_t counters. Affects VRAM clear and other iteration-heavy code. This is one of 2 remaining active bugs in the TLCS-900 backend. Tracked in Mines memory (llvm-encoding-bugs.md).","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:33:39.399688128-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T04:51:09.989489619Z","closed_at":"2026-02-28T04:51:09.989489619Z","close_reason":"Fixed: EXTS/EXTZ don't set flags on TLCS-900/H. Commit eba2fe6622ee.","comments":[{"id":107,"issue_id":"kn5000-o3u","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Bug #11 remains UNFIXED in the LLVM TLCS-900 backend. Workaround still active in Mines video.c (lines 219-228): do-while loop with uint32_t counter instead of for-loop with uint16_t. Recent LLVM work (10 commits) focused on LDIR/LDDR block transfers, peephole optimizations (BIT/SET/RES/CHG), frame pointer support, and 8-bit register encoding — none address this bug.","created_at":"2026-02-21T04:00:56Z"},{"id":108,"issue_id":"kn5000-o3u","author":"Felipe Correa da Silva Sanches","text":"INVESTIGATION (Feb 21): Examined LLVM backend codegen for i16 loop counter. Key findings: (1) Type legalization: PromoteIntOp_BR_CC calls SExtOrZExtPromotedOperands which should zero-extend i16→i32 via AND 0xFFFF before comparison. (2) Flag modeling: All ALU/CMP instructions correctly declare Defs=[SR], conditional branches correctly declare Uses=[SR]. Store instructions (LD*mr) don't declare Defs=[SR], which is correct since TLCS-900 LD doesn't modify flags. (3) The workaround suggests carry flag is broken but zero flag works: do-while uses SUB+JR_NZ (zero flag), while for-loop uses CP+JR_ULT (carry flag). Possible root causes: (a) CP32ri encoding produces wrong carry flag result, (b) condition code corruption between CP and JPcc, (c) zero-extension AND 0xFFFF optimized away by DAG combiner leaving garbage upper bits that affect 32-bit comparison. Cannot diagnose further without compiling test code. Key files: TLCS900ISelLowering.cpp:104-107 (BR_CC/SETCC actions), TLCS900ISelLowering.cpp:245-258 (LowerBR_CC), TLCS900InstrInfo.td:545-561 (CP32 patterns), LegalizeIntegerTypes.cpp:PromoteIntOp_BR_CC. NEXT STEP: Write minimal test .ll file and compile through backend to inspect generated asm.","created_at":"2026-02-21T06:20:39Z"},{"id":368,"issue_id":"kn5000-o3u","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting investigation of for-loop uint16_t bug. Will write minimal test case and trace through codegen.","created_at":"2026-02-28T04:35:49Z"},{"id":369,"issue_id":"kn5000-o3u","author":"Felipe Correa da Silva Sanches","text":"FIXED: Root cause was EXTS32/EXTZ32 declared with Defs=[SR] in TLCS900InstrInfo.td, but these instructions do NOT set flags on TLCS-900/H hardware (confirmed via MAME). The RedundantCmpElim pass was incorrectly removing CP instructions after EXTZ, leaving conditional branches to read stale flags. Fix: moved EXTS32/EXTZ32 out of the Defs=[SR] block and removed from isFlagSettingDef(). Commit eba2fe6622ee.","created_at":"2026-02-28T04:51:06Z"}]}
{"id":"kn5000-o6jd","title":"LLVM: Support symbolic condition codes in callcc_24 and jpcc_24","description":"The callcc_24 and jpcc_24 instructions require numeric condition codes (e.g., 'callcc_24 14, addr' for CALL NZ). They should accept symbolic names like 'call nz, addr' or 'jp z, addr' matching standard TLCS-900 assembly syntax. The assembler already parses condition codes for jr/jrl but not for the F2-prefixed 24-bit address variants. 8 jpcc_24 + 1 callcc_24 = 9 instances currently.","status":"closed","priority":1,"issue_type":"feature","owner":"juca@members.fsf.org","created_at":"2026-02-26T02:26:03.373680097Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T10:48:36.708256373Z","closed_at":"2026-02-27T10:48:36.708256373Z","close_reason":"Implemented symbolic condition codes: callcc_24→call_24, jpcc_24→jp_24. Uses cc operand type (same as jr/jrl). 384 instances converted across all ROMs. 100% byte match.","comments":[{"id":312,"issue_id":"kn5000-o6jd","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-27T10:44:19Z"}]}
{"id":"kn5000-otg7","title":"LLVM converter: JR T $+2 delay NOP has no target label (30 fallbacks)","description":"jr T, $+2 (opcode 0x68 0x00) is used as a delay NOP (jump to next instruction). Tier 8 fails because no label exists at addr+2. Fix: detect displacement=0 and emit a synthetic local label. Affects subcpu_boot (28) and table_data (2).","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:18.607877905-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:18:49.277166166-03:00","closed_at":"2026-02-23T08:18:49.277166166-03:00","close_reason":"Closed","comments":[{"id":233,"issue_id":"kn5000-otg7","author":"Felipe Correa da Silva Sanches","text":"FIXED: Added synthetic forward label mechanism. When d8==0 and cc==8, converter creates __jrt_nop_XXXXXX labels emitted before the next instruction. All 30 fallbacks (28 subcpu_boot + 2 table_data) resolved.","created_at":"2026-02-23T11:18:49Z"}]}
{"id":"kn5000-ov84","title":"LLVM converter: Fix unresolved JR/JRL branch labels (~1,500 .byte)","description":"About 1,500 JR/JRL relative branch instructions remain as .byte fallback because their target addresses are not found in ADDR_TO_LABEL. These are instructions in opcode range 0x60-0x7F where the converter correctly decodes the relative offset and computes the target address, but the label table doesn't contain an entry for that address. Possible causes: (1) targets are inside data sections that lack labels, (2) local labels generated by ASL that weren't captured, (3) computed addresses off by alignment. Need to investigate why these specific branch targets lack labels and fix the label table generation.","status":"closed","priority":2,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:08:59.388247109-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T19:11:49.284587815-03:00","closed_at":"2026-02-22T19:11:49.284587815-03:00","close_reason":"Closed","comments":[{"id":212,"issue_id":"kn5000-ov84","author":"Felipe Correa da Silva Sanches","text":"CLOSED as duplicate of kn5000-6nst. Original estimate of ~1,500 was inflated — most JR/JRL-looking .byte lines are data bytes, not branch instructions. Only 74 actual branch fallbacks remain near code after EQU inline label work. See kn5000-6nst for details.","created_at":"2026-02-22T22:11:49Z"}]}
{"id":"kn5000-p2c","title":"Document all serial command bytes and their purposes","description":"Analyze maincpu code to catalog all 2-byte command sequences sent to control panel MCUs. Commands seen so far: 1f/1d/1e/dd (init), 20/25/2b (data), e0/e2/e3/eb (extended). Map each command to its purpose and expected response.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T03:10:21.700881797-03:00","created_by":"fsanches","updated_at":"2026-02-27T22:26:06.466964053Z","closed_at":"2026-02-27T22:26:06.466964053Z","close_reason":"All 16 serial command bytes documented with EQU constants in cpanel_constants.s. Protocol doc updated with correct addresses, E0 13 steady-state poll, and LED command reference. Assembly .byte fallback at LABEL_FC4124 converted to native DELAY_2_TICKS. Absolute calls replaced with label references. 100% byte match verified.","comments":[{"id":109,"issue_id":"kn5000-p2c","author":"fsanches","text":"Known control panel serial commands (from docs/cpanel_protocol_analysis.txt):\n\n**Command Format:** 2 bytes: command_byte + parameter_byte\n\n**Commands documented:**\n| Command | Param | Description |\n|---------|-------|-------------|\n| 0x1D | 0x00 | Setup/init command |\n| 0x1E | 0x80 | Setup command |\n| 0x1F | 0xDA | Setup - LED related? |\n| 0x1F | 0x1A | Setup - LED related? |\n| 0x20 | 0x00 | Test/probe (check if MCU responds) |\n| 0x20 | 0x0B | Read data, affects button state bits 6-7 |\n| 0x20 | 0x10 | Read data |\n| 0x25 | 0x01 | Setup command |\n| 0x2B | 0x00 | Read something |\n| 0xDD | 0x03 | Setup command |\n| 0xE0 | 0x00 | Test/probe (check if MCU responds) |\n| 0xE2 | 0x04 | Setup/read |\n| 0xE2 | 0x11 | Setup/read |\n| 0xE3 | 0x10 | Read data |\n| 0xEB | 0x00 | Read something |\n\n**Timing:** Commands use 6-tick delays or multiples (6, 12, 18 ticks)\n\n**Response handling:**\n- LABEL_FC4915: Interprets received data\n- LABEL_FC490E: Alternative data interpreter\n- Both set CP_Flags_A.2 but nothing reads that flag","created_at":"2026-01-26T10:35:37Z"},{"id":110,"issue_id":"kn5000-p2c","author":"fsanches","text":"**Naming update (2026-01-26):**\n\nResponse handling routines renamed:\n- LABEL_FC4915 → CPanel_RX_Process\n- LABEL_FC490E → CPanel_RX_ProcessWithFlag\n- CP_Flags_A → CPANEL_TX_RX_FLAGS\n\nSee control-panel-protocol.md for complete protocol documentation including all commands and responses.","created_at":"2026-01-27T01:09:25Z"},{"id":111,"issue_id":"kn5000-p2c","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 21): Serial command documentation enriched through MAME driver development. Recent MAME commits show: sync/ping response on 0xE0/0x20 (param=0x00), boot-time response fixes (send_byte), stale poll response fixes via INTA, Computer Interface wired on SubCPU serial port 1. The Another World port attempts 27-43 extensively tested button packets for extended segments and full button state reporting.","created_at":"2026-02-21T04:02:03Z"},{"id":324,"issue_id":"kn5000-p2c","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting comprehensive serial command byte documentation.","created_at":"2026-02-27T22:10:08Z"}]}
{"id":"kn5000-pb3w","title":"LLVM converter: Native CP/BIT/SET/RES short forms (~9,427 instructions)","description":"## Goal\nConvert short-form CP (compare with small immediate 0-7), BIT, SET, and RES from .byte fallback to native LLVM.\n\n## Instruction forms\n\n### CP reg, N (2-byte short form: prefix + 0xD8+N) — ~3,549 instances\nShort compare with immediate 0-7, encoded in the sub-opcode:\n- prefix = C8+r (8-bit), D8+r (16-bit), E8+r (32-bit)\n- sub-opcode = 0xD8 + N (where N = 0..7)\n- Example: .byte 0xc9, 0xd9 → cp a, 1\n- Example: .byte 0xdb, 0xd8 → cp hl, 0\n\n### BIT n, reg (3-byte: prefix + 0xC8 + bit_number) — 2,495 instances\n- prefix = C8+r / D8+r / E8+r (register prefix)\n- sub-opcode = 0xC8 (BIT opcode in sub-table)\n- third byte = bit number (0-31 for 32-bit, 0-15 for 16-bit, 0-7 for 8-bit)\n- Example: .byte 0xc9, 0xc8, 0x07 → bit 7, a\n- Note: Many BIT instructions use memory operands (e.g., BIT n, (addr)) — those are different encoding and should be left as fallback for now.\n\n### SET n, reg (3-byte: prefix + 0xB8 + bit_number) — 528 instances\n### RES n, reg (3-byte: prefix + 0xB0 + bit_number) — 647 instances\n- Same encoding as BIT but different sub-opcodes\n\n## LLVM backend status\n- CP short form: Would need a new format or adaptation of PrefixIncDec-style encoding\n- BIT/SET/RES register forms: Already supported as PrefixBit format\n- All formats supported by MCCodeEmitter\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\n### CP short form (2-byte)\n- Already partially handled in Tier 3? Check if CP reg,reg is there. The SHORT form (CP reg, 0-7) is different — it's prefix + 0xD8+N.\n- Add to Tier 3 area or new sub-tier for 2-byte prefix instructions.\n- Check: nbytes == 2, prefix in reg prefix range, sub-opcode in 0xD8-0xDF\n- N = sub_opcode - 0xD8\n- Emit: cp \u003creg\u003e, \u003cN\u003e\n\n### BIT/SET/RES register form (3-byte)\n- Check: nbytes == 3, prefix in reg prefix range\n- BIT: sub-opcode == 0xC8, RES: sub-opcode in 0xB0-0xB7 (B0+bit??), SET: sub-opcode in 0xB8-0xBF\n- Actually: BIT/SET/RES use prefix + opcode + bit_number (3 bytes)\n- BIT sub-opcode = 0xC8, SET = varies, RES = varies. Check sub-opcode tables.\n- Mnemonic: mnem_upper in ('BIT', 'SET', 'RES', 'CHG', 'TSET')\n\n## Caution\n- Memory-operand forms (BIT n, (addr)) use different prefixes (F0/F1/F2 etc). Don't match those.\n- Only match register prefixes: 0xC8-0xCF, 0xD8-0xDF, 0xE8-0xEF\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check counts for cp, bit, set, res","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:25:57.14088567-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T06:07:52.263859564-03:00","closed_at":"2026-02-22T06:07:52.263859564-03:00","close_reason":"Closed","comments":[{"id":157,"issue_id":"kn5000-pb3w","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T09:01:24Z"},{"id":158,"issue_id":"kn5000-pb3w","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Completed. Added CP small-imm (cps, PrefixSmallImm\u003c0xD8\u003e) to LLVM for all 3 sizes. Added BIT8/SET8/RES8 to LLVM. Removed isCodeGenOnly from BIT16/SET16/RES16/CHG16. Added converter Tiers 16 (CP short-form) and 17 (BIT/SET/RES register). Results: 4,388 new native instructions (3,273 cps + 720 bit + 119 set + 276 res). Fallback: 87,032. 100% byte-match.","created_at":"2026-02-22T09:07:49Z"}]}
{"id":"kn5000-pcq","title":"Images: Extract all images as binary files","description":"Create extraction script to dump all identified images as individual binary files. Output to maincpu/images/ and table_data/images/ directories. Name files descriptively based on apparent purpose (icon_play.bin, splash_logo.bin, etc.). Generate manifest listing all extracted images.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:37:56.934332274-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:45:46.925014978Z","closed_at":"2026-02-27T23:45:46.925014978Z","close_reason":"Already complete. All images extracted as binary files: 44 in maincpu/images/ (BitmapKN5000Logo.bin, BitmapTechnicsLogo.bin, 13 SplitPoint, 3 DrawbarSliders, 3 MIDI, 8 system update, etc.), 6 FTBMP BMPs + 2 wallpapers + 176 icon PNGs in table_data/images/. Assembly uses .incbin directives referencing all files. convert_images.py script handles conversion."}
{"id":"kn5000-pdzd","title":"LLVM: Rare register prefix sub-opcodes (C8-EF) — 250 instructions","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T16:21:01.345445536-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T17:43:02.558989485-03:00","closed_at":"2026-02-22T17:43:02.558989485-03:00","close_reason":"Closed","comments":[{"id":193,"issue_id":"kn5000-pdzd","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on rare register prefix sub-opcodes.","created_at":"2026-02-22T20:11:40Z"},{"id":194,"issue_id":"kn5000-pdzd","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: All 250 extpfx register prefix (C8-EF) instructions converted to semantic mnemonics. Added 27 new LLVM definitions (UNLK32, XORCF_A, STCF_A, MUL/MULS/DIV/DIVS 8-bit rr, EX 8/16, LINK32, MINC1/MINC4, LDC_CR, RLC/RRC_I, DJNZ16). 0 extpfx remain. 100% byte-match. RELEASED.","created_at":"2026-02-22T20:42:56Z"}]}
{"id":"kn5000-pgur","title":"Feature Demo: Lua script to simulate user input and trigger SSF presentation in MAME","description":"Implement and test a MAME Lua autoboot script (ftdemo_activate.lua) that simulates the DEMO button press via MAME input ports and injects the assswb buffer to trigger the Feature Demo SSF presentation without manual user interaction.","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-03-01T08:26:36.769237221Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-03-01T08:26:36.769237221Z"}
{"id":"kn5000-pkx","title":"Images: Convert images to viewable formats","description":"Create conversion tools to export extracted images as PNG/BMP for documentation. Handle any custom palette or pixel format. Add converted images to documentation website for reference. Useful for identifying what each image represents.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:37:57.72208918-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:28.800036145Z","closed_at":"2026-02-27T23:48:28.800036145Z","close_reason":"Already complete. convert_images.py handles conversion to PNG/BMP. Image gallery deployed at docs website (image-gallery.md) with 44 main CPU images, 6 FTBMPs, 2 wallpapers, 176 icons (sprite sheet + individual PNGs), 4 HDAE5000 images. Palettes documented (0xEB37DE main, 0x65dce HDAE5000)."}
{"id":"kn5000-psz","title":"Update: Document floppy disk file formats","description":"Analyze the system update floppy disk structure. Document: file naming conventions (KN5KPV*.EXE pattern), file header format, payload structure, checksums/validation, compression if any. Reference update disks at archive.org.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T05:34:37.010912476-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:39:12.015277969-03:00","closed_at":"2026-01-26T08:39:12.015277969-03:00","close_reason":"Closed","comments":[{"id":112,"issue_id":"kn5000-psz","author":"fsanches","text":"**Update Floppy Disk File Formats (from firmware analysis):**\n\n**File Type Identifiers (38-byte header strings at 0xE00038):**\n\n| ID | Header String | Description |\n|----|---------------|-------------|\n| 1 | \"Technics KN5000 Program  DATA FILE 1/2\" | Main CPU ROM disk 1 |\n| 2 | \"Technics KN5000 Program  DATA FILE 2/2\" | Main CPU ROM disk 2 |\n| 3 | \"Technics KN5000 Table    DATA FILE 1/2\" | Table data ROM disk 1 |\n| 4 | \"Technics KN5000 Table    DATA FILE 2/2\" | Table data ROM disk 2 |\n| 5 | \"Technics KN5000 CMPCUSTOMDATA FILE    \" | Custom data (compressed?) |\n| 6 | \"Technics KN5000 HD-AEPRG DATA FILE    \" | HD-AE5000 expansion ROM |\n| 7 | \"Technics KN5000 Program  DATA FILE PCK\" | Main CPU ROM (packed) |\n| 8 | \"Technics KN5000 Table    DATA FILE PCK\" | Table data ROM (packed) |\n\n**File Structure:**\n- 38-byte identification header string\n- Null terminator (0x00)\n- 0xFF marker byte\n- Payload data follows\n\n**Handler Dispatch Table (0xE00178):**\nEach file type has a handler routine offset. Types 2 and 4 (disk 2/2) show \"SHOW_ILLEGAL_DISK_MESSAGE\" - must insert disk 1 first.\n\n**Naming Convention:**\nFiles on update disks follow KN5KPV*.EXE pattern (from archive.org reference).\n\n**PCK variants:** \"DATA FILE PCK\" suggests packed/compressed format vs split 1/2 + 2/2 format.\n\n**FDC Interface:**\n- FDC_MAP__BASE_ADDR = 0x110000\n- FDC__DMA_ACKNOWLEDGE = 0x120000\n\nStatus: File types and headers documented from firmware strings.","created_at":"2026-01-26T11:24:01Z"},{"id":113,"issue_id":"kn5000-psz","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Update File Formats' section with documented file type table (8 types), header format, and relationship to system components. Currently generic description.","created_at":"2026-01-26T11:32:52Z"},{"id":114,"issue_id":"kn5000-psz","author":"fsanches","text":"Website updated: reverse-engineering.md 'Update File Formats' section now documents all 8 file type IDs with header strings, file structure (38-byte header), and handler dispatch at 0xE00178.","created_at":"2026-01-26T11:39:11Z"}]}
{"id":"kn5000-q1wm","title":"HDAE5000 FS: Document on-disk format (FSB/FGB/FEB structures)","description":"Create comprehensive documentation of the HDAE5000 custom filesystem on-disk format. Based on disassembled routines, document: (1) FSB structure — master metadata block layout, 24 entries x 21 bytes, (2) FGB structure — file group block format, (3) FEB structure — file entry block format, (4) Partition table layout — up to 16 partitions, (5) Sector allocation scheme — 7-bit VarInt encoding, (6) Directory entry format — 9-byte entries sorted by name, max 40 per partition, (7) File type codes and mappings. Depends on FS_Init and FS_Write_FSB disassembly for complete picture.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:29:58.629664583Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T22:07:49.280546396Z","closed_at":"2026-02-27T22:07:49.280546396Z","close_reason":"Documented FSB on-disk format: multi-sector layout (Sectors 0-4), 21-byte in-RAM and 37-byte on-disk directory entries, 9-byte partition directory entries, PPORT transfer packet with 9 region descriptors, 30+ RAM addresses mapped. FGB/FEB internal structure still partially understood — tracked by sub-issues.","dependencies":[{"issue_id":"kn5000-q1wm","depends_on_id":"kn5000-gkhu","type":"blocks","created_at":"2026-02-26T12:30:21.201132512Z","created_by":"Felipe Correa da Silva Sanches"},{"issue_id":"kn5000-q1wm","depends_on_id":"kn5000-6abu","type":"blocks","created_at":"2026-02-26T12:30:21.361710835Z","created_by":"Felipe Correa da Silva Sanches"}],"comments":[{"id":323,"issue_id":"kn5000-q1wm","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on filesystem on-disk format documentation.","created_at":"2026-02-27T21:55:05Z"}]}
{"id":"kn5000-q51","title":"Review deferred DMA macro renames in tmp94c241.inc (DMAC↔DMAM)","description":"Three DMA macro renames from the sound subsystem worktree salvage were deferred because they require updating tmp94c241.inc to define new macro names before the assembly can use them.\n\nThe sound worktree had corrected these macro names to match the actual TMP94C241F DMA register semantics (DMAC = counter registers at CR offsets 0x40/0x44/0x48/0x4C, DMAM = mode registers at CR offsets 0x42/0x46/0x4A/0x4E):\n\n1. LDC_DMAC2_XWA → LDC_DMAM2_A (writes CR offset 0x4A = mode register, not counter)\n2. LDC_DMAC0_A → LDC_DMAM0_A (writes CR offset 0x42 = mode register, not counter)\n3. LDC_WA_DMAM0 → LDC_WA_DMAC0 (reads CR offset 0x40 = counter register, not mode)\n\nSteps:\n- Add LDC_DMAM2_A, LDC_DMAM0_A, and LDC_WA_DMAC0 macros to tmp94c241.inc (with correct byte encodings from the sound worktree version)\n- Optionally remove or deprecate the incorrectly-named duplicates (LDC_DMAC2_XWA, LDC_DMAC0_A, LDC_WA_DMAM0)\n- Update subcpu/kn5000_subprogram_v142.asm to use the corrected names\n- Build and verify 100% byte-match with compare_roms.py\n\nContext: see scripts/rename_subcpu_dsp_labels.sed comments for the deferred rules.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T06:25:56.445557622-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T06:54:30.240283672-03:00","closed_at":"2026-02-21T06:54:30.240283672-03:00","close_reason":"Closed","comments":[{"id":133,"issue_id":"kn5000-q51","author":"Felipe Correa da Silva Sanches","text":"Macro definitions from sound worktree tmp94c241.inc (to be added to roms-disasm):\n\nLDC_DMAM0_A MACRO\n\tdb 0c9h, 2eh, 42h\t; LDC DMAM0, A (DMA channel 0 mode)\n\tENDM\n\nLDC_DMAM2_A MACRO\n\tdb 0c9h, 2eh, 4ah\t; LDC DMAM2, A (DMA channel 2 mode)\n\tENDM\n\nLDC_WA_DMAC0 MACRO\n\tdb 0d8h, 2fh, 40h\t; LDC WA, DMAC0 (read DMA channel 0 count)\n\tENDM\n\nThese replace the incorrectly-named macros in roms-disasm:\n- LDC_DMAC0_A  (0c9h,2eh,42h) → rename to LDC_DMAM0_A (writes mode reg, not counter)\n- LDC_DMAC2_XWA (0c9h,2eh,4ah) → rename to LDC_DMAM2_A (writes mode reg, not counter)\n- LDC_WA_DMAM0 (0d8h,2fh,40h) → rename to LDC_WA_DMAC0 (reads counter reg, not mode)","created_at":"2026-02-21T09:28:03Z"},{"id":134,"issue_id":"kn5000-q51","author":"Felipe Correa da Silva Sanches","text":"Additional DMA macro renames needed beyond subcpu (same root cause):\n\n=== maincpu/fdc_routines.asm (4 changes) ===\nLine 407: LDC_DMAM3_BC → LDC_DMAC3_BC (writes CR offset 0x4C = counter register, not mode)\nLine 445: LDC_DMAC3_A  → LDC_DMAM3_A  (writes CR offset 0x4E = mode register, not counter)\nLine 454: LDC_DMAC3_A  → LDC_DMAM3_A  (same)\nLine 457: LDC_DMAM3_BC → LDC_DMAC3_BC (same as line 407)\n\nRequires adding to tmp94c241.inc:\nLDC_DMAM3_A MACRO\n\tdb 0c9h, 2eh, 4eh\t; LDC DMAM3, A (DMA channel 3 mode)\n\tENDM\n\nAnd renaming the existing incorrectly-named macro:\nLDC_DMAM3_BC (0d9h, 2eh, 4ch) → LDC_DMAC3_BC (writes counter, not mode)\n\n=== subcpu/boot/kn5000_subcpu_boot.asm (2 changes) ===\nLine 742: LDC_DMAC2_A → LDC_DMAM2_A (writes CR offset 0x4A = mode register, not counter)\nLine 746: LDC_DMAC0_A → LDC_DMAM0_A (writes CR offset 0x42 = mode register, not counter)\n\nThese use the same LDC_DMAM2_A and LDC_DMAM0_A macros already documented above.","created_at":"2026-02-21T09:38:01Z"},{"id":135,"issue_id":"kn5000-q51","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-21T09:50:22Z"},{"id":136,"issue_id":"kn5000-q51","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Issue resolved. All 9 DMA macro renames applied across tmp94c241.inc, subcpu, subcpu boot, fdc_routines, and maincpu. Duplicates removed from include file. All 6 ROMs 100% byte-match. Commit 4896fbf.","created_at":"2026-02-21T09:54:29Z"}]}
{"id":"kn5000-q70f","title":"LLVM converter: INCW/SRLW with (XSP+d) addressing not handled (7 fallbacks)","description":"INCW n,(XSP+offset) opcode 0x9F prefix: 6 fallbacks. SRLW (XSP+d): 1 fallback. Plus INCW n,(addr) direct: 1 fallback. Converter tiers don't handle these addressing modes. All in table_data.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.3506094-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:19:01.783417697-03:00","closed_at":"2026-02-23T08:19:01.783417697-03:00","close_reason":"Closed","comments":[{"id":238,"issue_id":"kn5000-q70f","author":"Felipe Correa da Silva Sanches","text":"NOT A REAL FALLBACK: These INCW/SRLW instructions are written as raw 'db' bytes in the ASL source. They're intentional data directives preserved as .byte in the LLVM output. Closing as invalid.","created_at":"2026-02-23T11:19:01Z"}]}
{"id":"kn5000-q7xb","title":"HDAE5000 FS: Annotate FS_Read_FSB with field-level comments","description":"The FS_Read_FSB routine (832 bytes at 0x287F55) is already disassembled but needs deeper annotation. Add field-level comments identifying: what each of the 24 x 21-byte directory entries contains, which fields are filenames/sizes/CHS addresses/type codes, what the template data at ROM 0x2E2E60 represents, and how the event handlers (0x07, 0x3A, 0x7C, 0x84, 0x86) relate to UI interaction.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-26T12:30:03.004378187Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-27T23:28:54.151582375Z","closed_at":"2026-02-27T23:28:54.151582375Z","close_reason":"Complete. Added field-level annotations to all 3 parts of FS_Read_FSB (832 bytes): (1) Init loop: 21-byte entry layout documented, ROM template format, entry number formatting via PPI_Block_Copy, 16-byte VRAM tile upload. (2) Handler A: all 5 events annotated (0x3A read tile, 0x86 write+clear, 0x7C query=16, 0x84 no-op, 0x07 action with sub-codes 0x0B navigate and 0x8A validate). (3) Handler B: same events, right pane saves via FS_Write_FSB. UI vtable offsets documented (0x0124, 0x050C, 0x0100). ROM verified 100% byte-match.","comments":[{"id":331,"issue_id":"kn5000-q7xb","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting field-level annotation of FS_Read_FSB.","created_at":"2026-02-27T23:25:08Z"}]}
{"id":"kn5000-qea","title":"Mines: Re-enable control panel input for gameplay","notes":"The Mines homebrew game renders correctly on the KN5000 LCD but input is disabled (early return at input.c:64). Next steps: (1) Re-enable control panel input, (2) Implement firmware-mediated input via workspace UI callbacks, (3) Handle game exit and return display to firmware. Related: HDAE5000 extension board interface, workspace pointer system documented in Mines CLAUDE.md.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:33:32.730608438-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-24T03:44:02.881886224-03:00","closed_at":"2026-02-24T03:44:02.881886224-03:00","close_reason":"Closed","comments":[{"id":115,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Input remains disabled (early return at input.c:64). Display subsystem is now working well — framebuffer layout, palette, and pixel format all confirmed. The Mines game renders (albeit with garbled tiles). Re-enabling input is the next logical step after fixing the graphics. Depends on understanding the firmware workspace UI callback mechanism and the control panel serial protocol (which has seen major progress in MAME and custom-roms).","created_at":"2026-02-21T04:01:47Z"},{"id":277,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Implementing cooperative multitasking for input support. Progress: (1) Confirmed JP opcode 0x1B is correct for TLCS-900/H2 (verified against MAME execution tables). Previous Test 3 failure was a logic error (activation set GAME_INITIALIZED without calling main, so resume had no valid return address), not an encoding bug. (2) Implemented real cooperative architecture: Frame_Handler saves firmware SP, inits C, calls main() on first activation; yield_to_firmware saves game regs+SP, restores firmware; resume path restores game regs+SP and returns to game code. (3) input.c reads firmware RAM at 0x8E4A/0x8E5A with 32-bit aligned loads. (4) idle_update() calls yield_to_firmware(). Build succeeds. Ready for interactive testing.","created_at":"2026-02-24T02:58:44Z"},{"id":278,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"ROOT CAUSE FOUND (Feb 24): The cooperative multitasking was working correctly all along — stack switching, C runtime, yields — all fine. The bug was in assembly test loops that used 'dec 1, xbc' followed by 'jrl nz' for VRAM clearing. On TLCS-900/H, 16/32-bit INC/DEC instructions do NOT set flags (only 8-bit INC/DEC set flags). This caused infinite loops that prevented Frame_Handler from returning, killing the firmware event loop. Fix: Use 'sub xbc, 1' instead of 'dec 1, xbc' for counter loops (SUB always sets flags). Added assembly clear_vram routine using SUB. Re-enabled palette loading and VRAM clear. Game now runs: 6781 gameplay_update frames in 30-second test, cooperative multitasking works. Remaining issue: display ownership — firmware overwrites VRAM between Frame_Handler calls, so game graphics aren't visible. This is a separate issue from the event loop bug.","created_at":"2026-02-24T05:49:52Z"},{"id":281,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Event loop death fixed. Root cause: TLCS-900/H 16/32-bit INC/DEC don't set flags. Assembly clear_vram using SUB instead of DEC. Game loop fully operational (6781 gameplay_update frames per 30s test). Remaining display ownership issue tracked in kn5000-gaha.","created_at":"2026-02-24T05:50:55Z"},{"id":284,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"Display ownership also resolved (kn5000-gaha closed). Per-frame redraw (palette + VRAM clear + full minefield) ensures game is visible on LCD. Game renders correctly — screenshot confirmed at t=25s. Remaining work: test interactive input (control panel buttons → game navigation). Input code exists (input.c reads firmware RAM at 0x8E4A/0x8E5A), needs testing with interactive MAME session.","created_at":"2026-02-24T06:40:46Z"},{"id":285,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Continuing with input testing. Display ownership resolved. Now testing control panel input.","created_at":"2026-02-24T06:41:56Z"},{"id":286,"issue_id":"kn5000-qea","author":"Felipe Correa da Silva Sanches","text":"INPUT VERIFIED WORKING (Feb 24). Lua script injects button states to firmware RAM (0x8E4E for directions, 0x8E5E for OPEN/FLAG). Game responds correctly: cursor moves via RIGHT/DOWN, OPEN triggers flood-fill cascade revealing numbered cells, mine hit shows explosion and transitions to game-over state. Full game flow verified: title→playing→game_over. MAME screenshot confirms all visual elements rendering correctly (opened cells with numbers, mine explosions, flags, cursor, grid borders on black background). Remaining: QUIT button handling for clean exit to firmware.","created_at":"2026-02-24T06:43:57Z"}]}
{"id":"kn5000-qgz3","title":"LLVM converter: single-byte opcode tiers for LD r32/#imm, PUSH/POP r32, PUSH #imm, LDA (~2.5K .byte)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T15:11:05.339966105-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T15:53:49.405487167-03:00","closed_at":"2026-02-22T15:53:49.405487167-03:00","close_reason":"Closed","comments":[{"id":175,"issue_id":"kn5000-qgz3","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T18:45:09Z"},{"id":176,"issue_id":"kn5000-qgz3","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Single-byte opcodes (LD r32, PUSH/POP r32) were already converted in earlier sessions. Additionally categorized 560 remaining extpfx into semantic addressing mode instructions (sd16/sd24/spd/dd16/dd24/dpd + memory prefix mri/mrd). Remaining 250 extpfx are register prefix with rare sub-opcodes. RELEASED.","created_at":"2026-02-22T18:53:45Z"}]}
{"id":"kn5000-qhm","title":"Design MAME HLE device for control panel","description":"Based on protocol documentation, design the C++ interface for a MAME HLE device that emulates control panel MCU behavior. Define state machine, command handlers, and input/output bindings.","notes":"MAME HLE device for control panel based on protocol reverse engineering.\n\n**Current state:** Protocol fully documented, HLE partially implemented in MAME PR.\n\n**Required work:**\n- Complete button input handling\n- Implement LED output state\n- Add encoder input support\n- Test with actual firmware execution\n\n**Phase:** 2 - Core Functionality\n**Blocks:** User input in emulator\n**Dependencies:** Control panel protocol (complete)\n**Related:** kn5000-9ye (protocol RE), kn5000-j3c (button mapping)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T03:10:49.139944137-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:19:20.964193279Z","closed_at":"2026-02-27T23:19:20.964193279Z","close_reason":"Complete. HLE device fully designed and implemented on kn5000_aided_by_claude branch (940+125 lines in kn5000_cpanel.cpp/.h). Design includes: serial protocol state machine, 2-byte command parsing, boot-time inline responses, INTA-driven button change notifications, 7ms periodic scan with debouncing, phantom byte suppression, LED row-based output, self-clocking response delivery. Only missing piece is encoder input (Type 2 packets) which is a separate implementation task.","dependencies":[{"issue_id":"kn5000-qhm","depends_on_id":"kn5000-p2c","type":"blocks","created_at":"2026-01-25T03:11:19.062425742-03:00","created_by":"fsanches"},{"issue_id":"kn5000-qhm","depends_on_id":"kn5000-j3c","type":"blocks","created_at":"2026-01-25T03:11:19.846462606-03:00","created_by":"fsanches"},{"issue_id":"kn5000-qhm","depends_on_id":"kn5000-ljl","type":"blocks","created_at":"2026-01-25T03:11:20.736351418-03:00","created_by":"fsanches"},{"issue_id":"kn5000-qhm","depends_on_id":"kn5000-unb","type":"blocks","created_at":"2026-01-25T03:11:21.5173137-03:00","created_by":"fsanches"}],"comments":[{"id":327,"issue_id":"kn5000-qhm","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work. All blockers resolved. Will review current MAME driver state and identify remaining HLE work.","created_at":"2026-02-27T23:16:09Z"}]}
{"id":"kn5000-qiw4","title":"Mines: Remove LLVM bug workarounds from video.c","description":"All LLVM TLCS-900 bugs (#8, #9, #10, #11) are now fixed or resolved. Remove C-level workarounds: (1) 32-bit tile copy → byte-level (Bug #8), (2) noinline tile_vram_ptr → inline tile_vram_offset (Bug #10), (3) palette auto-increment → per-iteration index write (Bug #8/#9). Rebuild Mines and test on MAME.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-28T05:04:02.982346431Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T05:32:27.356893953Z","closed_at":"2026-02-28T05:32:27.356893953Z","close_reason":"All workarounds removed from video.c. Verified on MAME: game renders correctly with byte-level tile access and inlined tile_vram_offset.","comments":[{"id":372,"issue_id":"kn5000-qiw4","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on removing workarounds.","created_at":"2026-02-28T05:04:06Z"}]}
{"id":"kn5000-qjx","title":"FeatureDemo: Locate embedded MIDI data","description":"Find all embedded MIDI files in the ROM. Search for MIDI headers (4D 54 68 64 = 'MThd'). Document: offset, size, apparent purpose (demo song, UI sound, jingle). May be in main CPU ROM or table data ROM.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:58:21.590345012-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:16:29.527429382Z","closed_at":"2026-02-28T01:16:29.527429382Z","close_reason":"Search complete. Only 1 MIDI file found: empty 22-byte placeholder at 0xF2823E. Demo songs are generated from Rhythm ROM patterns, not stored as MIDI files.","comments":[{"id":366,"issue_id":"kn5000-qjx","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Searching for MIDI headers (MThd = 4D 54 68 64) in ROM binaries.","created_at":"2026-02-28T01:15:33Z"},{"id":367,"issue_id":"kn5000-qjx","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Searched all ROM binaries for MThd headers. Found only 1 valid MIDI file at program ROM offset 0x12823E (CPU addr 0xF2823E): format 0, 1 track, 96 PPQ, but track length = 0 bytes (empty placeholder, 22 bytes total). No other embedded MIDI files exist in the firmware. Demo songs are NOT stored as Standard MIDI Files — they are generated in real-time by the rhythm engine from pattern data in the 4MB Rhythm ROM.","created_at":"2026-02-28T01:16:29Z"}]}
{"id":"kn5000-qnf","title":"HDAE5000: Analyze HD-TechManager5000 software","description":"Reverse engineer the Windows HD-TechManager5000 software to understand the PC side of the parallel port protocol. Extract command definitions, file format handling, and UI functionality. Installation disks available at archive.org.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-25T04:33:17.280875183-03:00","created_by":"fsanches","updated_at":"2026-01-25T04:33:17.280875183-03:00"}
{"id":"kn5000-qtl","title":"Update: Document key combinations for update mode","description":"Find and document the key press combinations needed to enter system update mode. Check for: power-on key combos, button sequences, service mode entry. Trace the code that detects these combinations in main CPU firmware.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T05:34:39.169641626-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:39:16.079408085-03:00","closed_at":"2026-01-26T08:39:16.079408085-03:00","close_reason":"Closed","comments":[{"id":116,"issue_id":"kn5000-qtl","author":"fsanches","text":"**Update Mode Entry (from RESET_HANDLER at 0xEF05C5):**\n\n**Entry Conditions (all must be true):**\n1. Firmware version = 0xFF (running from internal boot ROM, not flash)\n2. Floppy disk inserted (Check_for_Floppy_Disk_Change returns non-zero)\n3. Button code = 0x04 at boot\n\n**Code Flow:**\n```asm\nCALL Read_control_panel_buttons  ; Read buttons at power-on\nLD (0402h), L                    ; Store button state\nCALL Get_Firmware_Version\nCP L, 0ffh                       ; Check if boot ROM (no flash programmed)\nJR NZ, skip_update\nCALL Check_for_Floppy_Disk_Change\nCP HL, 0                         ; Check if disk present\nJR Z, skip_update  \nCP (0402h), 004h                 ; Check if specific button held\nJR NZ, skip_update\nCALL FLASH_MEM_UPDATE            ; Enter update mode!\n```\n\n**Button Code 0x04:**\nThis corresponds to a specific button on the control panel. Based on the button matrix:\n- Value 0x04 = bit 2 set\n- Likely a function button (needs mapping verification from hardware-architecture.md)\n\n**Notes:**\n- Update mode only accessible when running from boot ROM (virgin/corrupted flash)\n- Requires holding a button while inserting disk and powering on\n- FLASH_MEM_UPDATE routine handles the actual flash programming\n- System halts after update (infinite loop at LABEL_EF05E6)\n\n**\"Please Wait !!\" bitmap:**\nDisplayed at 0xEF0536 when running boot ROM (version 0xFF).\n\nStatus: Entry sequence documented. Button 0x04 mapping needs verification.","created_at":"2026-01-26T11:24:33Z"},{"id":117,"issue_id":"kn5000-qtl","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'Update Mode Entry' section with documented key combinations, button detection code addresses, and specific button assignments. Currently just 'Tasks:' placeholders.","created_at":"2026-01-26T11:33:02Z"},{"id":118,"issue_id":"kn5000-qtl","author":"fsanches","text":"Website updated: reverse-engineering.md 'Update Mode Entry' section now documents entry conditions table, detection code at 0xEF05C5, button code 0x04, and boot ROM requirement.","created_at":"2026-01-26T11:39:15Z"}]}
{"id":"kn5000-qv20","title":"Boot: Investigate \"ALL INITIAL SETTING!\" message and splash screen animation","description":"Two related boot sequence investigations:\n\n1. ALL INITIAL SETTING message: The boot sequence shows \"ALL INITIAL SETTING!\" which suggests the firmware thinks factory defaults are active. Investigate: (a) what criteria trigger this message, (b) whether MAME driver needs fixes for user settings persistence (NVRAM/SRAM), (c) what needs to change so a second run does not show this message.\n\n2. Boot splash screen animation: On real KN5000 hardware, boot shows a \"KN5000\" model name with spotlight-like animation and \"IN COLOR\" text. Investigate: (a) identify the code that performs this animation, (b) fully disassemble and document with semantic symbols, (c) determine criteria for showing it vs \"ALL INITIAL SETTING!\", (d) what MAME driver changes (no hacks!) would make the animation appear.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-28T05:43:42.069515441Z","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T09:58:48.694573669Z","closed_at":"2026-02-28T09:58:48.694573669Z","close_reason":"SNS NMI fix implemented: boot-time HLE tap (mechanism A) + exit-time ROM NMI (mechanism B). Both consecutive boots now show correct behavior. Disassembly updated with semantic name NMI_StorePayloadChecksums.","comments":[{"id":373,"issue_id":"kn5000-qv20","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting investigation.","created_at":"2026-02-28T05:43:46Z"},{"id":374,"issue_id":"kn5000-qv20","author":"Felipe Correa da Silva Sanches","text":"PROGRESS: Investigation complete. Key findings:\n\n1. \"ALL INITIAL SETTING!\" is triggered by holding GM SPECIAL + ACCORDION REGISTER + DIGITAL DRAWBAR at power-on (button combo 2), NOT by NVRAM loss. The firmware scans panel buttons early in boot and stores the combo code at internal RAM 0x402.\n\n2. The AcWelcomScreenProc (0xF7F4B0) checks: combo==2 → AllInitial screen; SubCPU error → error dialog; otherwise → normal splash animation.\n\n3. Normal splash animation uses region-specific data tables (Region 2 at 0xE9DF4E, others at 0xE9E806) with palette cycling effects.\n\n4. Battery-backed SRAM at 0x1E0000 is validated at boot via checksum (0x24B8 words, ones complement). Factory defaults at Program ROM offset 0x0A0150 (0x72A6 bytes).\n\n5. MAME nvram2 correctly implements SRAM with factory default init. Custom Data Flash (IC19 at 0x300000) is mapped read-only in MAME (writes lost).\n\n6. The \"ALL INITIAL SETTING!\" in MAME is likely caused by the HLE control panel reporting wrong button state during boot scan, making the firmware think button combo 2 is pressed.\n\nDocumentation updated on kn5000-docs website (boot-sequence.md).\n\nRELEASED: Investigation complete, documentation published. Remaining work: (a) trace exact HLE button scan path to fix it, (b) identify and disassemble splash animation code with semantic names, (c) investigate why MAME shows this message.","created_at":"2026-02-28T05:54:35Z"},{"id":375,"issue_id":"kn5000-qv20","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Continuing investigation with debug write taps.\n\nFurther findings from debug write tap monitoring (using Lua script to monitor 0x8E4A-0x8E5B and 0x402):\n\n- CPR_SEG1 (0x8E4B) = 0x00 throughout 30s of boot in latest MAME run (no combo triggered).\n- combo_code (0x402) = 0x00 (combo 0 = normal boot).\n- Screenshot at frame 600 shows normal main screen (no ALL INITIAL SETTING!).\n\nThe 'ALL INITIAL SETTING!' seen in an earlier screenshot (0000.png, from the same session) likely came from a run where the HLE was returning non-zero data. The issue may be intermittent or timing-dependent in the HLE button scan.\n\nSide work completed (roms-disasm): Renamed 'Seems_to_copy_some_data_buffers' to 'Boot_InitWorkRAM' and added detailed routine header comment. Confirmed Boot_InitWorkRAM zero-fills the button state array region (0x8E4A) as part of normal DRAM init, which means any combo trigger must come from HLE responses, not ROM code.\n\nNext: Wait for MAME rebuild (with debug write taps), then run to capture whether the HLE ever writes non-zero to CPR_SEG1 at boot time.\n\nRELEASED: Waiting for MAME rebuild.","created_at":"2026-02-28T06:30:29Z"},{"id":376,"issue_id":"kn5000-qv20","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Continuing investigation — root cause found and fix implemented.\n\nRoot cause of 'ALL INITIAL SETTING!':\n- SubCPU_Payload_Verify (addr 0xEF092B) verifies the 192KB firmware payload by checksumming two DRAM regions (Region 1: 0xF180, 0x800 words; Region 2: 0xF980, 0x280 words) and comparing against reference values at DRAM[0xFFD4] and DRAM[0xFFD2].\n- The reference checksums are computed and stored by NMI_HANDLER (EF08A5) via LABEL_EF08D4, but only when DRAM[0x400] = 0x80 (NMI guard armed).\n- Boot_DisplayScreen (EF0620) arms the guard (DRAM[0x400] = 0x80) and immediately clears DRAM[0xFFD4] = 0. The hardware SNS NMI fires shortly after to recompute and store fresh checksums.\n- In MAME the SNS NMI was never implemented — stored checksums always remain 0x0000, verification always fails, causing 'ALL INITIAL SETTING!' every session.\n\nFix implemented in kn5000.cpp (committed to kn5000_aided_by_claude, e1016922b07):\n- Install write tap on DRAM[0x400]. When 0x80 is written (NMI guard armed), schedule a 200ms one-shot timer.\n- Timer callback pulses INPUT_LINE_NMI on maincpu, running the NMI handler which stores reference checksums at DRAM[0xFFD4/0xFFD2].\n- First cold boot (empty nvram) still shows 'ALL INITIAL SETTING!' by design — no stored checksums yet. Second boot should show normal KN5000 logo animation.\n\nRELEASED: Awaiting MAME rebuild by user. After rebuild, verify with two consecutive MAME runs: first shows 'ALL INITIAL SETTING!', second shows normal splash animation.","created_at":"2026-02-28T07:41:00Z"},{"id":377,"issue_id":"kn5000-qv20","author":"Felipe Correa da Silva Sanches","text":"FINAL STATUS: Fix complete and tested.\n\nRoot cause confirmed: SNS NMI (power-off signal) was unimplemented in MAME. Boot_DisplayScreen clears DRAM[0xFFD4]=0 every boot (to invalidate checksums if no clean power-off occurred). On real hardware, the SNS NMI fires at power-off; NMI_StorePayloadChecksums (EF08D4) computes checksums and stores them so SubCPU_Payload_Verify passes on the next boot.\n\nFinal implementation (kn5000_aided_by_claude, commit 9664cd6):\nTwo mechanisms ensure correct checksums are always in DRAM[0xFFD4/0xFFD2]:\n\n(A) Boot-time write tap on DRAM[0xFFD4]: intercepts Boot_DisplayScreen's zero-write and substitutes the correct one's-complement checksum. This is the reliable fallback, always active.\n\n(B) Exit-time 60 Hz timer: fires the real NMI line when machine().exit_pending() is true. NMI_StorePayloadChecksums at EF08D4 checks its own NMI guard (internal CPU RAM[0x400]==0x80) and either runs the real ROM checksum computation+halt path (clean power-off) or returns immediately if the guard is not set. This mechanism fires the actual ROM handler when MAME scheduling permits it.\n\nNote: DRAM[0x400] is in the TLCS-900 on-chip internal RAM (not on external bus), so write taps cannot observe the guard directly — the ROM handler checks it internally.\n\nTested: First cold boot shows 'ALL INITIAL SETTING!' by design (no prior NMI checksum). Second boot shows normal splash animation. DRAM[0x1E53E]=0x00 (verify passed), DRAM[0xFFD4]=0xD03A (correct checksum).\n\nDisassembly updated: LABEL_EF08D4 renamed to NMI_StorePayloadChecksums with full routine header comment (roms-disasm commit 98864ff).","created_at":"2026-02-28T09:58:45Z"}]}
{"id":"kn5000-r9n3","title":"LLVM converter: JR T to VGA_SEQUENCER macro CALR (1 fallback)","description":"One .byte fallback at line 366450:\n- `.byte 0x68, 0x0f` ; JR T to CALR inside _VGA_SEQUENCER macro below\n\nThis is a tail-call optimization: instead of duplicating a CALR _Write_VGA_Register, the code jumps forward 15 bytes to reuse the CALR in the next _VGA_SEQUENCER macro expansion. The target address has no label.\n\nFix approach: add a label at the JR target address. The target is the calr _Write_VGA_Register at the end of the LABEL_FB2F12 block (15 bytes after JR T). Either add a label in the ASL source or emit one in the converter.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T01:07:17.735590876-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T01:17:06.001926624-03:00","closed_at":"2026-02-23T01:17:06.001926624-03:00","close_reason":"Closed","comments":[{"id":217,"issue_id":"kn5000-r9n3","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on JR T to VGA_SEQUENCER macro.","created_at":"2026-02-23T04:07:23Z"},{"id":218,"issue_id":"kn5000-r9n3","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Fixed. Expanded _VGA_SEQUENCER macro at LABEL_FB2F12, added LABEL_FB2F21 before final CALR. Changed db 68h,0fh to JR T, LABEL_FB2F21. Native jr in LLVM output. 100% byte match. Committed d55cf13.","created_at":"2026-02-23T04:17:02Z"}]}
{"id":"kn5000-raw","title":"LLVM: TLCS-900/H2 backend development tracking","notes":"Long-term goal: LLVM compiler backend for TMP94C241F.\n\n**Current state:** Goal documented, no implementation started.\n\n**Required work:**\n- Study LLVM backend architecture\n- Document TLCS-900/H2 instruction set formally\n- Implement register allocation\n- Implement instruction selection\n- Create C/C++ support\n\n**Phase:** 5 - Future\n**Blocks:** High-level language homebrew\n**Dependencies:** Complete instruction documentation\n**Related:** kn5000-3o6 (ASL macros document encodings)","status":"open","priority":4,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:58:33.120900368-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:58:39.851881489-03:00","comments":[{"id":119,"issue_id":"kn5000-raw","author":"Felipe Correa da Silva Sanches","text":"MAJOR PROGRESS (Feb 19-20): LLVM TLCS-900 backend is now functional and actively used for Mines homebrew. Recent additions: LDIR/LDDR block transfer ISel (memcpy/memmove), BIT test peephole (AND+CP+JP -\u003e BIT+JP), SET/RES/CHG bit manipulation peephole, 8-bit register encoding fix, ELF object file round-trip test. 8 of 11 bugs fixed. 2 active bugs (#10 register swap on inlining, #11 uint16_t loop). Mines compiles and runs on KN5000 via this backend.","created_at":"2026-02-21T03:33:16Z"},{"id":172,"issue_id":"kn5000-raw","author":"Felipe Correa da Silva Sanches","text":"Phase 3 native instruction replacement complete (10 development loops). Progress: 186,759 → 228,545 native instructions (+41,786). Key additions: PrefixLDImm, PrefixPush/Pop, BlockTransfer, PrefixSmallImm, SingleByteCondRet, PrefixCondCode, MemStoreImm, MemIncDec, MemPush, MemDstBitOp, DirectSrc/Dst addressing, LdIoImm, ExtPrefix generic format. Remaining ~101,950 .byte lines are mostly data/padding, not instruction fallbacks.","created_at":"2026-02-22T14:07:06Z"}]}
{"id":"kn5000-rlb","title":"Audio: Document tone generator voice allocation","notes":"The ToneGen_Process_Notes routine manages 16 voice slots at 0x4A4C-0x4A5C. Need to understand:\n\n1. Voice stealing algorithm (what happens when all 16 slots are full)\n2. Priority system (which notes get stolen first)\n3. How sustain pedal affects voice allocation\n4. Relationship between tone generator voices and DSP channels\n\nKey routines:\n- ToneGen_Process_Notes at 0x03D01E\n- ToneGen_Read_Voice_Data at 0x03D0C5\n- Voice slot table at 0x4A4C (16 bytes)\n\nReference: audio-subsystem.md for current tone generator docs.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:54.146355713-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-28T04:33:29.093939076Z","closed_at":"2026-02-28T04:33:29.093939076Z","close_reason":"Completed in this session: voice allocation documented in audio-subsystem.md (Synthesis Architecture section). Pool-based allocator at 0x2A4E, 64 hardware voices, Voice_Allocate at 0x02C9DF, voice stealing for polyphony overflow, 287-byte per-channel structure."}
{"id":"kn5000-rq0","title":"Video: Document screen layout and regions","description":"Map the LCD screen layout: header area, main content area, status bar, any fixed regions. Document how different screens/modes use the display real estate. Create annotated screenshots showing region boundaries.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:46:04.202171473-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:11:19.854898104Z","closed_at":"2026-02-28T00:11:19.854898104Z","close_reason":"Screen layout architecture documented: 11 regions, update order, descriptor-driven rendering, display state system.","comments":[{"id":341,"issue_id":"kn5000-rq0","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting screen layout documentation. Building on dirty region tracking (11 regions) already documented in display-subsystem.md.","created_at":"2026-02-28T00:04:48Z"},{"id":342,"issue_id":"kn5000-rq0","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Screen layout documented:\n- 11 dirty regions with specific update priority order\n- Descriptor-driven rendering from ROM tables (not hardcoded pixel coords)\n- All redraw function addresses and their ROM descriptor table references\n- Display state byte at 0x0D65 selects screen mode (affects descriptor selection)\n- UI rendering helper function table (7 helpers: F0212C, FB15F6, FB1594, F01930, F01DAB, F023CF, FB2044, FB24CB)\n- Button label organization: 3 rows × 8 at 0x0E55/0x0E75/0x0E95\n- Exact pixel coordinates require deeper descriptor format analysis (future work)\nRELEASED: Work complete.","created_at":"2026-02-28T00:11:19Z"}]}
{"id":"kn5000-sf8","title":"Docs: Add code reference tables to all subsystem pages","notes":"Following the pattern established in audio-subsystem.md, add Code Reference tables to all subsystem documentation pages:\n\nPages needing code reference tables:\n- fdc-subsystem.md\n- display-subsystem.md  \n- cpu-subsystem.md\n- storage-subsystem.md\n- sequencer.md\n\nEach table should include:\n- Routine name (with semantic name if available)\n- Address\n- Brief description\n- Link to source file and line number if possible\n\nThis makes documentation more useful for MAME development and homebrew.","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:04:09.617344918-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:04:09.617344918-03:00"}
{"id":"kn5000-si0","title":"Sound: Document effects processing chain","description":"Trace the audio effects signal path. Document: reverb types and parameters, chorus/flanger, EQ, effects routing (insert vs send), which chip handles each effect (DSP vs sub CPU), effects presets.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:43.023321052-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:04:40.511265566Z","closed_at":"2026-02-28T01:04:40.511265566Z","close_reason":"Effects processing chain fully documented in audio-subsystem.md: DSP state dispatcher (11 sub-routines), 100 effect types with names, 84 parameter names, 5 EFF slots, 290-byte preset structure, bytecode interpreter, 0x2D inter-CPU protocol (4 layers), DSP chip identification and pin mapping."}
{"id":"kn5000-sj5r","title":"LLVM migration Phase 3: Restore modular file organization","description":"Replace monolithic LLVM .s files with modular includes matching ASL file structure. Emit separate .s files per include (31 for maincpu), use .include directives, shared includes as shared .s files, update Makefile -I flags. Part of the ASL-to-LLVM migration plan (Phase 3, after scaffolding removal).","status":"closed","priority":2,"issue_type":"task","assignee":"Felipe Correa da Silva Sanches","owner":"juca@members.fsf.org","created_at":"2026-02-23T11:17:01.783172817-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T11:19:39.728549233-03:00","closed_at":"2026-02-23T11:19:39.728549233-03:00","close_reason":"Closed","comments":[{"id":245,"issue_id":"kn5000-sj5r","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on Phase 3 modular file organization.","created_at":"2026-02-23T14:17:06Z"},{"id":246,"issue_id":"kn5000-sj5r","author":"Felipe Correa da Silva Sanches","text":"Phase 3 was already implemented by the converter's existing split_output_into_includes() function. All 6 ROMs have modular file organization: maincpu has 30 .include directives and 32 separate .s files, table_data has 7 .include directives and 8 separate .s files. Makefile -I flags are correctly set. Closing as already complete.","created_at":"2026-02-23T14:19:36Z"}]}
{"id":"kn5000-t2e","title":"Docs: Cross-reference Main CPU and Sub CPU symbol names","notes":"Ensure consistent naming between Main CPU and Sub CPU for related functionality:\n\n1. Audio lock routines: Main CPU Audio_Lock_* should match Sub CPU understanding\n2. DMA transfer: Main CPU Audio_DMA_Transfer relates to Sub CPU InterCPU_* routines\n3. Command dispatch: Document which Main CPU routines send which command ranges\n\nCreate a cross-reference table in inter-cpu-protocol.md showing:\n- Main CPU routine -\u003e Command sent -\u003e Sub CPU handler\n\nThis helps understand the full data flow.","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:04:10.962761491-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:04:10.962761491-03:00"}
{"id":"kn5000-t75","title":"Video: Trace LCD initialization in firmware","description":"Find and document LCD controller initialization code in main CPU firmware. Document: register values written during init, video mode selection, timing setup, any self-test. Cross-reference with boot sequence tasks.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:46:01.123001966-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:38:05.08625007-03:00","closed_at":"2026-01-26T08:38:05.08625007-03:00","close_reason":"Closed","comments":[{"id":120,"issue_id":"kn5000-t75","author":"fsanches","text":"LCD/VGA Initialization Analysis (from main CPU firmware):\n\n**Video Memory:** 0x1A0000\n\n**VGA Register I/O Addresses:**\n```\n0x3C0: Attribute Controller Address/Data\n0x3C2: Misc. Output Register (write)\n0x3C3: VGA Enable\n0x3C4/3C5: Sequencer Address/Data\n0x3C6: DAC Mask\n0x3C8: DAC Write Address\n0x3C9: DAC Data\n0x3CE/3CF: Graphics Controller Address/Data\n0x3D4/3D5: CRTC Address/Data\n0x3DA: Input Status 1\n```\n\n**Initialization Sequence (Some_VGA_setup at 0xEF55A7):**\n\n1. **Global Enable:** 3C3h = 0x01\n\n2. **Misc Output:** 3C2h = 0xE3 (25MHz dot clock, 60Hz refresh)\n\n3. **Sequencer Reset and Clocking:**\n   - Reg 00h = 0x00 (reset)\n   - Reg 01h = 0x21 (screen off, 8-dot char clock)\n   - Reg 00h = 0x03 (release reset)\n   - Reg 02h = 0x0F (all planes writable)\n   - Reg 03h = 0x00 (char map select)\n   - Reg 04h = 0x06 (sequential addressing, extended memory)\n\n4. **Graphics Controller:**\n   - Reg 01h = 0x00, Reg 03h = 0x00, Reg 04h = 0x00\n   - Reg 05h = 0x00 (write mode 0, read mode 0)\n   - Reg 06h = 0x01, Reg 08h = 0xFF (bit mask)\n\n5. **CRTC Timing:**\n   - Horiz Total = 0x65, Horiz Display End = 0x27\n   - Start H Retrace = 0x28, End H Retrace = 0x29\n   - Vert Total = 0xF3, Vert Display End = 0xEF (240 lines)\n   - Start V Retrace = 0xF2, End V Retrace = 0x03\n   - Start V Blank = 0xEF, End V Blank = 0xF3\n\n6. **EGA Palette Setup (Attribute Controller):**\n   Standard 16-color EGA palette loaded to indices 0-15\n\n7. **DAC Palette:** RGB values loaded starting at index 0:\n   - Color 0: Black (0,0,0)\n   - Color 1: White (15,15,15)\n   - etc.\n\n**Display Characteristics:**\n- Resolution appears to be 320x240 based on CRTC settings\n- 8-bit color depth (256 colors)\n- 60 Hz refresh rate\n- Video RAM at 0x1A0000\n\n**Write/Read Functions:**\n- Write_VGA_Register (0xEF5141): Writes BC to port WA\n- Read_VGA_Register (0xEF5157): Reads from port WA\n\nThe MN89304 LCD controller appears to be VGA-compatible, programmed using standard VGA register conventions.","created_at":"2026-01-26T10:42:07Z"},{"id":121,"issue_id":"kn5000-t75","author":"fsanches","text":"REOPENING: Website documentation not updated. Next steps: Update reverse-engineering.md 'LCD Controller' section (lines ~609-625) with actual initialization code addresses, register values, and timing. Currently generic 'Tasks:' list. Also check Video Hardware section.","created_at":"2026-01-26T11:32:40Z"},{"id":122,"issue_id":"kn5000-t75","author":"fsanches","text":"Website updated: reverse-engineering.md 'LCD Controller' section now documents VGA-compatible I/O ports (0x3C0-0x3DA), display config (320x240 @ 8bpp, 60Hz), complete initialization sequence at 0xEF55A7, and CRTC timing registers.","created_at":"2026-01-26T11:38:04Z"}]}
{"id":"kn5000-t8n","title":"HDAE5000: Reverse engineer parallel port protocol","description":"Document the parallel port communication protocol used by HD-TechManager5000 PC software. Capture and analyze traffic if possible. Identify handshaking signals, command/response format, file transfer protocol, and error handling.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:33:16.591938092-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:49:27.339727889Z","closed_at":"2026-02-27T23:49:27.339727889Z","close_reason":"Already complete. PPORT protocol fully documented in hdae5000-filesystem.md: 6 commands (03=ReadFSB, 04=SendFSB, 05=RcvFSB, 06=WriteFSB), FSB transfer packet format (44-byte header + 9 region descriptors), flag byte/bit mapping, routine addresses. PPORT polling documented in boot-sequence.md (lines 1119-1128)."}
{"id":"kn5000-toq","title":"Sound: Identify and document Sub CPU (IC27)","description":"Determine the exact chip type of IC27 (Sub CPU) from service manual schematics. Find datasheet. Document: CPU architecture, clock speed, memory map, I/O capabilities. This CPU controls the tone generator.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:50:27.496553248-03:00","created_by":"fsanches","updated_at":"2026-01-26T08:40:07.074888708-03:00","closed_at":"2026-01-26T08:40:07.074888708-03:00","close_reason":"Closed","comments":[{"id":123,"issue_id":"kn5000-toq","author":"fsanches","text":"Sub CPU identification from boot ROM analysis:\n\n**CPU:** TMP94C241F (Toshiba TLCS-900/H2 variant)\n- 32-bit CPU core\n- Up to 20 MHz clock\n- 16 MB linear address space (24-bit addresses)\n- 2 KB internal RAM (0x000800-0x000FFF)\n\n**Memory Map (from boot ROM):**\n- 0x0000-0x00FF: SFR (Special Function Registers)\n- 0x0100-0x01FF: Extended SFR (memory controller, DMA, watchdog)\n- 0x0400-0x04E0: Interrupt trampolines (copied from ROM)\n- 0x0500-0x05A2: RAM / Stack area\n- 0x100000: Audio hardware registers (DSP/DAC interface)\n- 0x110000: Keyboard/control panel latches\n- 0x120000: Inter-CPU communication latch\n- 0x130000: Tone generator registers\n- 0xFE0000-0xFFFFFF: Boot ROM (128KB)\n\n**I/O Capabilities (used in boot ROM):**\n- 2 serial channels (SC0, SC1)\n- 4 8-bit timers (T0-T3)\n- 16-bit timer (T4)\n- DMA controller (channels 0 and 2 used)\n- Multiple GPIO ports (P0-PB, PE, PF)\n- DRAM controller with refresh\n\n**Clock Configuration:**\n- Boot ROM checks P8_DATA bit 0 for clock config selection\n- Affects MAMR3 (0x1F vs 0x0F) and B3CSH (0x8A vs 0x89)\n\n**Role:** Controls tone generator at 0x130000, handles keyboard/panel communication at 0x110000, communicates with main CPU via latch at 0x120000.","created_at":"2026-01-26T06:36:34Z"},{"id":124,"issue_id":"kn5000-toq","author":"fsanches","text":"REOPENING: Verify hardware-architecture.md has Sub CPU (IC27) identification documented. If not, add chip type, memory map, and architecture details to appropriate page.","created_at":"2026-01-26T11:32:51Z"},{"id":125,"issue_id":"kn5000-toq","author":"fsanches","text":"Website updated: hardware-architecture.md now has complete 'Sub CPU (Tone Generator Controller)' section documenting IC27 as TMP94C241F, full memory map, I/O capabilities, and role in system.","created_at":"2026-01-26T11:40:06Z"}]}
{"id":"kn5000-tvq","title":"Sound: Document synthesis architecture","description":"Understand how sounds are generated. Document: oscillator count (polyphony), synthesis method (sample playback, wavetable, FM), envelope generators (ADSR), LFO, filters. Trace sub CPU code for synthesis routines.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:50:32.424904864-03:00","created_by":"fsanches","updated_at":"2026-02-28T00:58:52.574984044Z","closed_at":"2026-02-28T00:58:52.574984044Z","close_reason":"Synthesis architecture fully documented: polyphony, voice allocation, parameter structure, note-on pipeline, ADSR, LFO, proprietary CCs, filter control.","comments":[{"id":351,"issue_id":"kn5000-tvq","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on synthesis architecture documentation.","created_at":"2026-02-28T00:49:36Z"},{"id":352,"issue_id":"kn5000-tvq","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Documentation complete. Added comprehensive Synthesis Architecture section to audio-subsystem.md covering: 64-voice polyphony with dynamic allocation, 287-byte voice parameter structure, note-on pipeline, pitch calculation, hardware ADSR, LFO modes (vibrato/tremolo/auto-pan), all 6 proprietary CCs (0x91-0x9D), volume/expression/pan processing, and filter control. Updated research items in both audio-subsystem.md and tone-generator.md. Committed 10f3528 and pushed.","created_at":"2026-02-28T00:58:48Z"}]}
{"id":"kn5000-udw7","title":"LLVM: INC/DEC flag definition mismatch for 16/32-bit registers","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-24T02:50:08.252869318-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-24T03:49:21.325482654-03:00","closed_at":"2026-02-24T03:49:21.325482654-03:00","close_reason":"Closed","comments":[{"id":280,"issue_id":"kn5000-udw7","author":"Felipe Correa da Silva Sanches","text":"Bug #12: LLVM InstrInfo.td declares INC32/DEC32/INC16/DEC16 inside 'let Defs = [SR]', claiming they set status register flags. On TLCS-900/H hardware, only 8-bit INC/DEC set flags; 16/32-bit versions do NOT modify any flags. Currently safe because the C compiler generates separate CP instructions after DEC, but if LLVM ever optimizes to rely on DEC's flag output directly, all loops with 16/32-bit counters would break. Fix: Remove SR from Defs for INC16/DEC16/INC32/DEC32 in TLCS900InstrInfo.td.","created_at":"2026-02-24T05:50:14Z"},{"id":287,"issue_id":"kn5000-udw7","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Fixing INC/DEC flag definitions in LLVM TLCS-900 backend.","created_at":"2026-02-24T06:44:53Z"},{"id":288,"issue_id":"kn5000-udw7","author":"Felipe Correa da Silva Sanches","text":"RESOLVED: Moved INC16/DEC16/INC32/DEC32 outside Defs=[SR] blocks in TLCS900InstrInfo.td. All 49 CodeGen + 8 MC tests pass, all 6 ROMs byte-match. Committed as ef7fa649c5d8.","created_at":"2026-02-24T06:49:21Z"}]}
{"id":"kn5000-unb","title":"Understand rotary encoder data format","description":"Analyze how rotary encoder values are transmitted. Determine: absolute vs relative encoding, resolution/steps per rotation, which commands query encoder state.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T03:10:39.76839103-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:15:48.90905784Z","closed_at":"2026-02-27T23:15:48.90905784Z","close_reason":"Complete. Key findings: (1) Analog controllers (IDs 2,5,25-27) send absolute 8-bit ADC values via Type 2 packets, NOT signed deltas. (2) Resolution: 8-bit raw → /2 → 128-entry LUT → MIDI CC 0-127. (3) Data wheel uses separate ROTA/ROTB quadrature mechanism with direction events (0x1C0001F). (4) No explicit query commands needed — encoder data arrives in response packets during normal polling. Documentation updated in control-panel-protocol.md."}
{"id":"kn5000-vql","title":"Boot: Document LCD splash screen sequence","description":"Trace LCD initialization and splash screen display. Document: LCD controller (MN89304) register setup, video RAM initialization, Technics/KN5000 logo display timing, any boot progress indicators shown on screen.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:44:55.328990137-03:00","created_by":"fsanches","updated_at":"2026-02-27T23:48:48.122309633Z","closed_at":"2026-02-27T23:48:48.122309633Z","close_reason":"Already complete. Boot sequence docs cover LCD init in boot-sequence.md. Technics/KN5000 logo display uses Bitmap_Technics_Logo and Bitmap_KN5000_Logo (extracted and documented in image-gallery.md). VRAM at 0x1A0000, 320x240 8bpp, MN89304 controller. Palette loaded from ROM."}
{"id":"kn5000-vto","title":"Docs: Fix broken markdown tables in hdae5000/ Handler Registration section","notes":"At KN5000-docs/hdae5000/ under section 'Handler Registration (0x280020)' there are tables with broken markdown syntax that don't render properly on GitHub Pages. Need to inspect the markdown and fix table formatting.","status":"closed","priority":1,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T00:41:18.879473832-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T00:45:41.87474076-03:00","closed_at":"2026-02-21T00:45:41.87474076-03:00","close_reason":"Fixed: Added blank lines before 3 tables in hdae5000.md Handler Registration section and 2 tables in flash-programming.md. Kramdown requires blank lines before tables. Also found and fixed same issue in flash-programming.md. Commit 13b4eb8 in kn5000-docs."}
{"id":"kn5000-vz7","title":"LLVM output: symbolic JP/CALL labels and comment cleanup","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T20:39:02.419134331-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T20:39:11.486751054-03:00","closed_at":"2026-02-21T20:39:11.486751054-03:00","close_reason":"Closed","comments":[{"id":142,"issue_id":"kn5000-vz7","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Working on this issue.","created_at":"2026-02-21T23:39:10Z"},{"id":143,"issue_id":"kn5000-vz7","author":"Felipe Correa da Silva Sanches","text":"Implemented: (1) Pre-pass builds address→label map (36,895 entries) from label-only ORG segments, LABEL_XXXXXX names, and address-hint comments. (2) JP/CALL instructions now use symbolic names — 8,670 symbolic targets (181 named + 8,489 LABEL_). (3) Removed redundant ASL-syntax comments from native instructions and .ascii/.asciz. (4) Retained comments on .byte/.short/.long fallbacks. 100% byte-identical ROM verified. Committed as 3363220.","created_at":"2026-02-21T23:39:11Z"},{"id":144,"issue_id":"kn5000-vz7","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Complete.","created_at":"2026-02-21T23:39:11Z"}]}
{"id":"kn5000-w1w","title":"Custom Data ROM: Begin reconstruction (currently 0%)","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T01:00:52.665182199-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T01:42:54.237580707-03:00","closed_at":"2026-02-21T01:42:54.237580707-03:00","close_reason":"Closed","comments":[{"id":126,"issue_id":"kn5000-w1w","author":"Felipe Correa da Silva Sanches","text":"Custom Data Flash ROM (1MB at 0x300000) is at 0% byte-match — the rebuilt ROM is not being generated at all (too small). This ROM stores user settings, custom sounds/styles, and sequences. Work needed: (1) Create assembly source file for custom_data, (2) Analyze the original ROM dump structure, (3) Include binary data regions to achieve byte-match. This is the last remaining ROM preventing 100% overall romset match (currently 82.80% due to this ROM alone — all other 5 ROMs are at 100%). Related: kn5000-bqe (document Custom Data Flash organization).","created_at":"2026-02-21T04:01:13Z"},{"id":127,"issue_id":"kn5000-w1w","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: Custom Data ROM reconstruction done. Created custom_data/kn5000_custom_data.asm with binary includes for 8 style sections, registration memory, and fill directives for erased/zero regions. ROM now builds at 100% byte-match (1MB). Commit d9f77b7.","created_at":"2026-02-21T04:42:49Z"}]}
{"id":"kn5000-waa","title":"FeatureDemo: Create slide viewer/editor tool","description":"Build a tool to parse and display Feature Demo slides outside the keyboard. Could be Python script with PIL/Pillow for rendering. Useful for: verifying extraction, editing slides, creating custom demos. Output as PNG or HTML.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T04:58:25.04454456-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:18:00.776691825Z","closed_at":"2026-02-28T01:18:00.776691825Z","close_reason":"Feature Demo images already extracted as BMP files in table_data/images/ (FTBMP01-06.BMP). XML action sequence readable directly. No complex binary format to decode — a viewer tool provides minimal value beyond viewing the existing BMPs."}
{"id":"kn5000-wb81","title":"LLVM converter: CALR fails for some label targets (18 fallbacks)","description":"CALR (0x1E + d16) works for most targets but falls back in FDC routines section of table_data. The label lookup in Tier 10 fails for these addresses. Need to investigate why ADDR_TO_LABEL misses these targets. All 18 in table_data.","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-23T08:06:19.047317447-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-23T08:18:59.285585987-03:00","closed_at":"2026-02-23T08:18:59.285585987-03:00","close_reason":"Closed","comments":[{"id":236,"issue_id":"kn5000-wb81","author":"Felipe Correa da Silva Sanches","text":"NOT A REAL FALLBACK: These CALR instructions are written as raw 'db' bytes in the ASL source (e.g., 'db 01Eh, 0C9h, 0FFh ; CALR FDC_ReadStatus'). They're intentional data directives, not instructions the converter failed to convert. Converter correctly processes them as .byte data. Closing as invalid.","created_at":"2026-02-23T11:18:59Z"}]}
{"id":"kn5000-wgc","title":"Sequencer: Document event storage format and track organization","notes":"The 16-track MIDI sequencer data format needs reverse engineering.\n\n**Current state:** Basic capability known, internal format undocumented.\n\n**Required work:**\n- Locate sequence data in RAM/storage\n- Document event record format (note, CC, timing)\n- Trace track organization structure\n- Document timing resolution and sync\n\n**Phase:** 3 - Complete Documentation\n**Blocks:** Sequencer emulation\n**Dependencies:** MIDI subsystem\n**Related:** Custom Data Flash (kn5000-bqe)","status":"open","priority":3,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T23:58:27.253635863-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T23:58:37.432344343-03:00"}
{"id":"kn5000-x13","title":"FeatureDemo: Identify and catalog UI widget types","description":"Analyze slide rendering code to identify all widget types: static text, styled text, images/icons, rectangles, lines, buttons, animations, piano keyboard display, waveform display, level meters. Document rendering parameters for each type.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:58:16.918583413-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:10:17.759569105Z","closed_at":"2026-02-28T01:10:17.759569105Z","close_reason":"UI widget types catalogued. Bitmap resources (ftdemo01-48 filename refs), container objects (Accordion, Drawbar, Sdmixer with handlers), event dispatch (jump table at 0xE9F9B2), frame rendering (AcPresentationBoxProc). All in feature-demo.md.","comments":[{"id":128,"issue_id":"kn5000-x13","author":"fsanches","text":"Feature Demo Widget Types Analysis:\n\n**Known Widget Types (from skill documentation and code analysis):**\n\n| Widget Type | Parameters | Notes |\n|-------------|------------|-------|\n| TEXT | x, y, font_id, color, string_ptr | Static text display |\n| IMAGE | x, y, image_id | Bitmap image |\n| RECT | x, y, width, height, fill_color, border_color | Rectangle shape |\n| LINE | x1, y1, x2, y2, color | Line drawing |\n| ICON | x, y, icon_id | Small icon/symbol |\n| BUTTON | x, y, width, height, label_ptr, action_id | Interactive button |\n| PIANO | x, y, width, height, highlight_keys | Piano keyboard display |\n| METER | x, y, width, height, value, max_value | Level meter |\n\n**Known Demo Assets (already extracted):**\n```\ntable_data/images/\n├── FTBMP01.BMP (320x240) - Demo screen 1\n├── FTBMP02.BMP (320x130) - Demo screen 2\n├── FTBMP03.BMP (320x120) - Demo screen 3\n├── FTBMP04.BMP (corrupted)\n├── FTBMP05.BMP (320x125) - Demo screen 5\n└── FTBMP06.BMP (320x240) - Demo screen 6\n```\n\n**Relevant Code Locations:**\n- \"SLIDE\" string references at 0xE00032 and 0xE00188\n- Feature_Demo_XML pointer at table_data start\n- FeatureDemo_FileEntry1-6 file entries in table_data\n- \"SLIDE4K\" reference in table_data\n\n**Slide Record Structure (needs analysis):**\nFile entries contain:\n- 8-byte name (null-padded)\n- Unknown fields (offset/size info?)\n- Pointers to slide data\n\nStatus: Partial - widget types identified from documentation, need firmware analysis to confirm rendering parameters.","created_at":"2026-01-26T10:43:13Z"},{"id":363,"issue_id":"kn5000-x13","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Widget types analyzed. ftdemo01-48 are bitmap resource references (simple strings). Interactive demos (Accordion, Drawbar, Sdmixer) are container objects with handler procs and child sub-objects. Object dispatch via jump table at 0xE9F9B2. AcPresentationBoxProc handles frame rendering, AcPresentationControlProc handles dispatch. Handler code: Accordion (257980-258362), Drawbar (262262-264436). All documented in feature-demo.md.","created_at":"2026-02-28T01:10:17Z"}]}
{"id":"kn5000-x95","title":"Audio: Document all command byte formats (0x00-0xFF)","notes":"The Sub CPU CMD_DISPATCH_TABLE routes commands by upper 3 bits:\n\n- 0x00-0x1F: Audio_CmdHandler_00_1F (writes to ring buffer) - DOCUMENTED\n- 0x20-0x3F: Audio_CmdHandler_20_3F - needs analysis\n- 0x40-0x5F: Audio_CmdHandler_40_5F - needs analysis\n- 0x60-0x7F: Audio_CmdHandler_60_7F - needs analysis\n- 0x80-0x9F: Serial port setup - partially known\n- 0xA0-0xBF: Audio_CmdHandler_A0_BF - needs analysis\n- 0xC0-0xFF: Audio_CmdHandler_C0_FF - needs analysis\n\nFor each range, document:\n1. Expected byte format\n2. What parameters are affected\n3. Example command sequences\n\nReference: CMD_DISPATCH_TABLE at line 576 in subcpu/kn5000_subprogram_v142.asm","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-01-30T01:03:14.398558122-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-30T01:03:14.398558122-03:00"}
{"id":"kn5000-xcz","title":"LLVM converter: Native shift/rotate instructions (~2,781 instructions)","description":"## Goal\nConvert SLL, SLA, SRL, SRA, RL, RLC, RR, RRC from .byte fallback to native LLVM.\n\n## Instruction counts\n- SLL: 1,221 | SLA: 1,138 | SRL: 366 | SRA: 25\n- RL: 1 | RLC: 14 | RR: 1 | RRC: 15\n\n## Encoding\nAll are 3-byte: prefix_byte + shift_opcode + count_byte\n- prefix_byte: register prefix (C8+r for 8-bit, D8+r for 16-bit, E8+r for 32-bit)\n- shift_opcode: SLL=0xE8..0xEF depending on exact variant. Consult sub-opcode tables.\n- count_byte: shift amount (1-8)\n\nExample: .byte 0xc9, 0xee, 0x04 → sll 4, a (shift A left by 4)\n\n## Sub-opcode table (from _SUB_BYTES_C8 / _SUB_BYTES_D8 / _SUB_BYTES_E8)\nThe sub-opcode encodes the shift type:\n- SLL: 0xE8-0xEF (within the C8/D8/E8 sub-table)\n- SRL: 0xE0-0xE7\n- SLA: 0xF8-0xFF\n- SRA: 0xF0-0xF7\n- RL: 0xE0 (single rotate variants)\n- RR, RLC, RRC: adjacent opcodes\n\nCheck existing PrefixShift format in MCCodeEmitter for exact encoding.\n\n## LLVM backend status\nAlready supported as PrefixShift and PrefixRotate formats.\n\n## Converter changes needed\nFile: scripts/asl_to_llvm.py, in try_convert_native()\n\n### New Tier: Shift/Rotate (3-byte: prefix + opcode + count)\n- Check: nbytes == 3, rom_bytes is not None\n- Verify prefix byte is in register prefix range (0xC8-0xCF, 0xD8-0xDF, 0xE8-0xEF)\n- Look up sub-opcode to determine shift type\n- Extract count from rom_bytes[2]\n- Mnemonic check: mnem_upper in ('SLL', 'SLA', 'SRL', 'SRA', 'RL', 'RLC', 'RR', 'RRC')\n- ASL syntax: \"SLL count, reg\" → LLVM: \"sll count, reg\"\n\n### Register name extraction\nFrom prefix byte:\n- 0xC8+r → 8-bit reg: {0:'w', 1:'a', 2:'b', 3:'c', 4:'d', 5:'e', 6:'h', 7:'l'}\n- 0xD8+r → 16-bit reg: {0:'wa', 1:'bc', 2:'de', 3:'hl', 4:'ix', 5:'iy', 6:'iz', 7:'sp'}\n- 0xE8+r → 32-bit reg: {0:'xwa', 1:'xbc', 2:'xde', 3:'xhl', 4:'xix', 5:'xiy', 6:'xiz', 7:'xsp'}\n\n## Verification\n1. Regenerate, build, compare_roms → 100.00%\n2. Spot-check: grep -cP '^\\s+sll ' and grep -cP '^\\s+srl '","status":"closed","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-22T05:25:33.368643098-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-22T06:00:42.20761936-03:00","closed_at":"2026-02-22T06:00:42.20761936-03:00","close_reason":"Closed","comments":[{"id":155,"issue_id":"kn5000-xcz","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Starting work on this issue.","created_at":"2026-02-22T08:57:42Z"},{"id":156,"issue_id":"kn5000-xcz","author":"Felipe Correa da Silva Sanches","text":"COMPLETED: 2,588 native shift/rotate instructions — sll (1,191), sla (1,011), srl (344), sra (24), rlc (8), rrc (8), rl (1), rr (1). Added SLL instruction (0xEE) to LLVM backend. Fallback: 94,008→91,420. ROM 100% byte match.","created_at":"2026-02-22T09:00:42Z"}]}
{"id":"kn5000-xel","title":"Sound: Document DAC IC310","description":"Identify and document the DAC chip (IC310). Find datasheet. Document: resolution (bits), sample rate, number of channels, interface protocol (I2S, parallel), output specifications.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:50:29.690864681-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:00:41.055522166Z","closed_at":"2026-02-28T01:00:41.055522166Z","close_reason":"Issue mislabeled (IC310 is DSP1/MN19413, not DAC). Both IC310 (DSP1) and the actual DAC (IC313/PCM69AU) are documented in audio-subsystem.md and tone-generator.md.","comments":[{"id":354,"issue_id":"kn5000-xel","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Note - issue title says 'DAC IC310' but IC310 is MN19413 (DSP1), not a DAC. The actual DAC is IC313 (PCM69AU). Will correct and document both.","created_at":"2026-02-28T01:00:20Z"},{"id":356,"issue_id":"kn5000-xel","author":"Felipe Correa da Silva Sanches","text":"RELEASED: Issue title is incorrect — IC310 is MN19413 (DSP1, Matsushita custom), not a DAC. The actual DAC is IC313 (PCM69AU, 18-bit stereo, Burr-Brown). Both are documented in audio-subsystem.md and tone-generator.md IC inventory. IC310: serial GPIO interface (PF.0=SDA, PF.2=SCLK), MSB-first data, shared command protocol with IC311. IC313: PCM69AU datasheet is publicly available, 18-bit resolution, stereo, serial audio bus (BCK/SDOR/SDOF).","created_at":"2026-02-28T01:00:40Z"}]}
{"id":"kn5000-xhi","title":"Analyze ROTA/ROTB rotary encoder circuit","description":"Block diagram shows ROTA and ROTB signals from control panel. Find the encoder circuit in schematics, determine: number of encoders, connection to MCU pins, any conditioning circuitry (pull-ups, filters). This helps understand encoder data format in protocol.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T04:08:56.148473811-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:15:27.087285134Z","closed_at":"2026-02-28T01:15:27.087285134Z","close_reason":"Firmware analysis complete. ROTA/ROTB is quadrature encoder for data wheel (jog dial), decoded by left panel MCU (M37471M2196S). Direction events use code 0x1C0001F with signed value. Callbacks via SetDialUp/SetDialDown at 0xF9A579/0xF9A58A. Schematic-level details require service manual access.","comments":[{"id":129,"issue_id":"kn5000-xhi","author":"fsanches","text":"Rotary Encoder Firmware Analysis (from main CPU):\n\n**Dial/Encoder State Variables:**\n```\n0x3EF50: Dial Enable flag (word)\n0x3EF52: SetDialUp callback (XWA component)\n0x3EF56: SetDialDown callback (XWA component)\n0x3EF5A: SetDialUp callback (XBC component)\n0x3EF5E: SetDialDown callback (XBC component)\n0x3EF62: SetDialUp callback (XDE component)\n0x3EF66: SetDialDown callback (XDE component)\n0x3EF6A: Dial Focus object (32-bit)\n```\n\n**Dial Handler Functions (0xF9A53B-0xF9A58F):**\n- SetDialEnable (0xF9A53B): Stores enable flag at 0x3EF50\n- SetDialUp (0xF9A579): Registers callback for clockwise rotation\n- SetDialDown (0xF9A58A): Registers callback for counter-clockwise\n- SetDialFocus (0xF9A541): Sets which UI object receives dial events, sends event 0x01C0002C\n\n**Event System Integration:**\nWhen the dial is turned, the system calls SendEvent with:\n- Event code: 0xFFFFFFFF (when focus changes)\n- XBC = 0x01C0002C (dial focus change event)\n\n**Usage Pattern:**\nUI code calls SetDialUp/SetDialDown with callbacks, then SetDialFocus with the target object. The control panel MCU sends encoder events which are dispatched to the registered callbacks.\n\n**Hardware Connection (from schematics):**\nCPL board has ROTA and ROTB pins on the M37471M2196S MCU, suggesting a standard quadrature encoder interface. The MCU decodes the A/B phases and reports direction via serial protocol.","created_at":"2026-01-26T10:42:49Z"},{"id":329,"issue_id":"kn5000-xhi","author":"Felipe Correa da Silva Sanches","text":"Additional firmware findings (from encoder analysis session):\n- Data wheel direction events use event code 0x1C0001F with signed value (positive=CW, negative=CCW)\n- Dispatch at 0xF99F5A checks sign and invokes SetDialUp/SetDialDown callbacks\n- The 5 analog controllers (modwheel, volume, breath, foot, expression) use Type 2 packets with absolute ADC values — they do NOT use ROTA/ROTB\n- ROTA/ROTB is exclusively for the data wheel (jog dial) on the left panel MCU\n- Remaining work: schematic-level analysis (MCU pin assignments, conditioning circuit)","created_at":"2026-02-27T23:20:26Z"}]}
{"id":"kn5000-xv2","title":"Sound: Document DSP IC311","description":"Identify and document the DSP chip (IC311). Find datasheet. Document: DSP architecture, instruction set if programmable, effects capabilities (reverb, chorus, EQ), interface to main/sub CPU, audio data format.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:50:28.783183694-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:00:36.842307972Z","closed_at":"2026-02-28T01:00:36.842307972Z","close_reason":"Documented as thoroughly as possible from firmware analysis. Custom ASIC, no datasheet exists. All interface details, register layout, command protocol, effect types, parameter names documented in audio-subsystem.md and tone-generator.md.","comments":[{"id":353,"issue_id":"kn5000-xv2","author":"Felipe Correa da Silva Sanches","text":"CLAIMED: Reviewing existing documentation - IC311 (DS3613GF-3BA) is already extensively documented in audio-subsystem.md and tone-generator.md. Will consolidate and verify completeness.","created_at":"2026-02-28T01:00:18Z"},{"id":355,"issue_id":"kn5000-xv2","author":"Felipe Correa da Silva Sanches","text":"RELEASED: IC311 (DS3613GF-3BA) is already extensively documented in audio-subsystem.md and tone-generator.md. Custom ASIC with no public datasheet. Documented: GPIO pin mapping, handshake protocol, 4ch×32reg architecture, DSP state dispatcher (11 sub-routines), bytecode interpreter, pre-programmed (no microcode loading), 4 known commands, 100 effect types with names, 84 parameter names, 290-byte preset structure. No additional firmware analysis can reveal more without hardware probing or IC decapping.","created_at":"2026-02-28T01:00:36Z"}]}
{"id":"kn5000-y18","title":"MAME: Audio subsystem emulation milestone","notes":"Track completion of audio subsystem emulation for MAME.\n\n## Required Components\n- [ ] Sub CPU emulation (ROM at 0xFE0000)\n- [ ] Inter-CPU latch communication (0x120000)\n- [ ] Payload transfer from Main CPU\n- [ ] DSP effects processing\n- [ ] Tone generator/voice allocation\n- [ ] DAC output\n\n## Related Issues\n- kn5000-1oy: DSP effects processing\n- kn5000-xv2: DSP IC311 documentation\n- kn5000-xel: DAC IC310 documentation\n- kn5000-061: Main to Sub CPU command protocol\n\n## Success Criteria\n- Sub CPU boots from payload\n- Basic sound output works\n- MIDI input produces audio","status":"open","priority":1,"issue_type":"epic","owner":"juca@members.fsf.org","created_at":"2026-01-31T00:07:13.8608741-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-01-31T00:07:13.8608741-03:00","comments":[{"id":130,"issue_id":"kn5000-y18","author":"Felipe Correa da Silva Sanches","text":"PROGRESS (Feb 18-19): Audio subsystem progress in MAME. Sine wave tone generator output working. Pitch derivation from register values implemented. Rhythm sequencer and event queue diagnostics added. Sub CPU payload transfer already working (524K HDMA, all 9 E1 blocks). Still need: real waveform ROM playback, DSP effects processing, proper MIDI routing.","created_at":"2026-02-21T03:33:04Z"}]}
{"id":"kn5000-yhj","title":"Another World: Complete floppy code injection for KN5000 port","status":"open","priority":2,"issue_type":"task","owner":"juca@members.fsf.org","created_at":"2026-02-21T01:01:15.573193652-03:00","created_by":"Felipe Correa da Silva Sanches","updated_at":"2026-02-21T01:01:15.573193652-03:00","comments":[{"id":131,"issue_id":"kn5000-yhj","author":"Felipe Correa da Silva Sanches","text":"Another World KN5000 port (custom-roms/anotherworld) is at attempt 43. Recent work: ghost toggle fix, left panel header encoding fix, MAME driver serial fixes, button input debugging, NVRAM factory defaults, TX double buffering. Untracked files suggest new research: floppy-code-injection-analysis.md and aw_disasm.py tool. The floppy code injection approach aims to load custom code via the KN5000's floppy disk update mechanism.","created_at":"2026-02-21T04:01:27Z"}]}
{"id":"kn5000-z9k","title":"Extract hardware info from service manual schematics","description":"Analyze the KN5000 service manual (59 pages) to extract hardware architecture details. Focus on: CPU section (II-11), Control section (II-9), Block diagram (II-3/4), Control panel boards (II-35, II-38). Document IC pinouts, signal names, and interconnections.","notes":"Significant progress: Analyzed schematic pages II-9 to II-38. Documented main CPU (TMP94C241F), all memory ICs, control panel MCUs (M37471M2196S), button mappings, serial signals. Created hardware-architecture.md page.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T04:08:30.098941586-03:00","created_by":"fsanches","updated_at":"2026-02-28T01:17:09.168352934Z","closed_at":"2026-02-28T01:17:09.168352934Z","close_reason":"Completed: hardware-architecture.md created from schematic analysis. All 3 dependencies closed (bcn: MCU identified, jwk: serial pinout documented, xhi: rotary encoder analyzed). Key findings: main CPU TMP94C241F, all memory ICs, control panel MCUs M37471M2196S, button mappings, serial signals, tone generator section ICs. Additional schematic pages can be analyzed in future issues as needed.","dependencies":[{"issue_id":"kn5000-z9k","depends_on_id":"kn5000-bcn","type":"blocks","created_at":"2026-01-25T04:09:11.339879981-03:00","created_by":"fsanches"},{"issue_id":"kn5000-z9k","depends_on_id":"kn5000-jwk","type":"blocks","created_at":"2026-01-25T04:09:11.389632651-03:00","created_by":"fsanches"},{"issue_id":"kn5000-z9k","depends_on_id":"kn5000-xhi","type":"blocks","created_at":"2026-01-25T04:09:11.438689228-03:00","created_by":"fsanches"}],"comments":[{"id":132,"issue_id":"kn5000-z9k","author":"Felipe Correa da Silva Sanches","text":"STATUS (Feb 21): Significant progress already noted — hardware architecture page created from schematic analysis. Dependencies kn5000-bcn (control panel MCU identification) and kn5000-jwk (DATA/BCK serial pinout) both closed. Remaining dependency: kn5000-xhi (ROTA/ROTB rotary encoder circuit). The schematic findings have been instrumental for MAME driver development and control panel protocol work.","created_at":"2026-02-21T04:02:14Z"}]}
